{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"AprendiendoPythondesde cero","text":"<p>Bienvenido a mis apuntes sobre el lenguaje de programaci\u00f3n Python.</p> <p>Puedes acceder a las p\u00e1ginas de este cuaderno pulsando sobre el \u00edndice que hay en la barra lateral, o bien en los enlaces de la barra inferior azul.</p> <p>Tambi\u00e9n puedes presionar las siguientes teclas:</p> <ul> <li>tecla N para ir a la p\u00e1gina siguiente (next) </li> <li>tecla P  para ir a la p\u00e1gina anterior (previous)</li> </ul> <p>Este cuaderno est\u00e1 en desarrollo, y todav\u00eda incompleto.</p> <p></p> <p>Fecha \u00faltima actualizaci\u00f3n: 19-jul-2025</p>"},{"location":"001-01-Inicio.html","title":"\u00bfQue es Python?","text":"<p>Python es un lenguaje de programaci\u00f3n, es decir, un conjunto de reglas de sintaxis que debemos respetar cuando escribimos las instrucciones de un  programa, de forma que nuestra computadora las entienda y ejecute.</p>"},{"location":"001-01-Inicio.html#que-es-un-programa","title":"\u00bfQue es un programa?","text":"<p>En su forma m\u00e1s simple, un programa es un archivo de texto con instrucciones  para el ordenador.</p>"},{"location":"001-01-Inicio.html#cuantos-lenguajes-existen","title":"\u00bfCuantos lenguajes existen?","text":"<p>Para crear un programa, no existe un \u00fanico lenguaje universal. Con los lenguajes de programaci\u00f3n sucede lo mismo que con los idiomas de las  personas, que hay muchos; franc\u00e9s, ingl\u00e9s, espa\u00f1ol, chino, etc. </p> <p>Si acudimos a un navegador web e introducimos la siguiente pregunta:</p> <p>\u00bfCuantos lenguajes de programaci\u00f3n existen?</p> <p>Obtendremos como respuesta algo as\u00ed como:</p> <p>Se estima que hay m\u00e1s de 700 lenguajes en uso activo, sin tener en cuenta los que han quedado anticuados y ya no se usan.</p> <p>En resumen... a lo largo de la historia de los ordenadores se han inventado  miles de lenguajes. Podemos obtener una lista de los m\u00e1s relevantes acudiendo a la Wikipedia  e introduciendo como texto de b\u00fasqueda:</p> <p>Lista de lenguajes de programaci\u00f3n.</p>"},{"location":"001-01-Inicio.html#por-que-hay-tantos-lenguajes","title":"\u00bfPor que hay tantos lenguajes?","text":"<ul> <li> <p>Porque algunos han sido concebidos para determinadas tareas, para crear      p\u00e1ginas web, juegos, para crear programas de c\u00e1lculo cient\u00edfico,      etc\u00e9tera. Hay lenguajes para el mundo de los negocios, y otros para ser     usados en el desarrollo de la inteligencia artificial.</p> <p>Tambi\u00e9n hay lenguajes de prop\u00f3sito general, que podemos utilizar para resolver cualquier tipo de problema. Python es uno de ellos.</p> </li> <li> <p>Porque los primeros lenguajes de la historia fueron creados en la d\u00e9cada     de 1950, y desde entonces han pasado muchos a\u00f1os. La programaci\u00f3n de     computadoras es una ciencia en constante evoluci\u00f3n, y la aparici\u00f3n de nuevas     tecnolog\u00edas requiere que los lenguajes se adapten continuamente para dar      respuesta a nuevos retos.</p> <p>Algunos lenguajes llegan a ser muy populares, mientras que otros van quedando  en el olvido.</p> </li> <li> <p>Porque desde las universidades, desde empresas como Microsoft, Google      o Apple, e incluso desde iniciativas personales, se intenta lograr el mejor      lenguaje de programaci\u00f3n, que nos permita indicarle al ordenador lo que      queremos, de forma precisa y sencilla al mismo tiempo.</p> </li> </ul>"},{"location":"001-01-Inicio.html#cuales-son-los-lenguajes-mas-utilizados","title":"\u00bfCuales son los lenguajes m\u00e1s utilizados?","text":"<p>No hay forma de hacer un c\u00e1lculo exacto de cuantas personas utilizan cada  lenguaje, pero si hacemos b\u00fasquedas en Internet, podemos establecer un ranking  en funci\u00f3n del n\u00famero de p\u00e1ginas obtenidas. </p> <p>Existen varios estudios al respecto. Uno de los m\u00e1s conocidos es el de la empresa de consultor\u00eda TIOBE, que publica mensualmente  su ranking de popularidad de lenguajes. Ver https://www.tiobe.com/tiobe-index/.</p> <p>Otros estudios similares son:</p> <ul> <li>PYPL PopularitY of Programming Language</li> <li>RedMonk</li> </ul>"},{"location":"001-02-PSF.html","title":"\u00bfQuien est\u00e1 detr\u00e1s de todo esto?","text":"<p> <p>Python fue ideado en diciembre de 1989 por un programador holand\u00e9s llamado Guido Van Rossum.</p> <p>Entre 1990 y el a\u00f1o 2000, Python fue desarrollado por Guido y su equipo de colaboradores:</p> <ul> <li> <p>hasta 1995, como empleados de un centro de investigaci\u00f3n llamado     CWI, en Amsterdam, Paises Bajos.</p> </li> <li> <p>desde 1995 hasta 2000, formando parte del      CNRI,     un centro de investigaci\u00f3n en Estados Unidos.</p> </li> <li> <p>durante un breve per\u00edodo de tiempo, en el a\u00f1o 2000, como trabajadores      asociados a una empresa de consultor\u00eda llamada BeOpen.com</p> </li> </ul> <p>Cuando Python empez\u00f3 a convertirse en un lenguaje importante, cuyo mantenimiento requer\u00eda mucho trabajo y dedicaci\u00f3n, crearon la Python Software Foundation  (PSF), que es una entidad sin \u00e1nimo de lucro concebida para coordinar todo lo  relacionado con el lenguaje Python y la enorme comunidad de voluntarios que participan en el proyecto.</p> <p>Su p\u00e1gina web es https://www.python.org. En ella encontraremos herramientas, documentaci\u00f3n, y todo lo necesario para empezar a programar en lenguaje Python. El material es gratuito, ya que los ingresos de la PSF provienen de otras empresas patrocinadoras y aportaciones individuales de todo tipo de personas interesadas en contribuir al mantenimiento de Python.</p>"},{"location":"001-03-Herramientas.html","title":"\u00bfQue necesitamos para empezar a programar?","text":"<p>Tendremos que contar con un editor de textos para escribir las instrucciones de los programas. Preferiblemente, un editor especializado en la redacci\u00f3n de programas Python.</p> <p>Debe ir acompa\u00f1ado de un \"Int\u00e9rprete\", es decir, un programa que toma nuestras instrucciones y las convierte a ceros y unos binarios, lo que se conoce como lenguaje m\u00e1quina. El ordenador solo es capaz de ejecutar instrucciones formadas por ceros y unos.</p> <p>El editor de textos, el int\u00e9rprete, y algunos programas adicionales forman un conjunto que se denomina Entorno Integrado de Desarrollo. Tenemos que descargar de Internet todo este paquete de herramientas e instalarlo  en nuestro ordenador. Para ello, hacer lo siguiente:</p> <ul> <li>Abrir el navegador web y acudir a la p\u00e1gina de Python,      https://www.python.org.</li> <li>Pulsar en el enlace Downloads (descargas).</li> <li>Descargar el programa de instalaci\u00f3n adecuado a nuestro ordenador (Windows,     Mac, etc\u00e9tera)</li> <li>Acudir a la carpeta de descargas y hacer doble clic     con el rat\u00f3n sobre el archivo que hemos obtenido. Se trata de un programa     que, al ejecutarse, instalar\u00e1 el paquete en nuestra computadora.</li> <li>Durante la ejecuci\u00f3n de este programa instalador, seguir las instrucciones      que se muestran en la pantalla.</li> </ul>"},{"location":"001-04-Versiones.html","title":"Versiones de Python","text":"<p>Cuando descarguemos Python de Internet y lo instalemos en nuestra computadora, en alg\u00fan sitio veremos algo as\u00ed como:</p> <p>Python versi\u00f3n 3.14.0</p> <p>Al igual que pasa con los idiomas humanos, Python est\u00e1 evolucionando continuamente, y se incorporan nuevas palabras y formas de expresarse.  Peri\u00f3dicamente, la PSF publica una versi\u00f3n actualizada del paquete de herramientas y documentaci\u00f3n.  V\u00e9ase lista de versiones.</p>"},{"location":"001-04-Versiones.html#numeracion","title":"Numeraci\u00f3n","text":"<p>Cada versi\u00f3n lleva tres n\u00fameros. Por ejemplo, la 3.14.0 significa lo siguiente:</p> <ul> <li> <p>el primer n\u00famero es el 3, lo que indica que pertenece a la tercera      generaci\u00f3n de Python. Las sucesivas generaciones de lenguajes Python      han sido:</p> <ul> <li>Python 0 fueron las primeras versiones de prueba</li> <li>Python 1 fue presentado en enero de 1994</li> <li>Python 2 se present\u00f3 en octubre de 2000, con notables mejoras     respecto a la versi\u00f3n anterior.</li> <li>En diciembre de 2008 se lanz\u00f3 Python 3. El evento produjo una gran     pol\u00e9mica, porque cambiaba notablemente la sintaxis del lenguaje,     obligando a reescribir los programas existentes. Python 2 y 3     estuvieron conviviendo oficialmente hasta 2020, a\u00f1o en el que     la PSF anunci\u00f3 que dejaba de dar soporte a Python 2.</li> </ul> </li> <li> <p>el segundo n\u00famero, que en nuestro ejemplo es el 14, significa que, para el      lenguaje Python 3, se han ido creando sucesivas versiones, y esta es la     n\u00famero 14. A cada versi\u00f3n se van incorporando nuevas caracter\u00edsticas y      mejoras.</p> </li> <li> <p>el tercer n\u00famero, que en este caso es un cero, significa que es la      primera vez que se lanza esa versi\u00f3n. Si se detectan errores o hay que hacer     correcciones, se publicar\u00e1 la 3.14.1 seguida de la 3.14.2, y as\u00ed      sucesivamente.</p> </li> </ul>"},{"location":"001-04-Versiones.html#version-que-tenemos-instalada","title":"Versi\u00f3n que tenemos instalada","text":"<p>Algunos sistemas operativos vienen con Python preinstalado, y en otros, tenemos que obtenerlo. Incluso si ya lo tenemos, no hay inconveniente en que haya varias versiones de Python presentes en nuestro ordenador.</p> <p>\u00a1Importante! No debemos borrar la versi\u00f3n que viene de f\u00e1brica con nuestro  equipo, aunque sea una versi\u00f3n antigua. El buen funcionamiento de la m\u00e1quina  puede depender de su presencia.</p>"},{"location":"001-04-Versiones.html#las-peps","title":"Las PEPs","text":"<p>\u00bfQuien decide las novedades que se introducen con cada versi\u00f3n? Todo cambio  comienza con una propuesta de alg\u00fan miembro de la comunidad Python.  Estas propuestas son  conocidas como PEPs (Python Enhancement Proposals), y a cada una se le  asigna un n\u00famero. Podemos ver la lista de PEPs en esta enlace.</p> <p>Una vez admitidas a debate, el Consejo Rector de Python puede aprobarlas o  rechazarlas. Las aprobadas ser\u00e1n tenidas en cuenta en futuros lanzamientos.</p>"},{"location":"001-05-Nombre.html","title":"\u00bfQue significa la palabra Python?","text":"<p> La palabra Python significa serpiente pit\u00f3n en ingl\u00e9s. Sin embargo, aunque  el logotipo muestra dos serpientes estilizadas, el nombre del lenguaje no tiene  nada que ver con estos animales. Es un homenaje personal de Van Rossum a un  programa de humor de la televisi\u00f3n brit\u00e1nica BBC, llamado  Monty Python\u2019s Flying Circus. </p>"},{"location":"002-01-IDLE.html","title":"El editor","text":"<p>Si hemos instalado Python siguiendo las recomendaciones de los cap\u00edtulos anteriores, veremos que el paquete oficial de herramientas incluye un editor de texto llamado IDLE. El nombre es la abreviatura de Integrated Development  and Learning Environment. Sirve para escribir programas.</p> <p>Nota</p> <p>Los sistemas operativos Mac y Linux suelen venir con una versi\u00f3n Python preinstalada, pero sin IDLE. En el caso de los Mac, conviene instalar el paquete completo m\u00e1s actual. En Linux, tendremos que instalar IDLE por  separado, acudiendo al repositorio de software del sistema.</p> <p>Para iniciar IDLE hacemos lo siguiente: </p> <ul> <li> <p>si tenemos un ordenador Windows, escribir \"IDLE\" en el cuadro de b\u00fasqueda      del escritorio. </p> </li> <li> <p>si el ordenador es un Mac, ir a la carpeta \"Aplicaciones\" y abrir la      subcarpeta \"Python 3.1x\". Pulsar sobre el icono de \"IDLE\".</p> </li> <li> <p>en ordenadores Linux, buscar IDLE en la lista de programas.</p> </li> </ul> <p>Tras iniciar el editor, deber\u00edamos ver una ventana como esta:</p> <p></p> <p>El aspecto puede ser algo diferente dependiendo de nuestro sistema operativo.  En los ejemplos de este cuaderno, usamos un ordenador con sistema Linux. </p> <p>A esta ventana se le llama shell. El \u00e1rea de trabajo muestra inicialmente un mensaje que indica la versi\u00f3n del int\u00e9rprete de Python que tenemos instalada:</p> <pre><code>Python 3.13.3 ...\n</code></pre> <p>lo que va seguido de un indicador formado por tres s\u00edmbolos:</p> <pre><code>&gt;&gt;&gt;\n</code></pre> <p>A estos tres caracteres se les llama prompt, e indica que IDLE est\u00e1 esperando  a que tecleemos algo. Vamos a introducir el siguiente comando:</p> <pre><code>&gt;&gt;&gt; credits\n</code></pre> <p>y al pulsar Enter se muestra un mensaje de agradecimiento a todas las  personas y empresas que han participado en el desarrollo de Python:</p> <pre><code>Thanks to CWI, CNRI, BeOpen, Zope Corporation, the Python Software\nFoundation, and a cast of thousands for supporting Python\ndevelopment.  See www.python.org for more information.\n</code></pre> <p>Seguidamente se vuelve a mostrar el prompt para introducir m\u00e1s comandos:</p> <pre><code>&gt;&gt;&gt;\n</code></pre> <p></p> <p>Podemos cerrar la ventana de IDLE con el comando:</p> <pre><code>&gt;&gt;&gt; exit()\n</code></pre> <p>\u00bfPor que hay que escribir par\u00e9ntesis con el comando exit?</p> <p>El comando <code>exit</code> puede formar parte de las instrucciones de un programa, y sirve para indicarle al ordenador que la ejecuci\u00f3n ha terminado.</p> <p>Muchos comandos pueden ir acompa\u00f1ados de informaci\u00f3n adicional. Por ejemplo:</p> <pre><code>exit 0\n</code></pre> <p>Un c\u00f3digo cero significa que todo ha ido bien. Con otro c\u00f3digo distinto  de cero, le dir\u00edamos  al ordenador que el programa ha concluido, pero que ha habido alg\u00fan error.</p> <p>A este tipo de informaci\u00f3n que acompa\u00f1a a un comando se le llama  argumentos, y se debe escribir entre par\u00e9ntesis:</p> <pre><code>exit(0)\n</code></pre> <p>Cuando no indicamos nada, se escriben par\u00e9ntesis vac\u00edos.</p> <pre><code>exit()\n</code></pre> <p>y en este caso, se est\u00e1 asumiendo un c\u00f3digo cero.</p>"},{"location":"002-02-IDLE_Menu.html","title":"El men\u00fa de IDLE","text":"<p>Como veremos a lo largo de este cuaderno, IDLE es un programa que se ejecuta en m\u00faltiples ventanas en la pantalla:</p> <p></p> <p>Cada ventana tiene, en su parte superior, una barra con opciones de men\u00fa.  Pulsando en esas opciones, se despliega el men\u00fa correspondiente:</p> <p></p> <p>Veamos algunas opciones de men\u00fa de uso frecuente:</p> <ul> <li> <p>File &gt;&gt; Close Window. Cierra la ventana. Si cerramos todas las ventanas de      IDLE, finaliza el programa.</p> </li> <li> <p>File &gt;&gt; Exit IDLE. Cierra todas las ventanas y finaliza el programa.</p> </li> <li> <p>Help. Acceso a la documentaci\u00f3n de IDLE y de Python.</p> </li> </ul> <p>El comportamiento de IDLE se puede personalizar pulsando en el men\u00fa  Options &gt;&gt; Configure IDLE. En un ordenador Mac, hay que pulsar en el men\u00fa  IDLE &gt;&gt; Preferences.</p> <p>Esto abre la ventana para modificar opciones de configuraci\u00f3n:</p> <p></p>"},{"location":"002-03-IDLE_Ventanas.html","title":"Las ventanas de IDLE","text":"<p>IDLE permite modificar varios programas a la vez, cada uno en una ventana aparte. La ventana shell se muestra como ventana separada, para  introducir comandos:</p> <p></p> <p>Para crear un programa desde cero tenemos que abrir una nueva ventana.  Para ello, pulsar en el men\u00fa File &gt;&gt; New. </p> <p>Para modificar un programa ya existente, abrirlo pulsando en  el men\u00fa File &gt;&gt; Open. </p> <p>El men\u00fa File &gt;&gt; Recent Files muestra una lista de los \u00faltimos archivos que hemos tenido abiertos para su edici\u00f3n. Pulsando en uno de ellos, lo abrimos.</p> <p>Las ventanas se pueden manipular de acuerdo al mecanismo existente en nuestro  sistema operativo, Windows, Mac, Linux, etc\u00e9tera. En resumen:</p> <ul> <li> <p>Todas las ventanas tienen una barra de t\u00edtulo en su parte superior, que      muestra el nombre del programa. Si todav\u00eda no lo hemos guardado por primera      vez, aparecer\u00e1 la palabra Untitled (sin nombre).</p> </li> <li> <p>Cada ventana tiene su propia barra de opciones de men\u00fa. Las ventanas de     edici\u00f3n de programas tienen un men\u00fa diferente del de la ventana      shell, aunque algunas opciones coinciden. Por ejemplo, la opci\u00f3n     File &gt;&gt; exit IDLE est\u00e1 presente en todas las ventanas. </p> </li> <li> <p>Al pulsar sobre el men\u00fa window, se mostrar\u00e1 una lista de ventanas para      seleccionar una u otra. Otra forma de seleccionar una ventana es pulsar      sobre ella con el rat\u00f3n.</p> </li> <li> <p>Para mover una ventana de un lado al otro del escritorio, pulsar con el      rat\u00f3n sobre la barra de t\u00edtulo, y arrastrarla.</p> </li> <li> <p>Para cambiarla de tama\u00f1o, pulsar con el rat\u00f3n sobre un borde de la ventana y      arrastrar.</p> </li> <li> <p>Para maximizar la ventana para que ocupe toda la pantalla, pulsar en el      icono de maximizar, en la esquina superior de la ventana. </p> </li> <li> <p>Para restaurar una ventana maximizada a su tama\u00f1o original, pulsar de      nuevo, en el bot\u00f3n maximizar en la esquina superior.</p> </li> <li> <p>Para ocultar la ventana, pulsar en el bot\u00f3n de minimizar. Para restaurarla,     pulsar en la barra inferior del escritorio, en el icono de IDLE (aunque     esto depende del sistema operativo, la barra de iconos puede estar en el     borde superior de la pantalla, o en el margen izquierdo, en el caso de      algunos sistemas tipo Linux).</p> </li> <li> <p>Para cerrar una ventana, pulsar sobre el icono de cierre en la esquina     superior de la ventana, o sobre el men\u00fa File &gt;&gt; Close Window.</p> </li> </ul> <p>Si cerramos una ventana de edici\u00f3n, podemos reabrirla pulsando  en el men\u00fa File &gt;&gt; Recent files.</p> <p>Si cerramos todas las ventanas, incluido el shell, finaliza  la ejecuci\u00f3n de IDLE.</p> <p>Si cerramos la ventana shell pero mantenemos alguna ventana de edici\u00f3n abierta,  no finaliza IDLE. En este caso, podemos reabrir la ventana shell pulsando en el men\u00fa Run &gt;&gt; Python Shell.</p>"},{"location":"003-01-PPrograma.html","title":"Primer programa","text":"<p>Los programas son archivos de texto que contienen instrucciones. El primer paso es crear una carpeta en el disco de nuestro ordenador, para guardar los programas. Seguidamente, iniciamos IDLE para empezar a programar.</p>"},{"location":"003-01-PPrograma.html#crear-un-nuevo-programa","title":"Crear un nuevo programa","text":"<p>En el editor IDLE, pulsamos sobre el men\u00fa File &gt;&gt; New File. Aparece una  ventana de edici\u00f3n en blanco. En ella, escribimos lo siguiente:</p> <pre><code>print 15+3\n</code></pre> <p>Esta es la primera instrucci\u00f3n de nuestro programa. \u00bfQue significa? Queremos  que el ordenador calcule la suma de dos n\u00fameros y muestre el resultado en la  pantalla.</p> <p>En el mundo de la programaci\u00f3n, se dice imprimir en pantalla, y se  escribe en ingl\u00e9s, <code>print</code>. Esta es una herencia de los inicios de la inform\u00e1tica, cuando no hab\u00eda pantallas y todo se mostraba en papel. Los primeros programadores de la historia escrib\u00edan <code>print</code> en sus programas, y el t\u00e9rmino se sigue manteniendo.</p>"},{"location":"003-01-PPrograma.html#diferencias-entre-python-2-y-python-3","title":"Diferencias entre Python 2 y Python 3","text":"<p>Python 3, presentado en 2008, cambi\u00f3 la sintaxis de la instrucci\u00f3n <code>print</code>. A la informaci\u00f3n a\u00f1adida se le llama argumentos de la operaci\u00f3n y deben  escribirse entre par\u00e9ntesis:</p> <pre><code>print( 15+3 )\n</code></pre> <p>A este tipo de operaciones a ejecutar, con los argumentos entre par\u00e9ntesis,  se les llama funciones. </p> <p>Podemos indicar varias cosas a mostrar. Cada una ser\u00e1 un argumento, y se  escriben separadas por comas:</p> <pre><code>print(15+3 , 20+7 , 12+28)\n</code></pre> <p>lo que calcular\u00eda tres sumas y mostrar\u00eda los tres resultados. Al aejecutarse, veremos lo siguiente en la pantalla:</p> <pre><code>18 27 40\n</code></pre>"},{"location":"003-01-PPrograma.html#nuestro-primer-programa","title":"Nuestro primer programa","text":"<p>El texto del programa va a tener cuatro instrucciones:</p> Primero.py<pre><code>print (15+3)\nprint (15-3)\nprint (15*3)\nprint (15/3)\n</code></pre> <p>Este es su aspecto en el editor. Como todav\u00eda no lo hemos guardado en el disco, su nombre es Untitled (sin t\u00edtulo):</p> <p></p> <p>Nota:</p> <p>Los ejemplos de este cuaderno se muestran como recuadro de color:</p> <pre><code>print (15+3)\nprint (15-3)\nprint (15*3)\nprint (15/3)\n</code></pre> <p>Al pasar el rat\u00f3n por el texto del ejemplo, en la esquina de la derecha  se muestra un icono .  Pulsando en el mismo, copiaremos el texto del ejemplo al portapapeles.</p> <p>Para probar estos ejemplos en nuestra computadora, tras copiar el texto  al portapapeles, ir al editor IDLE, y pulsar en el  men\u00fa Edit &gt;&gt; Copy para copiar el texto  en la ventana del editor.  </p> <p>En este programa tenemos cuatro l\u00edneas de texto, y cada una de ellas es una  instrucci\u00f3n a ejecutar. Tambi\u00e9n se les llama \"sentencias\". Se ejecutar\u00e1n en secuencia, una a continuaci\u00f3n de otra.</p> <p>Tras completar el texto del programa, pulsamos en el men\u00fa File &gt;&gt; Save y  lo guardamos como <code>Primero.py</code> (o con otro nombre, si es nuestro deseo).  Los programas Python son archivos de texto con el sufijo <code>.py</code></p> <p>Debemos fijarnos en que, al crear un programa nuevo o modificar uno ya existente, mientras no guardemos los cambios, en la barra de t\u00edtulo de la  ventana se mostrar\u00e1 un asterisco junto al nombre del archivo, como advertencia.</p>"},{"location":"003-01-PPrograma.html#numeros-de-linea","title":"N\u00fameros de l\u00ednea","text":"<p>En muchos ejemplos de este cuaderno se muestran las l\u00edneas numeradas en el margen izquierdo:</p> Primero.py<pre><code>print (15+3)\nprint (15-3)\nprint (15*3)\nprint (15/3)\n</code></pre> <p>Estos n\u00fameros de l\u00ednea no es algo que tengamos que teclear. </p> <p>IDLE tambi\u00e9n puede mostrar los n\u00fameros de l\u00ednea en el margen izquierdo de la ventana. Si no est\u00e1n visibles, activarlos con el men\u00fa Options &gt;&gt; Show line  numbers.</p>"},{"location":"003-01-PPrograma.html#ejecutar-programa","title":"Ejecutar programa","text":"<p>Una vez guardado el texto del programa, vamos a ejecutarlo.  Los resultados se mostrar\u00e1n en la ventana shell.  Seleccionamos la ventana de edici\u00f3n, y pulsamos en el men\u00fa Run &gt;&gt; Run  Module.</p> <p>\u00bfQue es un m\u00f3dulo?</p> <p>Un programa Python complejo, con muchas instrucciones, puede dividirse en  varios archivos. Diremos que tenemos varios \"m\u00f3dulos\". Cada m\u00f3dulo puede ejecutarse por separado, o todos a la vez.</p> <p>Al ejecutar nuestro primer ejemplo, en la ventana shell se muestra un mensaje:</p> <pre><code>=========== RESTART: /carpeta/prueba.py ==========\n</code></pre> <p>... lo que indica que estamos ejecutando desde cero (restart) el archivo que se indica.</p> <p>Seguidamente se muestra el resultado tras ejecutar las cuatro instrucciones:</p> <pre><code>18\n12\n45\n5.0\n</code></pre> <p>y al terminar el programa, se recupera el prompt <code>&gt;&gt;&gt;</code>.</p>"},{"location":"003-01-PPrograma.html#explicacion-del-programa","title":"Explicaci\u00f3n del programa","text":"<p>En este ejemplo, a cada llamada a la funci\u00f3n <code>print()</code> le pasamos como argumento una expresi\u00f3n aritm\u00e9tica:</p> <pre><code>print(15+3)\n</code></pre> <p>La ejecuci\u00f3n de cada sentencia se hace en dos pasos:</p> <ul> <li> <p>primero se calculan los argumentos a pasar a la funci\u00f3n print(), que      en este caso, es un \u00fanico argumento:</p> <pre><code>15+3\n</code></pre> </li> <li> <p>seguidamente se llama a <code>print()</code> pas\u00e1ndole el resultado de evaluar los     argumentos:</p> <pre><code>print(18)\n</code></pre> </li> </ul>"},{"location":"003-01-PPrograma.html#expresiones","title":"Expresiones","text":"<p>Las expresiones a evaluar est\u00e1n formadas por operandos (en este ejemplo,  los n\u00fameros 15 y 3) y por operadores. Los operadores aritm\u00e9ticos b\u00e1sicos son:</p> <ul> <li>suma: <code>+</code></li> <li>resta: <code>-</code></li> <li>multiplicaci\u00f3n: <code>*</code></li> <li>divisi\u00f3n: <code>/</code></li> </ul> <p>\u00bfPor que se usa un asterisco para la multiplicaci\u00f3n en lugar del s\u00edmbolo \u00d7  del aspa? Por dos motivos:</p> <ul> <li>El s\u00edmbolo \u00d7 del aspa se confunde f\u00e1cilmente con la letra \"x\".</li> <li>En el teclado de nuestro ordenador tenemos la letra x, pero no el aspa.</li> </ul>"},{"location":"003-01-PPrograma.html#numeros-con-decimales","title":"N\u00fameros con decimales","text":"<p>El resultado de las divisiones suele ser un n\u00famero con decimales. Salvo que  indiquemos lo contraio, Python siempre muestra esos decimales,  aunque en algunos casos, como en este ejemplo, sea <code>.0</code></p> <p>En lugar de la coma, se usa el punto decimal, al estilo anglosaj\u00f3n. </p> <p>La coma decimal</p> <p>El uso de la coma o el punto para separar los decimales, depende del pa\u00eds donde vivimos. V\u00e9ase Wikipedia</p> <p>En l\u00edneas generales:</p> <ul> <li>En Europa, Latinoam\u00e9rica y buena parte de Africa, se usa la coma</li> <li>En Reino Unido, USA, Centroam\u00e9rica, Africa oriental, China e India, se     usa el punto</li> </ul> <p>Al ejecutar un programa, Python muestra los resultados usando el punto  decimal, aunque existe la posibilidad de cambiarlo por una coma,  para mejorar la presentaci\u00f3n. En la edici\u00f3n de programas y escritura  de instrucciones siempre se usa el punto. </p> <pre><code>print( 1.5 * 2 )\n</code></pre>"},{"location":"003-01-PPrograma.html#marca-de-los-miles","title":"Marca de los miles","text":"<p>En la edici\u00f3n de programas, las marcas para separar los miles, millones,  etc\u00e9tera, no se escriben:</p> <pre><code>print (1500+300)\n</code></pre> <p>Aunque hay un truco. Si insertamos un car\u00e1cter de subrayado <code>_</code> en un n\u00famero,  este car\u00e1cter ser\u00e1 ignorado:</p> <pre><code>print(15_387.5 * 2)\n</code></pre> <p>Estos caracteres de subrayado se pueden poner en cualquier lugar del n\u00famero:</p> <pre><code>print(12_34_63)\n</code></pre> <p>lo que equivale a:</p> <pre><code>print(123463)\n</code></pre> <p>Pero no podemos ponerlo como sufijo o prefijo de un n\u00famero. Lo siguiente es un error:</p> <pre><code>print( _387.5 * 2 )\n</code></pre>"},{"location":"003-02-Errores.html","title":"Errores","text":"<p>Cuando editamos un programa, a veces cometemos errores. \u00bfQue pasa si  escribimos mal una instrucci\u00f3n? La ejecuci\u00f3n del programa se detendr\u00e1 y se mostrar\u00e1 un mensaje para advertirnos de que ha habido un fallo. </p> <p>Por ejemplo, supongamos que se nos olvida poner los par\u00e9ntesis de la instrucci\u00f3n <code>print()</code>:</p> <pre><code>print 5+3\n</code></pre> <p>en lugar del resultado de la suma, veremos lo siguiente:</p> <pre><code>SyntaxError: Missing parentheses in call to 'print'. Did you mean print(...)?\n</code></pre> <p>De todas formas, antes de ejecutarlo, tenemos que guardarlo. IDLE detectar\u00e1 el  fallo, nos avisar\u00e1, y el programa no llegar\u00e1 a guardarse ni a ejecutarse.</p> <p>Pero no todos los errores son de sintaxis. Por ejemplo, el siguiente programa...</p> PrimeroConError.py<pre><code>print (15+0)\nprint (15-0)\nprint (15*0)\nprint (15/0)\n</code></pre> <p>... muestra los tres primeros resultados, pero al llegar a la cuarta sentencia,  obtenemos:</p> <p></p> <p>\u00bfQue significa este mensaje tan siniestro? El texto del error es:</p> <pre><code>Traceback (most recent call last):\n  File \"/usr/lib/python3.13/idlelib/run.py\", line 590, in runcode\n    exec(code, self.locals)\n    ~~~~^^^^^^^^^^^^^^^^^^^\n  File \"/carpeta/PrimeroConError.py\", line 4, in &lt;module&gt;\n    print (15/0)\n           ~~^~\nZeroDivisionError: division by zero\n</code></pre> <p>Veamos algunas pistas:</p> <ul> <li> <p>La palabra Traceback indica que se ha producido un fallo en el programa     y que el int\u00e9rprete de Python est\u00e1 analiz\u00e1ndolo.</p> </li> <li> <p>Tenemos que fijarnos en la \u00faltima l\u00ednea para entender lo que ha pasado:</p> <pre><code>ZeroDivisionError: division by zero\n</code></pre> <p>Una divisi\u00f3n es una operaci\u00f3n equivalente a hacer un reparto. \u00bfSe puede repartir 15 unidades entre cero personas? No hay reparto. Dividir un n\u00famero entre cero no siempre es una buena idea.</p> </li> <li> <p>La dos l\u00edneas antes de la \u00faltima muestran la instrucci\u00f3n infractora:</p> <pre><code>print (15/0)\n</code></pre> </li> <li> <p>Y antes se muestra el archivo y n\u00famero de l\u00ednea donde se ha encontrado     la sentencia culpable:</p> <pre><code>File \"/carpeta/PrimeroConError.py\", line 4,\n</code></pre> </li> </ul> <p>\u00bfQue podemos hacer si se produce un error?  Corregir el programa y volver a ejecutarlo.</p>"},{"location":"003-03-Sintaxis.html","title":"Reglas de sintaxis","text":"<p>Una vez completado nuestro primer programa, repasemos algunas reglas de sintaxis.</p>"},{"location":"003-03-Sintaxis.html#sangria","title":"Sangr\u00eda","text":"<p>Se denomina sangr\u00eda al hecho de a\u00f1adir espacios en blanco a la izquierda de una sentencia:</p> <pre><code>sentencia 1\nsentencia 2\n    sentencia 3\n    sentencia 4\nsentencia 5\nsentencia 6\n</code></pre> <p>En otros lenguajes de programaci\u00f3n, esto es puramente decorativo, y se usa para facilitar el examen de los programas, para lograr que el texto sea lo los m\u00e1s  claro posible. </p> <p>Pero en En Python, la sangr\u00eda tiene un prop\u00f3sito especial. Se utiliza para  delimitar bloques de sentencias en situaciones especiales. Si sangramos una  l\u00ednea cuando no es necesario, obtendremos un mensaje de error  y se detendr\u00e1 el programa, mostrando algo as\u00ed como:</p> <pre><code>SyntaxError: unexpected indent\n</code></pre> <p>Regla de oro: la primera l\u00ednea de texto de un programa nunca puede estar  sangrada.</p>"},{"location":"003-03-Sintaxis.html#lineas-en-blanco","title":"L\u00edneas en blanco","text":"<p>En un programa Python, podemos a\u00f1adir l\u00edneas en blanco a nuestro gusto, para  delimitar visualmente bloques de sentencias:</p> <pre><code>print (15+3)\nprint (15-3)\n\nprint (15*3)\nprint (15/3)\n</code></pre>"},{"location":"003-03-Sintaxis.html#tokens-y-espaciado","title":"Tokens y espaciado","text":"<p>Una sentencia se divide en tokens:</p> <pre><code>print\n(\n15\n+\n3\n)\n</code></pre> <p>Podemos insertar espacios entre tokens, o no hacerlo, a nuestra voluntad. Las  dos siguientes sentencias son equivalentes:</p> <pre><code>print(15+3)\nprint ( 15 + 3 )\n</code></pre> <p>\u00bfQue estilo utilizar? El que m\u00e1s nos agrade, pero no hay que perder de vista que debemos procurar que el texto de nuestros programas sea de f\u00e1cil lectura.</p> <p>\u00a1Cuidado! Los espacios son obligatorios cuando, al unir dos tokens, se formar\u00eda uno nuevo. No es lo mismo</p> <pre><code>15 17\n</code></pre> <p>que</p> <pre><code>1517\n</code></pre> <p>En el primer caso tenemos dos n\u00fameros, 15 y 17, y en el segundo, un n\u00famero, 1517.    </p>"},{"location":"003-03-Sintaxis.html#mayusculas-y-minusculas","title":"May\u00fasculas y min\u00fasculas","text":"<p>Python es un lenguaje estricto en el uso de may\u00fasculas y min\u00fasculas. La palabra <code>print</code> se escribe en min\u00fasculas. </p> <p>Las palabras <code>print</code> y <code>Print</code> se consideran diferentes. La primera es una  funci\u00f3n. La segunda no tiene ning\u00fan significado especial para Python.</p> <p>En l\u00edneas generales, es habitual dar preferencia a las min\u00fasculas, aunque a veces es cuesti\u00f3n de estilo personal.</p> <p>En resumen:</p> <ul> <li>una \"A\" may\u00fascula y una min\u00fascula son caracteres diferentes</li> <li>una \"\u00e1\" con acento y otra sin acento, son caracteres diferentes</li> </ul>"},{"location":"003-03-Sintaxis.html#parentesis-vacios","title":"Par\u00e9ntesis vac\u00edos","text":"<p>Toda funci\u00f3n puede ir acompa\u00f1ada de argumentos, que se escriben entre par\u00e9ntesis. Si invocamos la funci\u00f3n sin argumentos, no debemos olvidar escribir  par\u00e9ntesis vac\u00edos:</p> Primero.py<pre><code>print (15+3)\nprint (15-3)\nprint ()\nprint (15*3)\nprint (15/3)\n</code></pre> <p>La funci\u00f3n print, sin argumentos, sirve para mostrar una l\u00ednea en blanco.</p> <pre><code>18\n12\n\n45\n5.0\n</code></pre>"},{"location":"003-03-Sintaxis.html#la-salida-de-print","title":"La salida de print()","text":"<p>En resumen, la funci\u00f3n <code>print()</code> puede recibir cero, uno o varios argumentos, separados por comas:</p> <pre><code>print(1)\nprint()\nprint(1, 2, 3)\n</code></pre> <ul> <li>En la primera sentencia, muestra el dato seguido de un salto de l\u00ednea. </li> <li>En la segunda, no muestra nada, pero produce el salto de l\u00ednea </li> <li>En la tercera, muestra los argumentos separados por un espacio, y al     final, a\u00f1ade el salto de l\u00ednea.</li> </ul> <p>Con lo que obtenemos:</p> <pre><code>1\n\n1 2 3\n</code></pre> <p><code>print()</code> se puede configurar para que no incluya los espacios o el salto de l\u00ednea. Lo veremos en su momento.</p>"},{"location":"003-04-Comentarios.html","title":"Comentarios","text":""},{"location":"003-04-Comentarios.html#anadir-comentarios","title":"A\u00f1adir comentarios","text":"<p>A veces nos encontramos con programas escritos por otras personas, y cuya  complejidad dificulta el examen del programa. Otras veces se trata de trabajos  realizados por nosotros mismos hace ya tiempo, y no resulta f\u00e1cil recordar el prop\u00f3sito original.</p> <p>Para facilitar la revisi\u00f3n de un programa, conviene a\u00f1adir anotaciones  explicando lo que tratamos de hacer:</p> Comentarios.py<pre><code># Programa para demostrar el uso\n# de operaciones de c\u00e1lculo\n\nprint( 15 + 3 )   # suma\nprint( 15 - 3 )   # resta\nprint( 15 * 3 )   # multiplicaci\u00f3n\nprint( 15 / 3 )   # divisi\u00f3n\n</code></pre> <p>Cuando Python encuentra un token que empieza o consiste en un s\u00edmbolo \"#\", todo lo que viene a continuaci\u00f3n, hasta el final de la l\u00ednea, ser\u00e1 ignorado al  ejecutar el programa. A esto se le denomina \"comentarios\".</p> <p>Los comentarios pueden ocupar toda una l\u00ednea del texto, o acompa\u00f1ar a una  sentencia. Lo que hay a la izquierda del s\u00edmbolo \"#\" se considera como  sentencia a ejecutar. Lo que hay a la derecha, se ignorar\u00e1.</p>"},{"location":"003-04-Comentarios.html#bloques-de-comentarios","title":"Bloques de comentarios","text":"<p>Si tenemos un bloque de comentarios muy grande, marcar todas las l\u00edneas una a una puede resultar un poco \"pesado\".  En lenguaje Python hay un truco para evitarlo. Consiste en delimitar entre triples comillas el bloque de texto a ignorar: </p> Comentarios2.py<pre><code>\"\"\"\nPrograma para demostrar el uso\nde operaciones de c\u00e1lculo\n\"\"\"\n\nprint( 15 + 3 )   # suma\nprint( 15 - 3 )   # resta\nprint( 15 * 3 )   # multiplicaci\u00f3n\nprint( 15 / 3 )   # divisi\u00f3n\n</code></pre> <p>Tambi\u00e9n valen los ap\u00f3strofos:</p> Comentarios3.py<pre><code>'''\nPrograma para demostrar el uso\nde operaciones de c\u00e1lculo\n'''\n\nprint( 15 + 3 )   # suma\nprint( 15 - 3 )   # resta\nprint( 15 * 3 )   # multiplicaci\u00f3n\nprint( 15 / 3 )   # divisi\u00f3n\n</code></pre> <p>\u00bfComillas o ap\u00f3strofos?</p> <p>En lenguaje Python, las comillas y ap\u00f3strofos se usan para delimitar texto, en este caso, comentarios. Ambas opciones son v\u00e1lidas, pero si  comenzamos con comillas, hay que finalizar con comillas. Si comenzamos con ap\u00f3strofos, hay que finalizar con ap\u00f3strofos.</p> <p>A tener en cuenta:</p> <ul> <li> <p>No debemos confundir el car\u00e1cter de ap\u00f3strofo ' con el de acento \u00b4     ni con el de acento invertido `. Examinemos el teclado para      localizar cada uno de ellos.</p> </li> <li> <p>No confundir el t\u00e9rmino ap\u00f3strofo con ap\u00f3strofe, que es una figura     literaria.</p> </li> <li> <p>En la literatura inform\u00e1tica, es frecuente referirse a los ap\u00f3strofos     como comillas simples, en oposici\u00f3n a las comillas ordinarias, o     comillas dobles.</p> </li> </ul>"},{"location":"003-04-Comentarios.html#comentar-sentencias","title":"Comentar sentencias","text":"<p>Adem\u00e1s de su prop\u00f3sito de documentaci\u00f3n, los comentarios tienen otro uso  especial. Sirven para anular sentencias que no  queremos ejecutar, pero tampoco borrarlas del programa. </p> <p>Es algo t\u00edpico, por ejemplo, en situaciones donde lo que queremos es a\u00f1adir alguna instrucci\u00f3n \"de pruebas\" para verificar que el programa  funciona bien.  Cuando completamos la fase de pruebas, podemos quitar esas sentencias,  o dejarlas como comentarios.</p> <pre><code># Programa para demostrar el uso\n# de operaciones de c\u00e1lculo\n\nprint( 15 + 3 )\nprint( 15 * 3 )\n\n# print( 15 - 3 )\n# print( 15 / 3 )\n</code></pre> <p>Si en el futuro necesitamos revisar el programa, podemos quitar ese s\u00edmbolo <code>#</code> y seguir haciendo pruebas.</p> <p>A esto se le llama comentar instrucciones, y cuando quitamos el s\u00edmbolo <code>#</code>, las estamos descomentando.</p> <p>IDLE cuenta con una ayuda para comentar un bloque de sentencias:</p> <ul> <li>seleccionar el texto a comentar</li> <li>pulsar en el men\u00fa Format &gt;&gt; Comment</li> <li>autom\u00e1ticamente, se a\u00f1adir\u00e1 un car\u00e1cter <code>#</code> a todas las l\u00edneas del     texto seleccionado. </li> </ul> <p>Tambi\u00e9n tenemos la operaci\u00f3n inversa, el men\u00fa Format &gt;&gt; Uncomment</p>"},{"location":"003-05-Incompletas.html","title":"Sentencias incompletas","text":"<p>En principio, cada sentencia se escribe en l\u00ednea aparte:</p> Primero.py<pre><code>print (15+3)\nprint (15-3)\nprint (15*3)\nprint (15/3)\n</code></pre> <p>Pero... \u00bfque pasa si tenemos una sentencia muy larga?</p> <pre><code>print ( 1512+33*20 , 1512-33*20 , 1512*33*20 , 1512/33*20 )\n</code></pre> <p>En principio, ser\u00eda preferible escribir cuatro sentencias <code>print()</code>. Pero esto a\u00f1ade un salto de l\u00ednea tras cada ejecuci\u00f3n de <code>print()</code>. Supongamos que  queremos mostrar los resultados en la misma l\u00ednea de la pantalla.</p> <p>La posible soluci\u00f3n es escribir la llamada a <code>print()</code> con los cuatro argumentos. Nos gustar\u00eda poder escribir:</p> <pre><code>print ( 1512+33*20 , \n        1512-33*20 , \n        1512*33*20 , \n        1512/33*20 \n        )\n</code></pre> <p>... lo cual es m\u00e1s claro. Pero \u00bfpodemos tener una sentencia que ocupa varias lineas en el texto del programa?</p> <p>La primera l\u00ednea es una sentencia incompleta. Y el resto de l\u00edneas, si las analizamos por separado, no son sentencias v\u00e1lidas. El int\u00e9rprete de Python  deber\u00eda mostrar un error al intentar ejecutar la primera l\u00ednea, porque falta el par\u00e9ntesis de cierre.</p> <p>Pero, en las reglas de sintaxis de Python,  se hace una excepci\u00f3n. Todo par\u00e9ntesis de apertura <code>(</code> debe tener su correspondiente de cierre <code>)</code>, y hasta no encontrarlo,  el int\u00e9rprete tomar\u00e1 el texto de las siguientes l\u00edneas como parte de la  sentencia, hasta encontrar el par\u00e9ntesis de cierre.</p> <p>Por lo tanto, lo siguiente es v\u00e1lido:</p> Primero.py<pre><code>print (15+3)\nprint (15-3)\nprint ( 1512+33*20 , \n        1512-33*20 , \n        1512*33*20 , \n        1512/33*20 \n       )\nprint (15*3)\nprint (15/3)\n</code></pre> <p>Esta regla de sintaxis se aplica:</p> <ul> <li>para los par\u00e9ntesis <code>( )</code></li> <li>para los corchetes <code>[ ]</code></li> <li>para las llaves <code>{ }</code></li> </ul> <p>El uso de corchetes y llaves lo veremos m\u00e1s adelante.</p> <p>Existe un mecanismo adicional en el lenguaje Python. Si el \u00faltimo car\u00e1cter de un l\u00ednea del programa es una barra invertida:</p> <pre><code>print (\\\n15+3)\n</code></pre> <p>el int\u00e9rprete ignorar\u00e1 ese car\u00e1cter especial y el salto de l\u00ednea que viene a continuaci\u00f3n, con lo que antes de ejecutarse, la sentencia se convierte en:</p> <pre><code>print (15+3)\n</code></pre> <p>Este es un mecanismo anticuado y poco popular entre los programadores Python,  ya que tiene tres inconvenientes:</p> <ul> <li>la barra <code>\\</code> \"ensucia\" el texto del programa y lo hace m\u00e1s ilegible</li> <li>si, por descuido, hay un espacio en blanco al final de la l\u00ednea,     el car\u00e1cter <code>\\</code> deja de ser el \u00faltimo, y el mecanismo no funciona.</li> <li> <p>es incompatible con el uso de comentarios:</p> <pre><code>print (\\  # l\u00ednea incompleta\n15+3)\n</code></pre> <p>porque el car\u00e1cter <code>\\</code> ya no es el \u00faltimo. Y si lo ponemos al final,  formar\u00e1 parte de los comentarios y ser\u00e1 ignorado.</p> </li> </ul>"},{"location":"003-06-Ejecutar.html","title":"Ejecutar programas","text":"<p>Supongamos que un amigo nos pide que le escribamos un programa. Una vez  completada la tarea, le pasamos el archivo de texto con las instrucciones.</p> <p>Para poder ejecutarlo, tiene que instalar Python en su computadora. Pero...  \u00bfcomo poner en marcha el programa sin abrir el editor IDLE?  Nuestro amigo no necesita revisar las instrucciones (aunque puede hacerlo, si es su deseo). Lo que necesita es ir a la carpeta donde est\u00e1 el archivo y ejecutarlo haciendo doble clic.</p> <p>Cada sistema operativo funciona de forma diferente. Veamos como hacerlo.</p>"},{"location":"003-06-Ejecutar.html#windows","title":"Windows","text":"<p>Para ejecutar un programa haciendo doble clic con el rat\u00f3n sobre el archivo de texto, necesitamos que el  ordenador sepa que se trata de un programa Python. De todas formas, el nombre del programa ya le est\u00e1 orientando, gracias al sufijo .py :</p> <pre><code>mi_programa.py\n</code></pre> <p>Conviene que la primera l\u00ednea del texto sea un comentario especial indicando  la versi\u00f3n del int\u00e9rprete:</p> Primero.py<pre><code>#! python3\n\nprint( 15 + 3 )\nprint( 15 - 3 )\nprint( 15 * 3 )\nprint( 15 / 3 )\n</code></pre> <p>A esta l\u00ednea se le llama shebang, y los dos primeros caracteres del archivo han de ser:</p> <ul> <li>un car\u00e1cter <code>#</code></li> <li>un s\u00edmbolo <code>!</code></li> </ul>"},{"location":"003-06-Ejecutar.html#mac","title":"Mac","text":"<p>En los ordenadores Mac y Linux, la l\u00ednea shebang suele ser algo as\u00ed como:</p> <pre><code>#!/usr/bin/env python3\n</code></pre> <p>Para ejecutar el programa en un Mac, pulsar sobre el archivo con el bot\u00f3n  secundario del rat\u00f3n, y en el men\u00fa desplegable, seleccionar \"Abrir con ... \"  seguido de \"Python Launcher\".</p> <p>Python Launcher es un programa que forma parte del paquete de herramientas  Python para Mac, y que sirve para ejecutar programas Python sin necesidad de abrir el editor IDLE. </p> <p>\u00bfComo configurar Python Launcher para que se use siempre por defecto al hacer  doble clic sobre el programa? Hacer lo siguiente:</p> <ul> <li> <p>pulsar sobre el archivo .py con el bot\u00f3n secundario     del rat\u00f3n. En el men\u00fa desplegable, seleccionar \"obtener informaci\u00f3n\".</p> </li> <li> <p>en la ventana de informaci\u00f3n del archivo, pulsar en \"Abrir con\" y     seleccionar Python Launcher.</p> </li> </ul>"},{"location":"003-06-Ejecutar.html#linux","title":"Linux","text":"<p>Como ya hemos indicado, la l\u00ednea shebang es:</p> <pre><code>#!/usr/bin/env python3\n</code></pre> <p>Adem\u00e1s, tenemos que asignar permisos de ejecuci\u00f3n a nuestro fichero. Para ello:</p> <ul> <li>abrir un terminal de comandos del sistema operativo</li> <li> <p>asignar el permiso con el comando:</p> <pre><code>chmod +x /carpeta1/carpeta2/miprograma.py\n</code></pre> <p>siendo:</p> <ul> <li><code>chmod</code> es el comando para cambiar permisos</li> <li><code>+x</code> indica que queremos activar el permiso <code>exec</code> </li> <li><code>/carpeta1/carpeta2/</code> es la ruta de carpetas. Cambiarlo por la que     proceda</li> <li><code>miprograma.py</code> es el nombre del archivo. Sustituirlo por el nombre del      nuestro.</li> </ul> </li> </ul>"},{"location":"003-06-Ejecutar.html#ocultar-informacion-de-ejecucion","title":"Ocultar informaci\u00f3n de ejecuci\u00f3n","text":"<p>Cuando iniciamos un programa, haciendo doble clic sobre el mismo, en la ventana que se muestra aparece un mensaje de lo que se est\u00e1 ejecutando. Por ejemplo, el programa:</p> Primero.py<pre><code>print( 15 + 3 )\nprint( 15 - 3 )\nprint( 15 * 3 )\nprint( 15 / 3 )\n</code></pre> <p>Mostrar\u00eda en un Mac algo as\u00ed como:</p> <pre><code>Last login: Fri Jun 20 10:28:30 on ttys002\ncd '/Users/usuario/Programas/' &amp;&amp; '/usr/local/bin/python3' \n'/Users/usuario/Programas/Primero.py'  \n&amp;&amp; echo Exit status: $? &amp;&amp; exit 1\n\n18\n12\n45\n5.0\n</code></pre> <p>\u00bfComo suprimir estos mensajes tan molestos? No es posible, a menos que logremos cambiar la configuraci\u00f3n de la computadora. Pero podemos solucionarlo a\u00f1adiendo al programa alguna instrucci\u00f3n que diga \"borrar pantalla\". En Windows son dos  instrucciones:</p> <pre><code>import os\nos.system(\"cls\")\n</code></pre> <p>No hace falta que entendamos lo que significa. Ya lo veremos m\u00e1s adelante. Por ahora, basta con copiar y pegarlas al inicio de nuestro programa:</p> Primero.py<pre><code>import os\nos.system(\"cls\")\n\nprint( 15 + 3 )\nprint( 15 - 3 )\nprint( 15 * 3 )\nprint( 15 / 3 )\n</code></pre> <p>En un ordenador Mac o Linux, hay que escribir \"clear\" en lugar de \"cls\".</p> <p>En Windows, cls significa \"clear screen\"</p>"},{"location":"003-06-Ejecutar.html#evitar-que-la-ventana-se-cierre","title":"Evitar que la ventana se cierre","text":"<p>En algunos sistemas operativos, cuando finaliza la ejecuci\u00f3n del programa, la ventana se cierra autom\u00e1ticamente impidiendo ver los resultados. De hecho, en un programa sencillo, la ejecuci\u00f3n ser\u00e1 tan r\u00e1pida que la ventana se abrir\u00e1 y cerrar\u00e1 en una fracci\u00f3n de segundo.</p> <p>Podemos bloquear el cierre de la ventana a\u00f1adiendo la sentencia:</p> <pre><code>input()\n</code></pre> <p>lo que hace que se quede a la espera de que el usuario pulse Enter. </p> <p>El programa completo queda as\u00ed:</p> Primero.py<pre><code>#! python3\n\nimport os\nos.system(\"cls\")  \n\nprint( 15 + 3 )\nprint( 15 - 3 )\nprint( 15 * 3 )\nprint( 15 / 3 )\n\ninput()\n</code></pre> <p>En sistemas Mac/Linux cambiar\u00edan dos l\u00edneas:</p> Primero.py<pre><code>#!/usr/bin/env python3\n\nimport os\nos.system(\"clear\")  \n\nprint( 15 + 3 )\nprint( 15 - 3 )\nprint( 15 * 3 )\nprint( 15 / 3 )\n\ninput()\n</code></pre>"},{"location":"004-01-Expresiones.html","title":"Expresiones complejas","text":"<p>Hasta ahora hemos hecho algunas operaciones sencillas. Pero \u00bfque pasa si  queremos resolver un c\u00e1lculo m\u00e1s complejo? Comencemos como combinar varias operaciones en una \u00fanica expresi\u00f3n.</p>"},{"location":"004-01-Expresiones.html#expresiones-con-varias-operaciones","title":"Expresiones con varias operaciones","text":"<p>Una expresi\u00f3n puede estar formada por varias operaciones:</p> Expresiones.py<pre><code>print(5*3+4)\nprint(5+4*3)\n</code></pre> <p>Lo que, al ejecutarse, muestra:</p> <pre><code>19\n17\n</code></pre> <p>En el primer caso, multiplicamos 5 por 3, y al resultado, que es 15, le sumamos 4.</p> <p>Pero... un momento. La segunda sentencia deber\u00eda sumar <code>5+4=9</code> y multiplicarlo  por tres. \u00bfQue ha pasado?</p> <p>Lo que sucede es que, dentro de  una expresi\u00f3n, algunas operaciones tienen  precedencia sobre las otras. La multiplicaci\u00f3n y la divisi\u00f3n tienen prioridad  sobre la suma y resta, y se deben ejecutar antes. De esta forma, primero se multiplica <code>4*3=12</code> y el resultado se suma a 5.</p> <p>Para obligar al ordenador a cambiar las precedencias, o para asegurarnos de que el c\u00e1lculo se hace siguiendo el orden previsto, podemos usar par\u00e9ntesis:</p> <pre><code>print( (5+4) * 3 )\n</code></pre> <p>... y de esta forma, primero se hace la suma, si eso es lo que queremos.</p>"},{"location":"004-01-Expresiones.html#expresiones-anidadas","title":"Expresiones anidadas","text":"<p>Podemos \"anidar\" par\u00e9ntesis, unos dentro de otros:</p> <pre><code>print( ((5+4) * 3) + 7 )\n</code></pre> <p>De esta forma, primero se resuelven las subexpresiones internas.</p> <p>La palabra \"anidado\" indica que un elemento del programa est\u00e1 dentro de otro, y viene del ingl\u00e9s \"nested\" (nest=nido)</p>"},{"location":"004-01-Expresiones.html#funciones-que-devuelven-resultados","title":"Funciones que devuelven resultados","text":"<p>Una funci\u00f3n es una operaci\u00f3n con nombre. La funci\u00f3n <code>print</code> realiza su tarea cada vez que la invocamos por su nombre.</p> <p>Hay funciones que han sido concebidas para realizar un c\u00e1lculo y devolvernos un resultado. Por ejemplo, lo siguiente:</p> FuncionesConResultados.py<pre><code>print( max(5,17,3,4) )\nprint( pow(5,2) )\n</code></pre> <p>... invoca las funciones <code>max()</code> y <code>pow()</code>, y pasa los resultados a <code>print()</code>:</p> <pre><code>17\n25\n</code></pre> <p>La funci\u00f3n <code>max()</code> toma varios argumentos y devuelve el mayor de ellos, 17. </p> <p>La funci\u00f3n <code>pow()</code> toma dos datos y calcula la potencia del primero elevado al segundo (power of). El resultado de calcular 5 al cuadrado es 25.</p> <p>Una funci\u00f3n puede formar parte de una expresi\u00f3n:</p> FuncionesConResultados2.py<pre><code>print( max( pow(5,2), 10 ) + 2 )\n</code></pre> <p>Nuestro ordenador resolver\u00e1 esto de acuerdo al siguiente orden:</p> <ul> <li> <p>analiza el \u00fanico argumento pasado, que es una expresi\u00f3n compleja.      Consiste en:</p> <pre><code>max( pow(5,2), 10 ) + 2\n</code></pre> </li> <li> <p>antes de llamar a la funci\u00f3n <code>max()</code>, resuelve sus dos par\u00e1metros, que son:</p> <pre><code>pow(5,2)\n10\n</code></pre> </li> <li> <p>luego calcula <code>max(25,10)</code> = 25</p> </li> <li> <p>seguidamente suma 2 al resultado de <code>max()</code>, obteniendo 27</p> </li> <li> <p>ese resultado final se le pasa a <code>print()</code></p> </li> </ul> <p>El operador <code>**</code></p> <p>El c\u00e1lculo de potencias es una operaci\u00f3n que se puede escribir usando el operador <code>**</code>. Es lo mismo</p> <pre><code>print(pow(5,2))\n</code></pre> <p>que</p> <pre><code>print(5**2)\n</code></pre>"},{"location":"004-02-Variables.html","title":"Variables","text":"<p>El uso de expresiones que combinen operaciones nos resuelve un c\u00e1lculo  complejo... hasta cierto punto. Si la cosa se complica, hay que dividir el problema en varios pasos y memorizar los resultados parciales. Para ello, necesitamos usar variables</p>"},{"location":"004-02-Variables.html#creando-variables","title":"Creando variables","text":"<p>Una variable es un dato almacenado en la memoria RAM, al que asignamos un  nombre. Por ejemplo:</p> Variables.py<pre><code>dato1 = 5              # guardando un valor\ndato2 = dato1 * 2      # calculando y guardando el resultado\ndato3 = pow(dato2,2)   # otro c\u00e1lculo\n\n# Mostrar datos\nprint(dato1, dato2, dato3)\n</code></pre> <p>Lo que, al ejecutarse, muestra:</p> <pre><code>5 10 100\n</code></pre> <p>Veamos otro ejemplo m\u00e1s pr\u00e1ctico:</p> CalculoCirculo.py<pre><code>radio = 5\n\npi = 3.14159\nperimetro = radio * pi * 2\narea = pi * pow(radio, 2)\nprint (radio, perimetro, area)\n</code></pre> <p>Al ejecutar eso, se muestra:</p> <pre><code>5 31.4159 78.53975\n</code></pre> <p>y cambiando la primera sentencia, podemos calcular circunferencias de diferente tama\u00f1o.</p>"},{"location":"004-02-Variables.html#que-es-una-variable","title":"\u00bfQue es una variable?","text":"<p>Cuando escribimos:</p> <pre><code>radio = 5\npi    = 3.14159\n</code></pre> <p>los valores indicados se almacenan en la memoria RAM de nuestra computadora, junto a las instrucciones del programa, y se les asigna un nombre.  Una variable es un dato con nombre.</p> <p>Una vez creadas, podemos usar las variables en otras sentencias del programa:</p> <pre><code>print(radio)\n</code></pre> <p>lo que, en este ejemplo, equivale a:</p> <pre><code>print(5)\n</code></pre>"},{"location":"004-02-Variables.html#nombres-de-variables","title":"Nombres de variables","text":"<p>Una variable puede tener un nombre corto, o uno m\u00e1s descriptivo:</p> <pre><code>x = 0\nradio = 5\n</code></pre> <p>En general, conviene usar nombres descriptivos, pero para peque\u00f1os programas, son aceptables nombres como <code>a</code> , <code>b</code> , <code>c</code>  o como <code>x</code>, <code>y</code>, <code>z</code> </p>"},{"location":"004-02-Variables.html#asignaciones","title":"Asignaciones","text":"<p>El s\u00edmbolo <code>=</code> se denomina operador de asignaci\u00f3n, y sirve para asignar un valor a una variable. La sintaxis en general es:</p> <pre><code>variable = valor\n</code></pre> <p>A una variable le podemos asignar el valor de otra:</p> <pre><code>dato1 = 5\ndato2 = dato1\n</code></pre> <p>... con lo que tendremos dos variables cuyo valor es el mismo.</p> <p>Tambi\u00e9n podemos asignarle el resultado de un c\u00e1lculo:</p> <pre><code>perimetro = radio * pi * 2\n</code></pre> <p>En una asignaci\u00f3n, siempre se eval\u00faa en primer lugar lo que hay a la derecha del operador <code>=</code>, y seguidamente, se asigna el resultado a la variable.</p>"},{"location":"004-02-Variables.html#por-que-se-llaman-variables","title":"\u00bfPor que se llaman variables?","text":"<p>Una variable puede cambiar de valor durante la ejecuci\u00f3n del programa.  Por ejemplo:</p> <pre><code>numero = 0\nnumero = 1\nprint(numero)\n</code></pre> <p>Al llegar a la tercera sentencia, el valor a mostrar es 1. En la segunda sentencia, el valor de la variable cambia, y el dato anterior se pierde.</p>"},{"location":"004-02-Variables.html#incremento","title":"Incremento","text":"<p>Una variable puede incrementar (o decrementar) su valor mediante</p> Incremento.py<pre><code>dato = 20\nincremento = 5\ndato = dato + incremento\nprint(dato) \n</code></pre> <p>En la tercera sentencia tomamos el valor de la variable,  le sumamos el incremento, y el resultado se asigna a la misma variable,  sustituyendo el valor anterior. La cuarta sentencia muestra el valor original incrementado en 5.</p>"},{"location":"004-02-Variables.html#asignaciones-compuestas","title":"Asignaciones compuestas","text":"<p>Supongamos una variable x que usamos para llevar la cuenta de algo. De cuando en cuando hay que sumarle 1:</p> <pre><code>x = 0         # valor inicial de la cuenta\nx = x + 1     # x vale 1\nx = x + 1     # x vale 2\nx = x + 1     # x vale 3\n</code></pre> <p>cada vez que le sumemos 1, la variable ir\u00e1 incrementando su valor.</p> <p>Hay una forma abreviada de escribir esto:</p> <pre><code>x += n       equivale a x = x + n\nx -= n       equivale a x = x - n\nx *= n       equivale a x = x * n\nx /= n       equivale a x = x / n\n</code></pre> <p>... considerando que n puede ser un n\u00famero cualquiera. Por ejemplo, en un programa donde hagamos una cuenta atr\u00e1s, para decrementar la variable de control podemos escribir:</p> <pre><code>x = 10\nx -= 1\nx -= 1\n</code></pre> <p>y as\u00ed sucesivamente, hasta que la variable valga cero.</p>"},{"location":"004-02-Variables.html#asignaciones-multiples","title":"Asignaciones m\u00faltiples","text":"<p>En una \u00fanica sentencia podemos hacer varias asignaciones:</p> <pre><code>numero1, numero2 = 0, 1\n</code></pre> <p>A la izquierda del operador de asignaci\u00f3n ponemos la lista de variables donde vamos a guardar los datos. A la derecha, una lista de valores  o de expresiones a evaluar. Las variables de la izquierda deben ir separadas por comas, y las expresiones de la derecha, tambi\u00e9n.</p> <p>En la pr\u00e1ctica, resulta m\u00e1s limpio y claro escribir cada asignaci\u00f3n en una  sentencia por separado. No obstante, este mecanismo tiene algunas ventajas.  Por ejemplo, sirve para intercambiar los valores de dos variables:</p> Intercambio.py<pre><code>a\u00f1o1 = 2013\na\u00f1o2 = 2025\na\u00f1o1, a\u00f1o2 = a\u00f1o2 , a\u00f1o1\nprint (a\u00f1o1, a\u00f1o2)\n</code></pre> <p>Lo que, al ejecutarse, muestra:</p> <pre><code>2025 2013\n</code></pre> <p>\u00bfComo se resuelve una asignaci\u00f3n m\u00faltiple? En la tercera sentencia de este  ejemplo:</p> <pre><code>a\u00f1o1, a\u00f1o2 = a\u00f1o2 , a\u00f1o1\n</code></pre> <ul> <li> <p>primero resolvemos lo que hay a la derecha del operador <code>=</code>.     Obtenemos un paquete de datos con los valores de <code>a\u00f1o2</code> y <code>a\u00f1o1</code>, en ese     orden, es decir, 2025 y 2013</p> </li> <li> <p>con el operador <code>=</code> se desempaquetan los resultados y se van asignando      a las variables que hay a la izquierda</p> </li> <li>el paquete de datos provisional, se borra de la memoria una vez completada     la operaci\u00f3n.</li> </ul>"},{"location":"004-02-Variables.html#asignaciones-encadenadas","title":"Asignaciones encadenadas","text":"<p>En una asignaci\u00f3n, primero se resuelve lo que hay a la derecha del operador <code>=</code>. Esto nos permite escribir:</p> Asignaciones_encadenadas.py<pre><code>a = b = c = 27\nprint(a,b,c)\n</code></pre> <p>Lo que equivale a</p> <pre><code>c = 27\nb = c\na = b\nprint(a,b,c)\n</code></pre>"},{"location":"004-02-Variables.html#error-en-el-nombre-de-una-variable","title":"Error en el nombre de una variable","text":"<p>Cuando asignamos un valor a una variable, se comprueba si ya existe. En este caso, se modifica. Por el contrario, si la variable no existe, se crea una  nueva.</p> <p>Esto puede dar lugar al siguiente error:</p> <pre><code># programa para calculare circunferencias\n\nradio = 27\n\n# varias instrucciones\n\nRadio = 28\n\n# m\u00e1s instrucciones\n</code></pre> <p>Tenemos un programa con muchas instrucciones, y en alg\u00fan lugar hemos querido cambiar el valor de la variable. Pero por descuido, la hemos escrito con la  letra inicial en may\u00fasculas. Python no se quejar\u00e1. Pensar\u00e1 que se trata de una  nueva variable y seguir\u00e1 con la ejecuci\u00f3n del programa, que producir\u00e1 unos  resultados que no son los esperados.</p> <p>Hay que tener mucho cuidado con los nombres de variables.</p>"},{"location":"004-03-NombresVariables.html","title":"Nombres de variables","text":"<p>A los nombres de variables, funciones y otros elementos se les llama identificadores. Podemos establecer los nombres que nosotros queramos, pero  existen algunas reglas que debemos respetar:</p> <ul> <li> <p>Los identificadores no pueden incluir espacios, porque obtendr\u00edamos dos     tokens separados. Lo siguiente es un error:</p> <pre><code>suma total = 100\n</code></pre> <p>Es preferible escribir:</p> <pre><code>sumatotal = 100\n</code></pre> <p>o bien:</p> <pre><code>suma_total = 100\n</code></pre> </li> <li> <p>Los caracteres que forman un identificador pueden incluir d\u00edgitos num\u00e9ricos:</p> <pre><code>suma_a\u00f1o1 = 1234\nsuma_a\u00f1o2 = 5678\n</code></pre> <p>Pero el primer car\u00e1cter no puede ser un d\u00edgito num\u00e9rico:</p> <pre><code>suma1 = 0     # ok\n1suma = 0     # error\n</code></pre> </li> <li> <p>En el nombre de una variable Python se admite todo tipo de caracteres m\u00e1s all\u00e1 del      alfabeto anglosaj\u00f3n. Por ejemplo, la e\u00f1e, las vocales acentuadas o los      s\u00edmbolos matem\u00e1ticos:</p> <pre><code>a\u00f1o = 2010\n\u03c0 = 3.14159\n\u03a3 = 5 + 4\n</code></pre> <p>aunque el programa ser\u00eda m\u00e1s claro si escribimos:</p> <pre><code>PI = 3.14159\nsuma = 5 + 4\n</code></pre> </li> <li> <p>No se admiten los s\u00edmbolos incluidos en el juego de caracteres b\u00e1sico,     a excepci\u00f3n del car\u00e1cter de subrayado:</p> <pre><code>! \" # % &amp; ' ( ) * + , \u2212 . / : ; &lt; = &gt; ? [ \\ ] ^ { | } ~\n</code></pre> <p>Por ejemplo, lo siguiente es un error, ya que el gui\u00f3n representa la  operaci\u00f3n de resta aritm\u00e9tica</p> <pre><code>suma-total = 1234\n</code></pre> </li> <li> <p>Un nombre de variable no puede ser ninguna de las palabras especiales      reservadas por el lenguaje Python (keywords) para prop\u00f3sitos especiales.      Podemos averiguar cuales son esas palabras ejecutando en la ventana shell      de IDLE el siguiente comando:</p> <pre><code>&gt;&gt;&gt; help(\"keywords\")\n</code></pre> <p>Lo que muestra algo as\u00ed como:</p> <pre><code>Here is a list of the Python keywords:\n\nFalse               class               from                or\nNone                continue            global              pass\nTrue                def                 if                  raise\nand                 del                 import              return\nas                  elif                in                  try\nassert              else                is                  while\nasync               except              lambda              with\nawait               finally             nonlocal            yield\nbreak               for                 not\n</code></pre> </li> <li> <p>Aunque los nombres de funciones como <code>print</code> no son palabras reservadas,      conviene no usarlos para otro prop\u00f3sito, ya que ser\u00eda una fuente      de problemas.  Supongamos el siguiente programa:</p> <pre><code>print = 0\nprint(print)\n</code></pre> <p>Estamos creando una variable <code>print</code> que sustituye a la funci\u00f3n <code>print()</code>. Al ejecutar la segunda sentencia, el int\u00e9rprete de Python nos dir\u00e1 que <code>print()</code> ha dejado de ser una funci\u00f3n, para convertirse en variable, y  por lo tanto, no se puede resolver la llamada a la funci\u00f3n <code>print()</code>.</p> <p>No nos alarmemos. Las variables desaparecen de la memoria RAM al  finalizar la ejecuci\u00f3n del programa. La palabra <code>print</code> recuperar\u00e1 su prop\u00f3sito original.</p> </li> <li> <p>Como ya hemos visto, se distingue entre may\u00fasculas y min\u00fasculas.      Lo siguiente son dos variables diferentes (y un p\u00e9simo estilo de      programaci\u00f3n):</p> <pre><code>x = 0\nX = 0\n</code></pre> </li> </ul> <p>Los nombres de variables con m\u00e1s de una palabra pueden ser dif\u00edciles de leer:</p> <pre><code>importetotal = 100\n</code></pre> <p>Hay varias t\u00e9cnicas que podemos utilizar para hacerlas m\u00e1s legibles:</p> <ul> <li> <p>Estilo snake_case. Cada palabra est\u00e1 separada por un car\u00e1cter de subrayado     (tambi\u00e9n conocido como gui\u00f3n bajo):</p> <pre><code>importe_total = 100\n</code></pre> </li> <li> <p>Estilo PascalCase, as\u00ed llamado porque es t\u00edpico del lenguaje de      programaci\u00f3n Pascal. Se usan min\u00fasculas y cada palabra comienza con una      letra may\u00fascula:</p> <pre><code>ImporteTotal = 100\n</code></pre> </li> <li> <p>Estilo camelCase. Cada palabra, excepto la primera, comienza con una letra     may\u00fascula:</p> <pre><code>importeTotal = 100\n</code></pre> </li> </ul>"},{"location":"004-04-Modulos.html","title":"M\u00f3dulos","text":"<p>Ya hemos visto que un programa puede dividirse en varios m\u00f3dulos. Pero hay m\u00e1s. Podemos escribir m\u00f3dulos de utilidad que sean reutilizables en varios de nuestros proyectos.</p> <p>Veamos un ejemplo. Adem\u00e1s de las funciones proporcionadas por el lenguaje  Python, podemos dise\u00f1ar nuestras propias funciones. Supongamos que nos dedicamos a crear videojuegos.  Creamos una funci\u00f3n que, cada vez que la invocamos, hace sonar un disparo:</p> <pre><code>disparo(1)\ndisparo(2)\ndisparo(1)\n</code></pre> <p>le pasamos como argumento la duraci\u00f3n del sonido del disparo, en segundos.</p> <p>La funci\u00f3n se define de la siguiente manera:</p> <pre><code>def disparo(segundos):\n    ... instrucciones a ejecutar\n    ... cada vez que invocamos la funcion\n</code></pre> <p>y una vez definida, la invocamos mediante:</p> <pre><code>disparo(n)\n</code></pre> <p>Nuestra funci\u00f3n <code>disparo()</code> puede formar parte de un m\u00f3dulo llamado  <code>misfunciones.py</code>. Puede resultar muy \u00fatil en otros proyectos, as\u00ed que creamos una colecci\u00f3n de m\u00f3dulos de utilidad, en la que incluimos  el archivo <code>misfunciones.py</code>.</p> <p>Estas colecciones son paquetes de archivos conocidos como  biblioteca de m\u00f3dulos.</p>"},{"location":"004-04-Modulos.html#la-biblioteca-estandar","title":"La biblioteca est\u00e1ndar","text":"<p>Tras instalar Python en nuestro ordenador, tendremos disponible, entre otras  cosas:</p> <ul> <li>el editor IDLE</li> <li>el int\u00e9rprete de Python, que toma nuestros programas, los traduce a formato     binario de ceros y unos, y los ejecuta</li> <li>la biblioteca oficial de Python, con m\u00f3dulos que definen todo tipo     de funciones de utilidad, complementando las funciones aportadas por     el propio lenguaje</li> </ul> <p>A las funciones integradas en el lenguaje, que no forman parte de un m\u00f3dulo de biblioteca, como es el caso de <code>print()</code>,  se les llama funciones built-in.</p>"},{"location":"004-04-Modulos.html#que-modulos-tenemos-instalados","title":"\u00bfQue modulos tenemos instalados?","text":"<p>En nuestro equipo tendremos la biblioteca est\u00e1ndar de Python mas otras bibliotecas de tereceros que hayamos instalado. Podemos averiguar la lista de m\u00f3dulos a  nuestra disposici\u00f3n abriendo la ventana shell de IDLE y ejecutando el comando:</p> <pre><code>&gt;&gt;&gt; help(\"modules\")\n</code></pre>"},{"location":"004-04-Modulos.html#el-modulo-math","title":"El m\u00f3dulo <code>math</code>","text":"<p>Supongamos que queremos calcular un n\u00famero elevado al cuadrado:</p> <pre><code>numero=5\nprint( pow(numero,2) )\n</code></pre> <p>Lo que, al ejecutarse, muestra:</p> <pre><code>25\n</code></pre> <p>Pero... \u00bfcomo se calcula una raiz cuadrada? Python no tiene una funci\u00f3n  built-in que lo haga.</p> <p>Para suplir esta carencia, la biblioteca est\u00e1ndar incluye el m\u00f3dulo <code>math</code>, que define un buen n\u00famero de funciones de c\u00e1lculo. La funci\u00f3n <code>math.sqrt()</code> (abreviatura de square root) calcula ra\u00edces cuadradas.</p> <p>Para usar cualquier m\u00f3dulo, hay que incorporarlo a nuestro programa mediante la  sentencia <code>import</code>:</p> RaizCuadrada.py<pre><code>import math\nnumero = 25\nraiz = math.sqrt(numero)\nprint(raiz)\n</code></pre> <p>Lo que al ejecutarse muestra el resultado con decimales:</p> <pre><code>5.0\n</code></pre> <p>N\u00f3tese que las funciones de un m\u00f3dulo externo se invocan precedidas por el  nombre del m\u00f3dulo:</p> <pre><code>math.sqrt(numero)\n</code></pre>"},{"location":"004-04-Modulos.html#un-ejemplo","title":"Un ejemplo","text":"<p>Veamos un ejemplo pr\u00e1ctico:</p> Hipotenusa.py<pre><code># Calculo de hipotenusa\nimport math\n\ncateto1 = 4\ncateto2 = 3\n\nsuma_cuadrado_catetos = pow(cateto1,2) + pow(cateto2,2)\nhipotenusa = math.sqrt(suma_cuadrado_catetos)\n\nprint(hipotenusa)\n</code></pre> <p>Lo que, al ejecutarse, muestra 25.0</p> <p>Vemos que la funci\u00f3n <code>sqrt()</code> va precedida por el nombre del m\u00f3dulo, mientras que las funciones built-in, como <code>pow()</code>, no llevan ning\u00fan prefijo.</p>"},{"location":"004-04-Modulos.html#formas-de-importar-un-modulo","title":"Formas de importar un m\u00f3dulo","text":"<p>Si escribimos:</p> <pre><code>import math\n</code></pre> <p>estamos incorporando la palabra <code>math</code> al espacio de nombres reconocidos por nuestro programa. En consecuencia, todas las funciones de ese m\u00f3dulo han de ir precedidas por el nombre del mismo:</p> <pre><code>raiz = math.sqrt(numero)\n</code></pre> <p>Pero podemos importar la funci\u00f3n <code>sqrt()</code> directamente, sin necesidad de  importar el m\u00f3dulo completo:</p> <pre><code>from math import sqrt\nnumero = 25\nraiz = sqrt(numero)\nprint(raiz)\n</code></pre> <p>Vemos como cambia la sintaxis de la sentencia <code>import</code>:</p> <pre><code>import math               # importando todo el m\u00f3dulo\nfrom math import sqrt     # importando solo una funci\u00f3n\n</code></pre> <p>En el segundo caso, <code>math</code> ser\u00e1 un t\u00e9rmino desconocido para nuestro programa,  porque lo que hemos importado es la funci\u00f3n. Tenemos que escribir:</p> <pre><code>raiz = sqrt(numero)\n</code></pre> <p>en lugar de</p> <pre><code>raiz = math.sqrt(numero)\n</code></pre> <p>hay una tercera opci\u00f3n; incorporar los nombres de todas las funciones del m\u00f3dulo:</p> <pre><code>from math import *\n</code></pre> <p>En este caso, las referencias a las funciones siguen siendo sin prefijo:</p> <pre><code>raiz = sqrt(numero)\n</code></pre> <p>pero esta es una t\u00e9cnica algo peligrosa, porque estamos importando nombres sin controlar el proceso. Pueden producirse colisiones con otros identificadores ya existentes en nuestro programa.</p>"},{"location":"004-04-Modulos.html#alias","title":"Alias","text":"<p>Cuando importamos un m\u00f3dulo o una funci\u00f3n, podemos asignarles un alias y ponerlo en el espacio de nombres reconocidos por el programa:</p> <pre><code>import math as m\nfrom math import sqrt as raiz\n</code></pre> <p>Lo que nos obliga a escribir:</p> <pre><code>resultado = m.sqrt(25)\nresultado = raiz(25)\n</code></pre> <p>El uso de alias puede hacer m\u00e1s f\u00e1cil las cosas, pero su abuso puede dar lugar a un programa confuso, porque nuestro programa contendr\u00e1 identificadores  que no son est\u00e1ndar.</p>"},{"location":"005-01-Textos.html","title":"Textos","text":""},{"location":"005-01-Textos.html#incorporar-textos-al-programa","title":"Incorporar textos al programa","text":"<p>Volvamos a nuestro programa para medir un c\u00edrculo:</p> CalculoCirculo.py<pre><code>radio = 5\n\npi = 3.14159\nperimetro = radio * pi * 2\narea = pi * pow(radio, 2)\nprint (radio, perimetro, area)\n</code></pre> <p>La presentaci\u00f3n de los resultados es un poco triste, \u00bfno?</p> <pre><code>5 31.4159 78.53975\n</code></pre> <p>Vamos a intentar mejorarlo:</p> CalculoCirculo2.py<pre><code>radio = 5\n\npi = 3.14159\nperimetro = radio * pi * 2\narea = pi * pow(radio, 2)\nprint (\"Radio:\", radio)\nprint (\"Per\u00edmetro:\", perimetro)\nprint (\"\u00c1rea:\", area)\n</code></pre> <p>Lo que, al ejecutarse, muestra:</p> <pre><code>Radio: 5\nPer\u00edmetro: 31.4159\n\u00c1rea: 78.53975\n</code></pre> <p>En la sentencia:</p> <pre><code>print (\"Radio:\", radio)\n</code></pre> <p>le pasamos a <code>print()</code> dos argumentos, un texto, y el valor de una variable. Lo que se muestra es ambos objetos separados por un espacio en blanco y completados con un salto de l\u00ednea:</p> <pre><code>Radio: 5\n</code></pre> <p>Ambos a\u00f1adidos, el espacio en blanco y el salto de l\u00ednea, los incluye la funci\u00f3n <code>print()</code> de forma autom\u00e1tica.</p>"},{"location":"005-01-Textos.html#delimitadores","title":"Delimitadores","text":"<p>\u00bfPor que delimitamos el texto entre comillas? </p> <pre><code>print(\"Hola\")\n</code></pre> <p>Las comillas no forman parte del texto, pero son necesarias porque, sin ellas,  tendr\u00edamos un nombre de variable:</p> <pre><code>print(Hola)\n</code></pre> <p>... y al no existir la variable, obtendr\u00edamos un mensaje de error.</p> <p>Las comillas se usan como delimitador en las sentencias del programa, para saber donde comienza y termina el texto.</p> <p>\u00bfQue pasa si necesitamos usar comillas como parte del texto? Supongamos que  queremos mostrar la siguiente frase:</p> <pre><code>El rey Alfonso X \"el sabio\" naci\u00f3 en 1221.\n</code></pre> <p>No podemos escribir</p> <pre><code>print(\"El rey Alfonso X \"el sabio\" naci\u00f3 en 1221.\")\n</code></pre> <p>porque el segundo car\u00e1cter de comillas dejar\u00eda el texto en... </p> <pre><code>print(\"El rey Alfonso X \"\n</code></pre> <p>y el ordenador estar\u00eda esperando un par\u00e9ntesis de cierre, o una coma. Se  producir\u00eda un error.</p> <p>\u00bfComo solucionarlo? Podemos usar ap\u00f3strofos delimitadores, en lugar de comillas:</p> <pre><code>print('El rey Alfonso X \"el sabio\" naci\u00f3 en 1221.')\n</code></pre> <p>y ahora si funciona. Python admite comillas o ap\u00f3strofos, indistintamente, pero el delimitador usado como inicio del texto ha de ser el mismo que el del final.</p> <p>Tambi\u00e9n podemos hacer lo inverso:</p> <pre><code>print(\"El rey Alfonso X 'el sabio' naci\u00f3 en 1221.\")\n</code></pre> <p>\u00bfQue utilizar como delimitadores? \u00bfComillas o ap\u00f3strofos? El est\u00e1ndar oficial de Python parece ser los ap\u00f3strofos, pero muchos programadores prefieren las comillas, porque son de uso com\u00fan cuando tienes que utilizar varios lenguajes.</p>"},{"location":"005-01-Textos.html#variables-de-texto","title":"Variables de texto","text":"<p>Podemos crear variables que almacenen textos:</p> CalculoCirculo3.py<pre><code>radio = 5\n\npi = 3.14159\nperimetro = radio * pi * 2\narea = pi * pow(radio, 2)\n\ntexto1 ='Radio:'\ntexto2 ='Per\u00edmetro:'\ntexto3 ='Area:'\n\nprint (texto1, radio)\nprint (texto2, perimetro)\nprint (texto3, area)\n</code></pre>"},{"location":"005-01-Textos.html#captura-de-datos-de-usuario","title":"Captura de datos de usuario","text":"<p>Ya hemos visto que la funci\u00f3n <code>input()</code> espera a que el usuario introduzca  un texto mediante el teclado y pulse Enter:</p> Saludo.py<pre><code>print ('Introduzca su nombre:')\nnombre = input()\nprint ('Hola,' , nombre) \n</code></pre> <p>Lo que, al ejecutarse, muestra algo as\u00ed como:</p> <pre><code>Introduzca su nombre: \nJuan\nHola, Juan\n</code></pre> <p>Lo tecleado por el usuario es devuelto por la funci\u00f3n <code>input()</code> en forma de  texto, que almacenamos en una variable.</p>"},{"location":"005-01-Textos.html#usar-un-prompt","title":"Usar un prompt","text":"<p>Tras la frase \"Introduzca su nombre\" se genera un salto de l\u00ednea que no es lo deseado. Quiz\u00e1s queremos que el cursor se quede tras los dos puntos:</p> <pre><code>Introduzca su nombre: Juan\nHola, Juan\n</code></pre> <p>Si pasamos un texto a la funci\u00f3n <code>input()</code>, esta lo utilizar\u00e1 como prompt. La primera llamada a <code>print()</code> ya no es necesaria:</p> Saludo2.py<pre><code>nombre = input('Introduzca su nombre: ')\nprint ('Hola,' , nombre) \n</code></pre> <p>Pero \u00a1ojo!. La funci\u00f3n <code>print()</code> muestra los argumentos que le pasemos insertando un espacio en blanco entre ellos. La funci\u00f3n <code>input()</code> no a\u00f1ade un espacio tras el prompt, por lo que tenemos que escribirlo a mano, como parte del texto del prompt.  </p>"},{"location":"005-02-Strings.html","title":"Strings","text":"<p>Los textos que maneja un programa son piezas de informaci\u00f3n formadas por una secuencia de caracteres. Se denominan cadenas de caracteres, en ingl\u00e9s,  strings.</p>"},{"location":"005-02-Strings.html#tamano-de-un-string","title":"Tama\u00f1o de un string","text":"<p>La funci\u00f3n len() acepta un texto como argumento y devuelve el n\u00famero de  caracteres, incluyendo espacios y cualquier s\u00edmbolo tecleado por el usuario. La pulsaci\u00f3n de la tecla Enter no cuenta como parte del texto que queda almacenado en la variable:</p> lenTexto.py<pre><code>texto = input('Introduzca un texto: ')\nprint ('Usted ha tecleado' , len(texto), 'caracteres') \n</code></pre> <p>Al ejecutarse, muestra algo as\u00ed como:</p> <pre><code>Introduzca un texto: Hola\nUsted ha tecleado 4 caracteres\n</code></pre>"},{"location":"005-02-Strings.html#examinando-caracteres-individuales","title":"Examinando caracteres individuales","text":"<p>Veamos el siguiente programa</p> Caracteres.py<pre><code>texto = 'Hola'\nprint( texto[0] )\nprint( texto[1] )\nprint( texto[2] )\nprint( texto[3] )\n</code></pre> <p>Al ejecutarse, muestra:</p> <pre><code>H\no\nl\na\n</code></pre> <p>Cada car\u00e1cter de un texto pueden obtenerse a\u00f1adiendo al nombre de la variable un n\u00famero \u00edndice entre corchetes. Los \u00edndices de una cadena de n caracteres van  de cero a n-1.</p> <p>N\u00f3tese que, cuando aplicamos un \u00edndice, lo que sucede es que obtenemos una nueva  cadena formada por un \u00fanico car\u00e1cter:</p> ExtraerCaracter.py<pre><code>primera = 'Hola'\nsegunda = primera[0]\nprint('Cadena completa:', primera)\nprint('Primer car\u00e1cter:', segunda)\nprint('Tama\u00f1o primera cadena:', len(primera))\nprint('Tama\u00f1o segunda cadena:', len(segunda))\n</code></pre> <p>Al ejecutarse, muestra:</p> <pre><code>Cadena completa: Hola\nPrimer car\u00e1cter: H\nTama\u00f1o primera cadena: 4\nTama\u00f1o segunda cadena: 1\n</code></pre> <p>\u00bfPor que los \u00edndices empiezan por cero?</p> <p>Resulta un poco extra\u00f1o que el segundo car\u00e1cter sea <code>texto[1]</code>, y el tercero, <code>texto[2]</code>. Pero esto tiene una explicaci\u00f3n.</p> <p>Cuando el ordenador acude a una variabel de texto, lo que obtiene es el primer car\u00e1cter de la cadena. Y lo que ponemos en el \u00edndice es el n\u00famero de  saltos necesarios para alcanzar el car\u00e1cter deseado.</p> <p>De esta forma, para obtener el segundo car\u00e1cter hay que dar 1 salto, y para acceder al tercer car\u00e1cter, toca dar dos saltos desde el principio de la cadena.  </p> <p>Para un principiante no habituado a estas cosas, resulta poco elegante,  pero en la ejecuci\u00f3n de programas, el ordenador se encuentra muy c\u00f3modo trabajando as\u00ed.</p>"},{"location":"005-02-Strings.html#errores-de-indice","title":"Errores de \u00edndice","text":"<p>Para una cadena de tama\u00f1o <code>n</code>, un \u00edndice con valor <code>n</code> o mayor generar\u00e1 un error:</p> OutOfRange.py<pre><code>texto = 'Hola'\nprint( texto[10] )\n</code></pre> <p>Al ejecutarse, muestra un mensaje de error:</p> <pre><code>IndexError: string index out of range\n</code></pre>"},{"location":"005-02-Strings.html#indices-negativos","title":"Indices negativos","text":"<p>Un \u00edndice negativo permite contar los caracteres empezando por el final de la  cadena:</p> IndicesNegativos.py<pre><code>texto = 'Hola'\nprint( texto[-1] )\nprint( texto[-2] )\nprint( texto[-3] )\nprint( texto[-4] )\n</code></pre> <p>Al ejecutarse, muestra:</p> <pre><code>a\nl\no\nH\n</code></pre> <p>Considerando forma que:</p> <pre><code>Caracter          H   o   l   a\nIndice positivo   0   1   2   3\nIndice negativo  -4  -3  -2  -1\n</code></pre> <p>De esta forma, el segundo car\u00e1cter del final tiene \u00edndice -2, y el tercero, -3. Siempre se cumple la regla siguiente:</p> <pre><code>indice negativo = indice positivo - len(texto)\n</code></pre>"},{"location":"005-03-OpStrings.html","title":"Operaciones con strings","text":""},{"location":"005-03-OpStrings.html#sumas-y-multiplicaciones","title":"Sumas y multiplicaciones","text":"<p>Veamos un ejemplo que hace sumas:</p> SumarStrings<pre><code>print(15+2)\nprint('Hola'+'Adios')\n</code></pre> <p>Al ejecutarse, muestra:</p> <pre><code>17\nHolaAdios\n</code></pre> <p>Los textos se pueden sumar, con lo que se obtiene un nuevo texto. A esta operaci\u00f3n se le llama 'concatenaci\u00f3n'.</p> <p>Tambi\u00e9n podemos multiplicar un texto por un n\u00famero para replicarlo:</p> <pre><code>print('Hola' * 5 )\n</code></pre> <p>lo que muestra:</p> <pre><code>HolaHolaHolaHolaHola\n</code></pre> <p>Pero es un error concatenar un texto con un n\u00famero:</p> <pre><code>print('Hola'+17)\n</code></pre> <p>lo que muestra</p> <pre><code>TypeError: can only concatenate str (not 'int') to str\n</code></pre> <p>Esto significa: solo se puede concatenar un string (no un n\u00famero entero) con otro string.</p>"},{"location":"005-03-OpStrings.html#la-funcion-str","title":"La funci\u00f3n <code>str</code>","text":"<p>Lo anterior puede solucionarse con ayuda de la funci\u00f3n <code>str()</code>. Le pasamos cualquier objeto num\u00e9rico o de otro tipo, y devuelve su representaci\u00f3n en forma de texto:</p> <pre><code>n = 17\nprint(\"Hola\" + str(n) )\n</code></pre> <p>lo que muestra:</p> <pre><code>Hola17\n</code></pre> <p>Es decir, pasamos un valor 17 a la funci\u00f3n <code>str()</code> y esta nos devuelve  una cadena <code>\"17\"</code></p>"},{"location":"005-04-Slicing.html","title":"Slicing","text":"<p>Hemos visto que el uso de \u00edndices con un string nos proporciona nuevas cadenas  de un car\u00e1cter. Pero \u00bfcomo obtener fragmentos con m\u00e1s caracteres a  partir de un string? Realizando una operaci\u00f3n de slicing. </p> <p>En ingl\u00e9s, un slice es una porci\u00f3n o una rebanada de algo. Por ejemplo,  en una pizzeria, podemos comprar pizzas enteras o slices.</p>"},{"location":"005-04-Slicing.html#obtener-un-slice","title":"Obtener un slice","text":"<p>Un slice se obtiene aplicando un doble \u00edndice:</p> FragmentoTexto.py<pre><code>texto = 'Hola, que tal'\nfragmento = texto[6:9]\nprint(fragmento)\n</code></pre> <p>Muestra:</p> <pre><code>que\n</code></pre> <p>Los dos \u00edndices se escriben separados por un s\u00edmbolo <code>:</code>.  El primero indica el primer car\u00e1cter a tomar, y el segundo \u00edndice, el primer car\u00e1cter a ignorar. En este ejemplo:</p> <pre><code>Car\u00e1cter  Indice  Indice negativo\n--------  ------  ---------------\nH              o              -13\no              1              -12\nl              2              -11\na              3              -10\ncoma           4               -9\nespacio        5               -8\nq              6               -7\nu              7               -6\ne              8               -5\nespacio        9               -4\nt             10               -3\na             11               -2\nl             12               -1\n</code></pre> <p>indicamos que hay que coger caracteres desde la posici\u00f3n 6, y empezar a ignorar todo lo que a partir de la posici\u00f3n 9. Ser\u00eda lo mismo que escribir:</p> <pre><code>fragmento = texto[-7:-4]\n</code></pre> <p>Comprob\u00e9moslo:</p> FragmentoTexto2.py<pre><code>texto = \"Hola, que tal\"\nfragmento = texto[6:9]\nfragmento2 = texto[-7:-4]\ncomillas = '\"'\nprint(comillas+fragmento+comillas)\nprint(comillas+fragmento2+comillas)\n</code></pre> <p>Muestra:</p> <pre><code>\"que\"\n\"que\"\n</code></pre>"},{"location":"005-04-Slicing.html#indices-fuera-de-rango","title":"Indices fuera de rango","text":"<p>A diferencia de la indexaci\u00f3n ordinaria, un \u00edndice fuera de rango no genera un  error en una operaci\u00f3n de slicing. Si por ejemplo, escribimos:</p> <pre><code>fragmento = texto[6:99]\n</code></pre> <p>la extracci\u00f3n se lleva a cabo y se detiene al llegar al final de la cadena.</p>"},{"location":"005-04-Slicing.html#indices-por-omision","title":"Indices por omisi\u00f3n","text":"<p>En una operaci\u00f3n de slicing, podemos omitir el primer \u00edndice, el segundo,  o los dos a la vez. Pero no podemos omitir los dos puntos, porque indican que se trata de una operaci\u00f3n de slicing:</p> <ul> <li>si se omite el primer \u00edndice, se asume cero.</li> <li>si se omite el segundo \u00edndice, se asume que la extracci\u00f3n se lleva hasta el     final de la cadena</li> <li>si se omiten ambos \u00edndices, se extrae la cadena completa</li> </ul> <p>Por ejemplo:</p> FragmentoTexto2.py<pre><code>texto = \"Hola, que tal\"\nfragmento1 = texto[:6]\nfragmento2 = texto[6:]\nfragmento_total = texto[:]\ncomillas = '\"'\nprint(comillas+fragmento1+comillas)\nprint(comillas+fragmento2+comillas)\nprint(comillas+fragmento_total+comillas)\n</code></pre> <p>Muestra:</p> <pre><code>\"Hola, \"\n\"que tal\"\n\"Hola, que tal\"\n</code></pre>"},{"location":"005-04-Slicing.html#las-cadenas-son-inmutables","title":"Las cadenas son inmutables","text":"<p>Una cadena de texto es un objeto que no se puede modificar. Supongamos que  tenemos un texto en el que queremos cambiar el segundo car\u00e1cter (\u00edndice 1). No podemos escribir:</p> ModificarCadena.py<pre><code>texto = \"Hola\"\ntexto[1] = \"a\"\nprint(texto)\n</code></pre> <p>En la segunda sentencia obtendremos un error:</p> <pre><code>TypeError: 'str' object does not support item assignment\n</code></pre> <p>\u00bfLa soluci\u00f3n? Obtener una nueva cadena completa, y asign\u00e1rsela a la variable, perdiendo el texto original:</p> ModificarCadena.py<pre><code>texto = \"Hola\"\n\nindice = 1\nnuevo_caracter= \"a\"\n\nnuevo_texto = texto[:indice]   # tomar los caracteres a la izquierda\nnuevo_texto += nuevo_caracter  # sumar el nuevo car\u00e1cter\nindice += 1                    # desplazar el \u00edndice una posici\u00f3n\nnuevo_texto += texto[indice:]  # a\u00f1adir los caracteres de la derecha\ntexto = nuevo_texto\n\nprint(texto)\n</code></pre> <p>Lo que, al ejecutarse, muestra:</p> <pre><code>Hala\n</code></pre>"},{"location":"005-05-FStrings.html","title":"f-Strings","text":"<p>Un f-string es una cadena de texto en la que podemos incrustar datos.  Por ejemplo:</p> fstrings.py<pre><code>n = 5\ndoble = n * 2\ntexto = f\"El doble de {n} es {doble}.\"\nprint (texto)\n</code></pre> <p>Lo que muestra:</p> <pre><code>El doble de 5 es 10.\n</code></pre> <p>Al ejecutar la tercera sentencia, se toman los valores de las variables <code>n</code> y  <code>doble</code>, se convierten en texto, y el resultado se insertan en los lugares  delimitados por las llaves. Esos marcadores son sustituidos por el texto insertado.</p> <p>N\u00f3tese que los f-strings se escriben con una letra  <code>f</code> como prefijo (min\u00fascula o may\u00fascula). Si se nos olvida, el mecanismo de sustituci\u00f3n no se llevar\u00e1 a cabo, y obtendremos:</p> <pre><code>El doble de {n} es {doble}.\n</code></pre>"},{"location":"005-05-FStrings.html#que-quiere-decir-f-string","title":"\u00bfQue quiere decir f-string?","text":"<p>La presentaci\u00f3n de un dato en pantalla se hace convirti\u00e9ndolo a texto, aplicando un formato de presentaci\u00f3n. En t\u00e9rminos coloquiales, a esta operaci\u00f3n de  conversi\u00f3n se le suele llamar formateo del dato.</p> <p>Los f-strings son cadenas de texto que permiten aplicar de forma c\u00f3moda un formato de presentaci\u00f3n, de ah\u00ed el nombre.</p>"},{"location":"005-05-FStrings.html#expresiones","title":"Expresiones","text":"<p>Entre las llaves de un marcador podemos poner variables o expresiones m\u00e1s complejas:</p> fstrings.py<pre><code>n = 5\ntexto = f\"El doble de {n} es {n*2}.\"\nprint (texto)\n</code></pre>"},{"location":"005-05-FStrings.html#especificaciones-de-formato","title":"Especificaciones de formato","text":"<p>Una expresi\u00f3n o variable a insertar, puede ir acompa\u00f1ada de instrucciones de  formato:</p> <pre><code>f\"texto { expresion : formato } m\u00e1s texto\"\n</code></pre> <p>Por ejemplo:</p> fstrings2.py<pre><code>n = 50\ntexto = f\"La mitad de {n} es {n/2:.0f}\"\nprint (texto)\n</code></pre> <p>El resultado de una divisi\u00f3n siempre tiene decimales. Tras la expresi\u00f3n <code>n/2</code> escribimos dos puntos seguidos del formato a aplicar, que es <code>.0f</code> lo que indica que lo mostremos con cero decimales.</p> <p>Esto muestra:</p> <pre><code>La mitad de 50 es 25\n</code></pre> <p>Para mostrarlo con dos decimales, por ejemplo, escribir\u00edamos <code>.2f</code>:</p> fstrings2.py<pre><code>n = 50\ntexto = f\"La mitad de {n} es {n/2:.2f}\"\nprint (texto)\n</code></pre>"},{"location":"005-06-Escapes.html","title":"Secuencias de escape","text":"<p>Supongamos que queremos mostrar en la pantalla:</p> <pre><code>Hola\nAdios\n</code></pre> <p>Imaginemos que queremos una cadena con los diez caracteres del texto  a visualizar:</p> <pre><code>H\no \nl \na\nsalto\nA\nd\ni\no\ns\n</code></pre> <p>Tanto los caracteres de espacio como los saltos de l\u00ednea son un car\u00e1cter m\u00e1s, que se incluyen como parte del texto a mostrar.</p> <p>\u00bfComo podemos incluir un car\u00e1cter de salto en una cadena? No podemos escribir:</p> <pre><code>texto = \"Hola\nAdios\"\n</code></pre> <p>... porque no podemos partir una cadena de texto en dos.</p> <p>Python proporciona un truco especial:</p> <pre><code>texto = \"Hola\\nAdios\"\n</code></pre> <p>La secuencia \"\\n\" representa un salto de l\u00ednea (newline), y al evaluar  la cadena, el int\u00e9rprete sustituir\u00e1 esos dos caracteres por uno de salto:</p> Salto.py<pre><code>texto = \"Hola y...\\nadios\"\nprint(texto)\n</code></pre> <p>al ejecutarse, muestra:</p> <pre><code>Hola y...\nadios\n</code></pre> <p>A este tipo de secuencias especiales de caracteres en un literal de texto se les secuencias de escape.</p>"},{"location":"005-06-Escapes.html#otras-secuencias","title":"Otras secuencias","text":"<p>Las secuencias de escape se utilizan para incluir en una cadena caracteres de dificil representaci\u00f3n. Un ejemplo son las comillas y ap\u00f3strofos. Si queremos insertar estos caracteres como parte del texto regular, podemos escaparlos con una barra invertida:</p> Secuencias1.py<pre><code>texto = \"Nos llaman \\\"los mejores del mundo\\\".\"\nprint(texto)\n</code></pre> <p>Muestra:</p> <pre><code>Nos llaman \"los mejores del mundo\".\n</code></pre> <p>Cuando el int\u00e9rprete encuentra un car\u00e1cter de barra invertida <code>\\</code> asume que  se trata del comienzo de una secuencia de escape. Pero... \u00bfcomo insertar una barra como texto regular? Con una secuencia <code>\\\\</code></p> Secuencias2.py<pre><code>carpera = \"C:\\\\mis documentos\"\nprint(carpera)\n</code></pre> <p>Muestra:</p> <pre><code>C:\\mis documentos\n</code></pre> <p>La secuencia <code>\\t</code> represenra un car\u00e1cter de tabulaci\u00f3n, lo que equivale  a pulsar Tab. Es una forma muy b\u00e1sica de alinear datos en vertical:</p> Secuencias3.py<pre><code>print(\"Puntuaciones:\")\nprint()\nprint(\"Andr\u00e9s:\\t\", 7)\nprint(\"Ana:\\t\", 8)\nprint(\"Teresa:\\t\", 5.5)\n</code></pre> <p>Muestra:</p> <pre><code>Puntuaciones:\n\nAndr\u00e9s:  7\nAna:     8\nTeresa:  5.5\n</code></pre>"},{"location":"005-06-Escapes.html#cadenas-raw","title":"Cadenas raw","text":"<p>A veces sucede que las secuencias de escape tienen un efecto inesperado:</p> Secuencias3.py<pre><code>archivo = \"C:\\nuevos documentos\\doc1.txt\"\nprint(archivo)\n</code></pre> <p>lo que muestra:</p> <pre><code>C:\nuevos documentos\\doc1.txt\n</code></pre> <p>En el texto hay dos barras invertidas <code>\\</code>. La segunda secuencia es <code>\\d</code>, que no tiene un significado especial como secuencia de escape, por lo que se respeta como texto. Pero la primera secuencia <code>\\n</code> es sustituida por un salto de l\u00ednea.</p> <p>\u00bfComo hacer que se ignoren las secuencias de escape y se tome el texto de una  cadena tal cual? Poniendo un prefijo <code>r</code>, lo que significa que se trata de una cadena raw, donde se toma el texto \"en crudo\":</p> Secuencias3.py<pre><code>archivo = r\"C:\\nuevos documentos\\doc1.txt\"\nprint(archivo)\n</code></pre>"},{"location":"005-06-Escapes.html#literales-multilinea","title":"Literales multil\u00ednea","text":"<p>Existe la posibilidad de escribir un literal de texto ocupando varias l\u00edneas:</p> Chistes.py<pre><code>chistes = \"\"\"\u00bfQu\u00e9 le dice una impresora a otra?\n\u00a1Esa hoja es tuya o es una impresi\u00f3n m\u00eda?\n\n\u00bfQu\u00e9 hace una abeja en el gimnasio?\n\u00a1Zumba!\n\n\u00bfCu\u00e1l es el \u00faltimo animal que subi\u00f3 al arca de No\u00e9?\n\u00a1El del f\u00edn!\n\n\u00bfQu\u00e9 le dice un cero a otro cero?\n\u00a1No somos nada!\n\"\"\"\n\nprint(chistes)\n</code></pre> <p>Lo que, al ejecutarse, muestra:</p> <pre><code>\u00bfQu\u00e9 le dice una impresora a otra?\n\u00bfEsa hoja es tuya o es una impresi\u00f3n m\u00eda?\n\n\u00bfQu\u00e9 hace una abeja en el gimnasio?\n\u00a1Zumba!\n\n\u00bfCu\u00e1l es el \u00faltimo animal que subi\u00f3 al arca de No\u00e9?\n\u00a1El del f\u00edn!\n\n\u00bfQu\u00e9 le dice un cero a otro cero?\n\u00a1No somos nada!\n</code></pre> <p>El texto se delimita entre triples comillas, y los saltos de l\u00ednea se consideran como un car\u00e1cter que forma parte del texto.</p> <p>Alternativamente, podemos delimitar el texto entre triples ap\u00f3strofos:</p> <pre><code>chistes = '''\n   ... texto multil\u00ednea ...\n'''\n</code></pre> <p>Es frecuente utilizar la barra invertida como car\u00e1cter de continuaci\u00f3n:</p> <pre><code>chistes = \"\"\"\\\n\u00bfQu\u00e9 le dice una impresora a otra?\n...\n</code></pre> <p>lo que sirve para ignorar el salto de l\u00ednea inicial.</p>"},{"location":"005-06-Escapes.html#textos-como-comentarios","title":"Textos como comentarios","text":"<p>Cualquier texto aislado, sin ser asignado a una variable, sin ser pasado como argumento de una funci\u00f3n, ni formar parte de una expresi\u00f3n, ser\u00e1 ignorado y considerado como comentarios:</p> <pre><code>\"Hola, que tal\"\nprint(5+2)\n</code></pre> <p>Como ya vimos en el apartado dedicado a comentarios, esto resulta muy \u00fatil en el caso de comentarios multil\u00ednea, por ejemplo:</p> Comentarios3.py<pre><code>'''\nPrograma para demostrar el uso\nde operaciones de c\u00e1lculo\n'''\n\nprint( 15 + 3 )   # suma\nprint( 15 - 3 )   # resta\nprint( 15 * 3 )   # multiplicaci\u00f3n\nprint( 15 / 3 )   # divisi\u00f3n\n</code></pre>"},{"location":"006-01-Shell.html","title":"El shell de Python","text":"<p>Tras escribir algunos programas b\u00e1sicos, ya va siendo hora de echar un vistazo a la ventana shell.</p>"},{"location":"006-01-Shell.html#comandos","title":"Comandos","text":"<p>Los comandos del shell son en realidad sentencias Python:</p> <pre><code>&gt;&gt;&gt; texto=\"Hola\"\n&gt;&gt;&gt; print(texto)\n    Hola\n</code></pre> <p>A diferencia de lo que sucede en los programas, los comandos se teclean y ejecutan de forma interactiva, a medida que pulsamos Enter.</p>"},{"location":"006-01-Shell.html#historial-de-comandos","title":"Historial de comandos","text":"<p>El int\u00e9rprete de Python mantiene un historial de los \u00faltimos comandos  ejecutados en la ventana shell de IDLE. Podemos recuperar comandos anteriores de dos maneras:</p> <ul> <li> <p>si el comando est\u00e1 visible en la ventana, llevar el cursor a esa l\u00ednea y     pulsar Enter. Esto copia el texto del comando en la l\u00ednea donde est\u00e1      el prompt, y podemos usar las teclas Left y Right para mover      el cursor a izquierda y derecha, editar el comando, y ejecutarlo de nuevo      pulsando Enter.</p> </li> <li> <p>pulsando Ctrl+P (previous) se van recuperando comandos del historial.     Mientras navegamos hacia atr\u00e1s, podemos movernos en sentido     contrario pulsando Ctrl+N (next).</p> </li> </ul> <p>\u00a1Cuidado!</p> <p>En algunos sistemas operativos se usa la tecla Alt en lugar de Ctrl para desplazarse por el historial de comandos. Es posible que Ctrl+P  sea una combinaci\u00f3n de teclas asociada a la acci\u00f3n de imprimir el documento.</p> <p>Recorriendo el historial con las teclas de flecha</p> <p>En sesiones shell de otros editores distintos de IDLE, podemos usar las teclas Up y Down para movernos por el historial de comandos.  Eso no funciona en IDLE, donde tenemos que usar Ctrl+P y Ctrl+N. Las flechas mueven el cursor por la ventana del shell.</p>"},{"location":"006-01-Shell.html#el-eco","title":"El eco","text":"<p>Si escribimos una expresi\u00f3n a continuaci\u00f3n del prompt, se evaluar\u00e1 y mostrar\u00e1 el resultado:</p> <pre><code>&gt;&gt;&gt; valor = 99\n\n&gt;&gt;&gt; valor * 2\n    198\n</code></pre> <p>La operaci\u00f3n de asignaci\u00f3n no produce \"eco\", pero si escribimos una expresi\u00f3n aislada, se eval\u00faa y visualiza.</p> <p>Tambi\u00e9n funciona si tecleamos el nombre de una variable:</p> <pre><code>&gt;&gt;&gt; valor\n    99\n</code></pre> <p>Podemos usar el \"eco\" para probar una funci\u00f3n:</p> <pre><code>&gt;&gt;&gt; valor1 = 99\n&gt;&gt;&gt; valor2 = 50\n&gt;&gt;&gt; min(valor1, valor2)\n    50\n</code></pre>"},{"location":"006-01-Shell.html#la-variable-_","title":"La variable <code>_</code>","text":"<p>Cuando evaluamos una expresi\u00f3n haciendo uso del eco en el shell, el resultado se guarda en una variable interna cuyo nombre se limita a un car\u00e1cter <code>_</code></p> <pre><code>&gt;&gt;&gt; valor1 = 99\n&gt;&gt;&gt; valor2 = 50\n&gt;&gt;&gt; min(valor1, valor2)\n    50\n\n&gt;&gt;&gt; _ * 2\n    100\n</code></pre> <p>Esto tiene una cierta utilidad si queremos dividir un c\u00e1lculo en varios pasos. Por ejemplo, para calcular el per\u00edmetro de una circunferencia de radio 5:</p> <pre><code>&gt;&gt;&gt; 5 * 3.14159\n15.70795\n\n&gt;&gt;&gt; _ * 2\n31.4159\n</code></pre> <p>Pero si la cosa se complica, seguramente es mejor escribir un programa.</p>"},{"location":"006-01-Shell.html#el-prompt-secundario","title":"El prompt secundario","text":"<p>Si introducimos una sentencia que Python considere incompleta, mostrar\u00e1 sucesivos prompts <code>...</code> para darnos la posibilidad de completarla:</p> <pre><code>&gt;&gt;&gt; max(\n...     15,\n...     3,\n...     27\n...     )\n\n27\n</code></pre> <p>Al introducir el par\u00e9ntesis de cierre, la sentencia se considera completa y se ejecutar\u00e1. A este prompt <code>...</code> se le llama \"secundario\", y sirve para  completar sentencias.</p> <p>En versiones modernas de IDLE, al pulsar Ctrl+P para recuperar comandos anteriores, si se trata de un comando multil\u00ednea, se recupera completo, mostrando los prompts secundarios. La edici\u00f3n del comando recuperado permite borrar o insertar l\u00edneas antes de pulsar Enter para ejecutarlo.</p> <p>El otros shell distintos del de IDLE, hay que recuperar y ejecutar l\u00ednea a l\u00ednea.</p>"},{"location":"006-01-Shell.html#la-ayuda-de-python","title":"La ayuda de Python","text":"<p>Otra posible utilidad del shell es el comando:</p> <pre><code>&gt;&gt;&gt; help()\n</code></pre> <p>que da inicio a una sesi\u00f3n de ayuda:</p> <pre><code>Welcome to Python 3's help utility! If this is your first time using\nPython, you should definitely check out the tutorial at\nhttps://docs.python.org/3.13/tutorial/.\n\nEnter the name of any module, keyword, or topic to get help on writing\nPython programs and using Python modules.  To get a list of available\nmodules, keywords, symbols, or topics, enter \"modules\", \"keywords\",\n\"symbols\", or \"topics\".\n\nEach module also comes with a one-line summary of what it does; to list\nthe modules whose name or summary contain a given string such as \"spam\",\nenter \"modules spam\".\n\nTo quit this help utility and return to the interpreter,\nenter \"q\" or \"quit\".\n\nhelp&gt;\n</code></pre> <p>N\u00f3tese que ha cambiado el prompt:</p> <pre><code>help&gt;\n</code></pre> <p>Probemos a introducir topics como t\u00e9rmino de b\u00fasqueda:</p> <pre><code>help&gt; topics\n\nHere is a list of available topics.  Enter any topic name to get more help.\n\nASSERTION           DEBUGGING           LITERALS            SEQUENCES\nASSIGNMENT          DELETION            LOOPING             SHIFTING\nASSIGNMENTEXPRESSIONS DICTIONARIES        MAPPINGMETHODS      SLICINGS\nATTRIBUTEMETHODS    DICTIONARYLITERALS  MAPPINGS            SPECIALATTRIBUTES\nATTRIBUTES          DYNAMICFEATURES     METHODS             SPECIALIDENTIFIERS\nAUGMENTEDASSIGNMENT ELLIPSIS            MODULES             SPECIALMETHODS\nBASICMETHODS        EXCEPTIONS          NAMESPACES          STRINGMETHODS\nBINARY              EXECUTION           NONE                STRINGS\nBITWISE             EXPRESSIONS         NUMBERMETHODS       SUBSCRIPTS\nBOOLEAN             FLOAT               NUMBERS             TRACEBACKS\nCALLABLEMETHODS     FORMATTING          OBJECTS             TRUTHVALUE\nCALLS               FRAMEOBJECTS        OPERATORS           TUPLELITERALS\nCLASSES             FRAMES              PACKAGES            TUPLES\nCODEOBJECTS         FUNCTIONS           POWER               TYPEOBJECTS\nCOMPARISON          IDENTIFIERS         PRECEDENCE          TYPES\nCOMPLEX             IMPORTING           PRIVATENAMES        UNARY\nCONDITIONAL         INTEGER             RETURNING           UNICODE\nCONTEXTMANAGERS     LISTLITERALS        SCOPING             \nCONVERSIONS         LISTS               SEQUENCEMETHODS\n</code></pre> <p>Introduzcamos uno de esos temas de ayuda:</p> <pre><code>help&gt; POWER\nThe power operator\n******************\n\nThe power operator binds more tightly than unary operators on its\nleft; it binds less tightly than unary operators on its right.  The\nsyntax is:\n\n   power ::= (await_expr | primary) [\"**\" u_expr]\n\nThus, in an unparenthesized sequence of power and unary operators, the\noperators are evaluated from right to left (this does not constrain\nthe evaluation order for the operands): \"-1**2\" results in \"-1\".\n\nThe power operator has the same semantics as the built-in \"pow()\"\nfunction, when called with two arguments: it yields its left argument\nraised to the power of its right argument.  The numeric arguments are\nfirst converted to a common type, and the result is of that type.\n\nFor int operands, the result has the same type as the operands unless\nthe second argument is negative; in that case, all arguments are\nconverted to float and a float result is delivered. For example,\n\"10**2\" returns \"100\", but \"10**-2\" returns \"0.01\".\n\nRaising \"0.0\" to a negative power results in a \"ZeroDivisionError\".\nRaising a negative number to a fractional power results in a \"complex\"\nnumber. (In earlier versions it raised a \"ValueError\".)\n\nThis operation can be customized using the special \"__pow__()\" and\n\"__rpow__()\" methods.\n\nRelated help topics: EXPRESSIONS\n\nhelp&gt;\n</code></pre> <p>En general, los textos de ayuda suelen ser bastante t\u00e9cnicos. Si el texto es muy extenso, IDLE se limitar\u00e1 a mostrar un enlace:</p> <pre><code>help&gt; STRINGS\nSqueezed text (184 lines)\n</code></pre> <p>y pulsando en ese enlace con el bot\u00f3n secundario del rat\u00f3n, se mostrar\u00e1 el texto en una ventana aparte.</p> <p>Se sale de la sesi\u00f3n de ayuda con el comando <code>quit</code></p> <pre><code>help&gt; quit\n</code></pre> <p>Podemos obtener ayuda sobre un tema concreto. desde el prompt interactivo <code>&gt;&gt;&gt;</code>.  Para ello, invocar la funci\u00f3n <code>help()</code> pasando como argumento el texto a consultar.  Por ejemplo, para obtener la lista de m\u00f3dulos instalados:</p> <pre><code>&gt;&gt;&gt; help(\"modules\")\n</code></pre>"},{"location":"006-01-Shell.html#la-documentacion-de-python","title":"La documentaci\u00f3n de Python","text":"<p>El sistema de ayuda del shell es un primer recurso, pero \u00bfcomo podemos consultar la documentaci\u00f3n oficial de Python? El portal de ayuda on-line est\u00e1 en la p\u00e1gina web https://docs.python.org/es/</p>"},{"location":"006-02-ComandosSO.html","title":"Comandos del sistema operativo","text":"<p>Al margen de los comandos Python, cada sistema operativo, Windows, Mac, Linux, etc\u00e9tera, tiene su propio lenguaje de comandos para realizar tareas. Pero no debemos confundirlo con los comandos de Python.</p> <p>\u00bfPor que son importantes los comandos del S.O.? En principio, para ejecutar cualquier programa, IDLE o los programas que nosotros escribamos, basta con hacer doble clic sobre ellos. Pero hay situaciones en las que tendremos que recurrir a la ejecuci\u00f3n de comandos desde un Terminal del sistema.</p> <p>Echemos un vistazo a lo m\u00e1s b\u00e1sico.</p>"},{"location":"006-02-ComandosSO.html#forma-de-ejecutar-comandos-del-so","title":"Forma de ejecutar comandos del S.O.","text":"<p>B\u00e1sicamente, se pueden ejecutar comandos abriendo una ventana shell del sistema  operativo. En Windows, es un programa llamado S\u00edmbolo del sistema. V\u00e9ase  Wikipedia. Para abrirlo, escribir \"cmd\" en el cuadro de b\u00fasqueda del escritorio.</p> <p>En Mac, la consola de comandos es un programa llamado Terminal, que encontraremos en de la carpeta \"Aplicaciones &gt;&gt; Utilidades\". En Linux,  tambi\u00e9n suele denominarse Terminal.</p> <p>Al abrir la ventana de consola de comandos, se mostrar\u00e1 un prompt que depende  del sistema operativo, y que suele ser un s\u00edmbolo <code>&gt;</code>, <code>$</code>, <code>%</code> o <code>#</code>.  Habitualmente va precedido por el nombre de la carpeta de trabajo actual:</p> <pre><code>/micarpeta/ &gt;\n</code></pre> <p>\u00bfComo es la sintaxis de los comandos? Como hemos dicho, cada sistema tiene su lenguaje de comandos. Podemos encontrar numerosos tutoriales en Internet.</p>"},{"location":"006-02-ComandosSO.html#scripts-de-comandos","title":"Scripts de comandos","text":"<p>Otra posibilidad es crear un archivo de texto con una secuencia de comandos a ejecutar, como har\u00edamos con los programa Python. En Windows, llevan el sufijo <code>.bat</code> y para ejecutarlos, basta con hacer doble clic sobre ellos.</p> <p>A este tipo de archivos se les llama scripts. En un Mac, podemos ejecutarlos pulsando sobre ellos con el bot\u00f3n secundario del rat\u00f3n, y seleccionando  Abrir con ... Terminal de comandos. </p> <p>En Mac/Linux, para ejecutar un script tenemos que asignar permisos  de ejecuci\u00f3n al archivo. Para ello, abrir el Terminal y ejecutar el comando:</p> <pre><code>chmod +x /ruta_de_carpetas/nombre_de_archivo\n</code></pre> <p>... siendo la ruta de carpetas y el nombre del archivo el que corresponda.</p> <p>Editores</p> <p>Para crear scripts y archivos de texto en general, Windows proporciona un  editor b\u00e1sico llamado Notepad (bloc de notas).  Nos puede servir para este prop\u00f3sito.</p> <p>Todos los sistemas operativos suelen incluir de serie alg\u00fan editor sencillo. De todas formas, en Internet existe una ampl\u00edsima gama de editores que podemos descargar e instalar en nuestro esquipo.</p> <p>N\u00f3tese que ha de tratarse de alg\u00fan editor de ficheros tipo \"plain text\", es decir, texto sin m\u00e1s a\u00f1adidos. Los procesadores de texto del tipo Microsoft Word no nos sirven, ya que insertan en el documento todo tipo de informaci\u00f3n sobre tipos de letra, m\u00e1rgenes, paginaci\u00f3n, im\u00e1genes  incluidas en el texto, etc\u00e9tera. Este tipo de programas son aptos para maquetaci\u00f3n de publicaciones, no para labores de programaci\u00f3n.</p>"},{"location":"006-02-ComandosSO.html#comando-para-averiguar-la-version-instalada-de-python","title":"Comando para averiguar la versi\u00f3n instalada de Python","text":"<p>En el Terminal del sistema operativo, introducir el comando:</p> <pre><code>python -version\n</code></pre> <p>o bien, dependiendo de como hayamos instalado Python:</p> <pre><code>python3 -version\n</code></pre> <p>Al ejecutar el comando, se mostrar\u00e1 el n\u00famero de versi\u00f3n. Un mensaje de error indica que no tenemos las herramientas Python en nuestro equipo (o que hay que escribir <code>Python3</code> en lugar de <code>Python</code>).</p>"},{"location":"006-02-ComandosSO.html#como-ejecutar-un-programa-python","title":"Como ejecutar un programa Python","text":"<p>Para ejecutar un programa desde un Terminal de comandos, lo primero es averiguar el nombre de la carpeta donde se encuentra ubicado. Seguidamente introducimos el  comando:</p> <pre><code>python3 /carpeta1/carpeta2/miprograma.py\n</code></pre> <p>siendo <code>/carpeta1/carpeta2</code> la ruta de carpetas. En Windows, llevar\u00e1 la unidad como prefijo y las barras invertidas:</p> <pre><code>python3 c:\\carpeta1\\carpeta2\\miprograma.py\n</code></pre>"},{"location":"006-02-ComandosSO.html#ejecutar-comandos-del-so-en-el-shell-de-idle","title":"Ejecutar comandos del S.O. en el shell de IDLE","text":"<p>El shell de IDLE solo permite comandos Python. No confundirlos con los del sistema operativo.</p> <p>De todas formas, hay un peque\u00f1o truco que ya hemos visto. Si ponemos el texto de un comando del sistema en una variable:</p> <pre><code>texto = \"python3 -version\"\n</code></pre> <p>podemos ejecutarlo desde Python pas\u00e1ndoselo a la funci\u00f3n <code>system()</code> del m\u00f3dulo <code>os</code>:</p> <pre><code>texto = \"python3 -version\"\nimport os\nos.system(texto)\n</code></pre>"},{"location":"007-01-Tipos.html","title":"Tipos de datos","text":"<p>Hasta ahora hemos visto tres tipos de datos:</p> <ul> <li>N\u00fameros sin decimales</li> <li>N\u00fameros con decimales</li> <li>Cadenas de texto</li> </ul> <p>Cualquiera de ellos se puede asignar a una variable:</p> <pre><code>dato1 = 5\ndato2 = 10.5\ndato3 = \"50\"\n</code></pre>"},{"location":"007-01-Tipos.html#distinguir-entre-tipos-de-numeros","title":"Distinguir entre tipos de n\u00fameros","text":"<p>\u00bfPor que es importante la distinci\u00f3n entre n\u00fameros enteros y n\u00fameros con  decimales? B\u00e1sicamente, por dos motivos</p> <p>El primer motivo es que, cuando se asignamos cualquier dato a una variable,  el ordenador intenta almacenarlos como un paquete de ceros y unos.  La forma de representar en formato binario un n\u00famero con decimales, con una parte entera y una fraccionaria, difiere a como representar\u00edamos un n\u00famero  entero. Las dos siguientes sentencias son aparentemente iguales:</p> <pre><code>dato1 = 5\ndato2 = 5.0\n</code></pre> <p>... pero su almacenamiento en formato de ceros y unos es diferente.   </p> <p>El segundo motivo es que el comportamiento del dato depende de su tipo. De hecho, en el sistema de numeraci\u00f3n binario no existen las fracciones, por lo que la representaci\u00f3n interna que hacen los ordenadores, no es del todo exacta. Por  ejemplo, si escribimos en la ventana shell:</p> <pre><code>&gt;&gt;&gt; (1+1+1)/3\n    1.0\n</code></pre> <p>Pero si lo hacemos con decimales:</p> <pre><code>&gt;&gt;&gt; (0.1+0.1+0.1)/3\n    0.10000000000000002\n</code></pre> <p>Estas peque\u00f1as inexactitudes son propias de los c\u00e1lculos con decimales en una computadora, y se deben a las conversiones internas del sistema decimal al binario y a la inversa.</p> <p>Todo lo explicado puede resultar sorprendente, pero en realidad, el sistema  decimal al que estamos acostumbrados tambi\u00e9n tiene sus imprecisiones. Consideremos la siguiente  expresi\u00f3n:</p> <pre><code>10/3\n</code></pre> <p>\u00bfCual es el resultado? \u00bf3,33 o 3,3333333333 ... ?</p>"},{"location":"007-01-Tipos.html#averiguar-el-tipo-de-dato","title":"Averiguar el tipo de dato","text":"<p>Si pasamos cualquier objeto a la funci\u00f3n <code>type()</code> obtendremos un nuevo objeto con informaci\u00f3n del dato:</p> Tipos.py<pre><code>dato1 = 5\ndato2 = 10.5\ndato3 = \"50\"\n\ninfo1 = type(dato1)\ninfo2 = type(dato2)\ninfo3 = type(dato3)\n\ninfo4 = type(info1)\n\nprint(f\"{dato1} es un {info1}\")\nprint(f\"{dato2} es un {info2}\")\nprint(f\"{dato3} es un {info3}\")\nprint(f\"{info1} es un {info4}\")\n</code></pre> <p>lo que muestra:</p> <pre><code>5 es un &lt;class 'int'&gt;\n10.5 es un &lt;class 'float'&gt;\n50 es un &lt;class 'str'&gt;\n&lt;class 'int'&gt; es un &lt;class 'type'&gt;\n</code></pre> <p>Es decir:</p> <ul> <li> <p>Los n\u00fameros enteros, sin decimales son objetos del tipo <code>int</code>,      abreviatura de integer</p> </li> <li> <p>Los n\u00fameros con decimales son objetos del tipo <code>float</code></p> </li> <li> <p>Los textos son objetos del tipo <code>str</code>, abreviatura de <code>string</code></p> </li> <li> <p>Los paquetes de informaci\u00f3n devueltos por la funci\u00f3n <code>type()</code> son objetos     del tipo <code>type</code></p> </li> <li> <p>Los paquetes de informaci\u00f3n devueltos por la funci\u00f3n <code>type()</code>, al ser      convertidos a texto, generan un texto:</p> <pre><code>&lt;class 'tipo'&gt;\n</code></pre> </li> <li> <p>A los tipos tambi\u00e9n se les llama clases.</p> </li> </ul>"},{"location":"007-01-Tipos.html#numeros-flotantes","title":"N\u00fameros flotantes","text":"<p>\u00bfQue quiere decir <code>float</code>? En el mundo de los ordenadores, a los n\u00fameros con decimales se les llama flotantes, porque si movemos el punto decimal de  izquierda a derecha, o a la inversa, es como multiplicar o dividir por 10:</p> <pre><code>1.2345\n12.345\n123.45\n1234.5\n</code></pre>"},{"location":"007-01-Tipos.html#programacion-orientada-a-objetos","title":"Programaci\u00f3n orientada a objetos","text":"<p>Python es un lenguaje pensado para trabajar con objetos. En Python, todo es un objeto, tanto los datos num\u00e9ricos, como las cadenas de texto, o las funciones:</p> <pre><code>&gt;&gt;&gt; type(print)\n    &lt;class 'builtin_function'&gt;\n</code></pre> <p>Todo objeto pertenece a una clase, y eso determina:</p> <ul> <li>su comportamiento como objeto</li> <li>su representaci\u00f3n interna en forma de ceros y unos</li> </ul>"},{"location":"007-02-Conversiones.html","title":"Conversiones","text":"<p>Hay veces que tenemos un tipo de dato y lo necesitamos de otro tipo.  Tendremos que hacer una conversi\u00f3n, generando un nuevo dato a partir del original.</p>"},{"location":"007-02-Conversiones.html#conversiones-automaticas","title":"Conversiones autom\u00e1ticas","text":"<p>Si, en una operaci\u00f3n aritm\u00e9tica, los dos operandos son del mismo tipo, el resultado ser\u00e1 de dicho tipo:</p> <pre><code>&gt;&gt;&gt; type(1.0)\n    &lt;class 'float'&gt;\n\n&gt;&gt;&gt; type(1.0 + 1.0)\n    &lt;class 'float'&gt;\n\n&gt;&gt;&gt; type(1+1)\n    &lt;class 'int'&gt;\n</code></pre> <p>Si un operando es <code>int</code> y el otro <code>float</code>, el primero se convierte internamente a <code>float</code> antes de realizar la operaci\u00f3n, y el resultado es <code>float</code>:</p> <pre><code>&gt;&gt;&gt; 1+1.0\n    2.0\n</code></pre> <p>El resultado de una divisi\u00f3n siempre es <code>float</code> aunque ambos operandos sean <code>int</code></p> <pre><code>&gt;&gt;&gt; 10/2\n    5.0\n</code></pre>"},{"location":"007-02-Conversiones.html#conversiones-manuales","title":"Conversiones manuales","text":"<p>Un dato tipo <code>str</code> no se puede concatenar con uno num\u00e9rico:</p> <pre><code>&gt;&gt;&gt; \"Hola\"+\"17\"\n    'Hola17'\n\n&gt;&gt;&gt; \"Hola\"+17\n    Traceback (most recent call last):\n      File \"/usr/lib/python3.13/idlelib/run.py\", line 590, in runcode\n        exec(code, self.locals)\n        ~~~~^^^^^^^^^^^^^^^^^^^\n      File \"&lt;pyshell#11&gt;\", line 1, in &lt;module&gt;\n    TypeError: can only concatenate str (not \"int\") to str\n</code></pre> <p>Tendremos que convertir el valor num\u00e9rico en texto. La funci\u00f3n <code>str()</code> admite  valores de cualquier tipo, y devuelve un string:</p> <pre><code>&gt;&gt;&gt; \"Hola\"+str(17)\n    'Hola17'\n</code></pre> <p>De igual forma, la funci\u00f3n <code>int()</code> devuelve un n\u00famero entero a partir de un texto o cualquier otro valor num\u00e9rico. Por su parte, <code>float()</code> devuelve un valor con decimales a partir de un entero o de un texto:</p> <pre><code>&gt;&gt;&gt; int(17.5)\n    17\n\n&gt;&gt;&gt; int(\"17\")\n    17\n\n&gt;&gt;&gt; float(\"17.5\")\n    17.5\n</code></pre>"},{"location":"007-02-Conversiones.html#un-ejemplo","title":"Un ejemplo","text":"<p>Vamos a crear una calculadora:</p> Sumadora.py<pre><code>numero1 = input(\"N\u00famero 1: \")\nnumero2 = input(\"N\u00famero 2: \")\nnumero1 = float(numero1)\nnumero2 = float(numero2)\nprint(f\"Suma = {n1+n2}\")\n</code></pre> <p>Lo que al ejecutarse muestra algo as\u00ed como:</p> <pre><code>N\u00famero 1: 27\nN\u00famero 2: 12.5\nSuma = 39.5\n</code></pre> <p>Lo que introduce el usuario es un dato del tipo <code>str</code>. Con la funci\u00f3n <code>float</code>, obtenemos el valor num\u00e9rico correspondiente y se lo asignamos a la propia variable, perdi\u00e9ndose el texto original.</p>"},{"location":"007-02-Conversiones.html#las-variables-pueden-cambiar-de-tipo","title":"Las variables pueden cambiar de tipo","text":"<p>En el ejemplo anterior, vemos que al asignar un dato a una variable:</p> <pre><code>numero1 = float(numero1)\n</code></pre> <p>... no solo se pierde el dato original, sino que el nuevo puede ser de un tipo  diferente.</p> <p>En otros lenguajes de programaci\u00f3n, esto se considera un herej\u00eda. Las variables pueden cambiar de valor a lo largo de la ejecuci\u00f3n del programa, pero no pueden cambiar de tipo. Python lo permite.</p> <p>Nota para quienes tengan experiencia en otros lenguajes</p> <p>\u00bfComo es posible redefinir una variable para que cambie de tipo? Se debe a que las variables Python son en realidad punteros. Si escribimos:</p> <pre><code>x = 0\nx = \"0\"\n</code></pre> <p>lo que almacena la variable x es la direcci\u00f3n de memoria del objeto asignado. Los objetos que dejan de estar apuntados por ninguna variable, ser\u00e1n suprimidos por el recolector de basura de Python.</p>"},{"location":"007-03-Metodos.html","title":"M\u00e9todos","text":""},{"location":"007-03-Metodos.html#que-es-un-metodo","title":"\u00bfQue es un m\u00e9todo?","text":"<p>Un m\u00e9todo es una funci\u00f3n especial asociada a un tipo de dato. Por ejemplo, la funci\u00f3n <code>print()</code> no est\u00e1 asociada a un tipo particular de dato, pero la funci\u00f3n <code>upper()</code>, que devuelve un texto convertido en may\u00fasculas, solo se puede ejecutar con datos tipo <code>str</code>.</p> <p>Veamos como funciona:</p> <pre><code>&gt;&gt;&gt; texto = \"Feliz A\u00f1o\"\n&gt;&gt;&gt; mayusculas = texto.upper()\n&gt;&gt;&gt; mayusculas\n   'FELIZ A\u00d1O'\n</code></pre> <p>A este tipo de operaciones, asociadas a un objeto, se les llama \"m\u00e9todos\". Se escriben anteponiendo el objeto, y un punto entre el mismo y el nombre del m\u00e9todo:</p> <pre><code>mayusculas = texto.upper()\n</code></pre> <p>en lugar de:</p> <pre><code>mayusculas = uper(texto)\n</code></pre> <p>Comprobamos la diferencia entre invocar una funci\u00f3n y un m\u00e9todo:</p> <pre><code>&gt;&gt;&gt; texto = \"Feliz A\u00f1o\"\n&gt;&gt;&gt; len(texto)\n    9\n\n&gt;&gt;&gt; texto.upper()\n    'FELIZ A\u00d1O'\n</code></pre> <p>\u00bfPor que <code>len()</code> es una funci\u00f3n y <code>upper()</code> un m\u00e9todo? Esto se debe a que <code>len()</code> puede usarse con otros tipos, en particular con colecciones de  varios elementos, que veremos m\u00e1s adelante. La funci\u00f3n <code>len()</code> devuelve el n\u00famero de elementos. Por el contrario, todo m\u00e9todo est\u00e1 asociado a un tipo concreto de objeto.</p>"},{"location":"007-03-Metodos.html#un-ejemplo","title":"Un ejemplo","text":"<p>Volvamos a nuestro ejemplo de la sumadora. El usuario puede introducir un  n\u00famero con decimales:</p> Sumadora.py<pre><code>numero1 = input(\"N\u00famero 1: \")\nnumero2 = input(\"N\u00famero 2: \")\nnumero1 = float(numero1)\nnumero2 = float(numero2)\nprint(f\"Suma = {n1+n2}\")\n</code></pre> <p>Pero se supone que va a utilizar el punto decimal. \u00bfQue pasa si utiliza la coma?</p> <pre><code>N\u00famero 1: 1234,56\n</code></pre> <p>Antes de hacer la conversi\u00f3n a <code>float</code>, podemos reemplazar las comas por puntos con la ayuda del m\u00e9todo <code>replace()</code>:</p> Sumadora.py<pre><code>numero1 = input(\"N\u00famero 1: \")\nnumero2 = input(\"N\u00famero 2: \")\n\nnumero1 = numero1.replace( \",\" , \".\" )\nnumero2 = numero2.replace( \",\" , \".\" )\n\nn1 = float(numero1)\nn2 = float(numero2)\n\nprint(f\"Suma = {n1+n2}\")\n</code></pre> <p>El m\u00e9todo <code>replace()</code> est\u00e1 asociado a una cadena de texto, que ser\u00e1 transformada generando un nuevo texto (las cadenas son inmutables). Se le pasan dos cadenas como argumento, el texto a reemplazar (la coma) y el valor de sustituci\u00f3n (el punto).</p>"},{"location":"007-04-Aritmetica.html","title":"Algo de aritm\u00e9tica","text":""},{"location":"007-04-Aritmetica.html#operadores","title":"Operadores","text":"<p>Ya hemos visto cinco operadores aritm\u00e9ticos:</p> <ul> <li> <p>Suma:</p> <pre><code>&gt;&gt;&gt; 25+3\n    28\n</code></pre> </li> <li> <p>Resta:</p> <pre><code>&gt;&gt;&gt; 25-3\n    22\n</code></pre> </li> <li> <p>Multiplicaci\u00f3n:</p> <pre><code>&gt;&gt;&gt; 25*3\n    75\n</code></pre> </li> <li> <p>Divisi\u00f3n:        </p> <pre><code>&gt;&gt;&gt; 25/3\n    8.333333333333334\n</code></pre> </li> <li> <p>Potencia:</p> <pre><code>&gt;&gt;&gt; 25**3\n    15625\n</code></pre> </li> </ul> <p>Las operaciones de divisi\u00f3n generan un resultado float, aunque los operandos sean <code>int</code>. Si queremos una divisi\u00f3n entera, sin decimales, podemos usar:</p> <ul> <li> <p>Para el c\u00e1lculo del cociente:</p> <pre><code>&gt;&gt;&gt; 25//3\n    8\n</code></pre> </li> <li> <p>Para calcular el resto de la divisi\u00f3n:</p> <pre><code>&gt;&gt;&gt; 25%3\n    1\n</code></pre> </li> </ul> <p>Ambas operaciones devuelven un resultado <code>int</code>. Los operandos deber\u00edan ser <code>int</code>. Python no se quejar\u00e1 si son float, aunque el resultado puede no ser de mucha  utilidad:</p> <pre><code>&gt;&gt;&gt; 25.2//3.1\n    8.0\n\n&gt;&gt;&gt; 25.2%3.1\n    0.3999999999999986\n</code></pre> <p>\u00bfComo se calcula el resto de una divisi\u00f3n? En tres fases. Usemos la variable shell <code>_</code> para comprobarlo:</p> <pre><code>&gt;&gt;&gt; 25.2//3.1\n    8.0\n\n&gt;&gt;&gt; _ * 3.1\n    24.8\n\n&gt;&gt;&gt; 25.2 - _\n    0.3999999999999986\n</code></pre>"},{"location":"007-04-Aritmetica.html#signo-de-las-operaciones","title":"Signo de las operaciones","text":"<p>Recordemos que los valores negativos se representan anteponiendo un s\u00edmbolo <code>-</code></p> <pre><code>&gt;&gt;&gt; 100-230\n    -130\n</code></pre> <p>Podemos poner un valor negativo como literal en una expresi\u00f3n:</p> <pre><code>&gt;&gt;&gt; 100 + (-1)\n    99\n</code></pre> <p>Veamos algunas multiplicaciones con signo:</p> <pre><code>&gt;&gt;&gt; 10 * 10\n&gt;&gt;&gt; 100\n\n&gt;&gt;&gt; 10 * -10\n&gt;&gt;&gt; -100\n\n&gt;&gt;&gt; -10 * 10\n&gt;&gt;&gt; -100\n\n&gt;&gt;&gt; -10 * -10\n&gt;&gt;&gt; 100\n</code></pre> <p>Divisiones:</p> <pre><code>&gt;&gt;&gt; 10/10\n    1.0\n\n&gt;&gt;&gt; 10/-10\n    -1.0\n\n&gt;&gt;&gt; -10/10\n    -1.0\n\n&gt;&gt;&gt; -10/-10\n    1.0\n</code></pre>"},{"location":"007-04-Aritmetica.html#el-modulo-random","title":"El m\u00f3dulo random","text":"<p>El m\u00f3dulo random proporciona funciones que devuelven n\u00fameros al azar.  Por ejemplo:</p> <pre><code>&gt;&gt;&gt; import random\n&gt;&gt;&gt; random.randint(3, 9)\n    5\n</code></pre> <p>La funci\u00f3n <code>randint(a,b)</code> devuelve un n\u00famero al azar entre a y b</p> <p>La funci\u00f3n <code>random()</code> devuelve un n\u00famero float entre 0 y 1:</p> <pre><code>&gt;&gt;&gt; random.random()\n    0.6749348988795146\n</code></pre> <p>\u00bfComo podemos obtener un n\u00famero float entre 0 y un valor n? Multiplicando el resultado de <code>random()</code> por n:</p> <pre><code>&gt;&gt;&gt; random.random()*1000\n    888.8664473749074\n\n&gt;&gt;&gt; random.random()*1000\n    593.2422282656003\n</code></pre> <p>de esta foma, obtendremos valores entre 0.0 y 1000.0</p>"},{"location":"008-01-Condicional.html","title":"Sentencias condicionales","text":"<p>Hasta ahora, hemos ejecutado las sentencias de un programa en secuencia, una tras otra, pero esa secuencia se puede alterar.</p> <p>Veamos el primer caso. Vamos a ejecutar una sentencia solo si se da una  condici\u00f3n.</p> Condicional1.py<pre><code>nombre = input(\"Introduzca su nombre: \")\nn = len(nombre)\nif n &lt; 3:\n    print(f\"{nombre}, \u00bfno es un nombre demasiado corto?\")\nelse:\n    print(f\"Bienvenido, {nombre}\")\n</code></pre> <p>Lo que al ejecutarse muestra algo as\u00ed como:</p> <pre><code>Introduzca su nombre: Juli\u00e1n\nBienvenido, Juli\u00e1n\n</code></pre> <p>o bien:</p> <pre><code>Introduzca su nombre: x\nx, \u00bfno es un nombre demasiado corto?\n</code></pre> <p>La palabra if significa \"si\". La palabra else significa \"en caso contrario\". En el ejemplo, vemos que las l\u00edneas 4 y 6 no se ejecutan siempre. Previamente se eval\u00faa una condici\u00f3n y se ejecuta una u otra.</p> <p>En l\u00edneas generales, la sintaxis de una sentencia condicional es:</p> <pre><code>if condici\u00f3n :\n    sentencia a ejecutar si la condici\u00f3n se cumple\n    sentencia condicional 2\n    sentencia condicional 3\nelse :\n    sentencia 4, a ejecutar si la condici\u00f3n no se cumple\n    sentencia 5\n    sentencia 6\n\notras sentencias que deben ejecutarse siempre\n</code></pre> <p>A tener en cuenta:</p> <ul> <li> <p>Los bloques condicionales pueden estar formados por una o varias sentencias</p> </li> <li> <p>Todo bloque condicional se delimita mediante sangr\u00eda.</p> </li> <li> <p>El bloque <code>else</code> se ejecuta cuando la condici\u00f3n no se cumple. Es opcional,      y se puede omitir:</p> <pre><code>if condici\u00f3n :\n    sentencias a ejecutar si la condici\u00f3n se cumple\n\notras sentencias que deben ejecutarse siempre\n</code></pre> </li> <li> <p>No olvidar los dos puntos que delimitan el final de las l\u00edneas if y else:</p> <pre><code>if condici\u00f3n :\n    sentencias\nelse :\n    sentencias\n</code></pre> </li> </ul>"},{"location":"008-01-Condicional.html#sangria","title":"Sangr\u00eda","text":"<p>La sangr\u00eda que delimita un bloque puede estar formada por espacios o por caracteres de tabulaci\u00f3n, pero dentro de un bloque, no podemos mezclar un estilo  con otro. Si en una l\u00ednea ponemos tabuladores y en otra espacios, obtendremos un mensaje de error:</p> <pre><code>TabError: inconsistent use of tabs and spaces in indentation\n</code></pre> <p>Tambi\u00e9n tenemos que vigilar que la sangr\u00eda sea consistente para todas las l\u00edneas del bloque. Lo siguiente es err\u00f3neo, porque las l\u00edneas 4 y 5 no est\u00e1n alineadas:</p> Condicional1.py<pre><code>nombre = input(\"Introduzca su nombre: \")\nn = len(nombre)\nif n &lt; 3:\n    print(f\"{nombre}, \u00bfno es un nombre demasiado corto?\")\n      print(\"adios\")    \nelse:\n    print(f\"Bienvenido, {nombre}\")\n</code></pre> <p>Cuesti\u00f3n de estilo</p> <p>El n\u00famero de espacios a utilizar para la sangr\u00eda es una cuesti\u00f3n de estilo personal, al igual que lo es el uso de may\u00fasculas y min\u00fasculas. Sin embargo, conviene adoptar un estilo ampliamente aceptado por la comunidad de  programadores Python. Esto facilita el examen de los programas escritos por otras personas.</p> <p>La PEP n\u00ba 8 es un documento que  propone unas reglas de estilo que se recomienda seguir. En cuanto a la sangr\u00eda, dice que:</p> <p>Spaces are the preferred indentation method.</p> <p>Use 4 spaces per indentation level.</p>"},{"location":"008-01-Condicional.html#operadores","title":"Operadores","text":"<p>La condici\u00f3n a evaluar ha de ser una expresi\u00f3n cuyo resultado ha de ser Verdadero o Falso. Al igual que en las expresiones aritm\u00e9ticas tenemos  los operadores <code>+</code>, <code>-</code>, <code>*</code> y <code>/</code>, en las expresiones de comparaci\u00f3n tenemos  los siguientes operadores:</p> <ul> <li>Menor que: <code>a &lt; b</code></li> <li>Menor o igual que: <code>a &lt;= b</code></li> <li>Mayor que: <code>a &gt; b</code></li> <li>Mayor o igual que: <code>a &gt;= b</code></li> <li>Igual a: <code>a == b</code></li> <li>Distinto de: <code>a != b</code></li> </ul> <p>Un ejemplo:</p> Contrase\u00f1a.py<pre><code>texto = input(\"Introduzca contrase\u00f1a: \")\nif texto == \"Hola\":\n    print(\"contrase\u00f1a correcta\")\nelse:\n    print(\"contrase\u00f1a incorrecta\")\n</code></pre> <p>En la segunda l\u00ednea usamos el operador de igualdad <code>==</code>. \u00bfPor que es un doble s\u00edmbolo <code>==</code>? Para no confundirlo con el operador de  asignaci\u00f3n. Es decir:</p> <ul> <li><code>x=10</code> asigna un valor 10 a la variable x</li> <li><code>x==10</code> comprueba que valor de la variable x es 10</li> </ul> <p>Los operadores formados por dos s\u00edmbolos no admiten un espacio entre ellos, porque se convertir\u00edan en dos tokens separados. Es decir, no podemos escribir:</p> <pre><code>a &gt; = b\n</code></pre> <p>En su lugar, debemos escribir:</p> <pre><code>a &gt;= b\n</code></pre>"},{"location":"008-01-Condicional.html#la-sentencia-pass","title":"La sentencia pass","text":"<p>Hay veces que necesitamos decir si se da una condici\u00f3n, no hacer nada, en caso contrario hacer esto otro.</p> <p>\u00bfComo se indica que no queremos hacer nada? Con la sentencia <code>pass</code>:</p> Condicional2.py<pre><code>nombre = input(\"Introduzca su nombre: \")\nn = len(nombre)\nif n &gt; 2:\n    pass\nelse:\n    print(f\"{nombre} es demasiado corto\")\n    exit(1)\nprint(f\"Bienvenido, {nombre}\")\n</code></pre>"},{"location":"008-01-Condicional.html#condiciones-multiples","title":"Condiciones m\u00faltiples","text":"<p>Cuando tenemos que controlar varias situaciones, se utilizan tres bloques, <code>if</code>, <code>elif</code> y <code>else</code>:</p> Condicional2.py<pre><code>nombre = input(\"Introduzca su nombre: \")\nn = len(nombre)\n\nif n == 0:\n    print(\"Error: nombre en blanco\")\n\nelif n &lt; 3:\n    print(\"Error: nombre muy corto\")\n\nelif n &gt; 30:\n    print(\"Error: nombre demasiado largo\")\n\nelse:\n    print(f\"Bienvenido, {nombre}\")\n</code></pre> <p>A tener en cuenta:</p> <ul> <li> <p><code>elif</code> significa else if. Sirve para comprobar otras condiciones cuando     lo anterior no se cumple.</p> </li> <li> <p>los bloques <code>elif</code> y <code>else</code> son opcionales. Si se ponen, <code>else</code> debe ser     el \u00faltimo bloque.</p> </li> <li> <p>puede haber tantos bloques <code>elif</code> como queramos.</p> </li> <li> <p>tanto las sentencias <code>if</code> como <code>elif</code> deben ir acompa\u00f1adas de una expresi\u00f3n     condicional. La sentencia <code>else</code> nunca lleva expresi\u00f3n condicional, porque     significa si todo lo dem\u00e1s falla.</p> </li> </ul>"},{"location":"008-01-Condicional.html#bloque-anidados","title":"Bloque anidados","text":"<p>Un bloque condicional est\u00e1 formado por sentencias que, a su vez, pueden contener otros bloques condicionales, delimitados por nuevos niveles de sangrado.</p> <p>Por ejemplo:</p> Condicional2.py<pre><code>nombre = input(\"Introduzca su nombre: \")\nn = len(nombre)\n\nif n == 0:\n    print(\"Error: nombre en blanco\")\n\nelse:\n    if n &lt; 3:\n        print(\"Error: nombre muy corto\")\n    else:\n        if n &gt; 30:\n            print(\"Error: nombre demasiado largo\")\n        else:\n            print(f\"Bienvenido, {nombre}\")\n</code></pre> <p>Esta es una alternativa al uso de sentencias <code>elif</code>. \u00bfQue estilo usar?  En l\u00edneas generales, el que facilite el examen del programa y lo haga m\u00e1s  sencillo de revisar.</p>"},{"location":"008-02-Booleano.html","title":"Valores booleanos","text":"<p>Consideremos la siguiente sentencia:</p> <pre><code>if a &gt; b :\n    sentencias a ejecutar\n</code></pre> <p>Al evaluar la expresi\u00f3n <code>a &gt; b</code>, se obtiene un resultado, como sucede con las expresiones aritm\u00e9ticas:</p> <pre><code>&gt;&gt;&gt; 5 + 2\n    7\n\n&gt;&gt;&gt; 5 &gt; 2\n    True\n\n&gt;&gt;&gt; 5 &lt; 2\n    False\n</code></pre> <p>Los resultados de una expresi\u00f3n de comparaci\u00f3n solo pueden ser dos, verdadero o falso, que en Python se expresan mediante las palabras True y False  (la letra inicial en may\u00fascula). Son palabras reservadas del lenguaje.</p> <p>Los valores True y False se pueden asignar a una variable:</p> <pre><code>&gt;&gt;&gt; valor1 = 5 + 2\n&gt;&gt;&gt; valor2 = 5 &gt; 2\n&gt;&gt;&gt; print(valor1, valor2)\n    7 True\n</code></pre> <p>\u00bfCual es el tipo de esas variables?</p> <pre><code>&gt;&gt;&gt; type(valor1)\n    &lt;class 'int'&gt;\n\n&gt;&gt;&gt; type(valor2)\n    &lt;class 'bool'&gt;\n</code></pre> <p>Los valores True y False son datos del tipo bool. A estos datos se les  llama booleanos.</p> <p>El t\u00e9rmino \"booleano\" se llama as\u00ed en honor a un matem\u00e1tico brit\u00e1nico del siglo XIX, George Boole. \u00c9l fue quien desarroll\u00f3 las reglas de l\u00f3gica que sirven de base para el funcionamiento de los modernos ordenadores.</p>"},{"location":"008-02-Booleano.html#equivalencias","title":"Equivalencias","text":"<p>Toda sentencia <code>if</code> debe ir acompa\u00f1ada de una expresi\u00f3n o de una variable cuyo valor sea booleano, es decir, True o False:</p> Booleano1.py<pre><code>x = 17\npositivo = (x &gt;= 0)\nif positivo:\n    print(\"valor positivo\")\nelse:\n    print(\"valor negativo\")\n</code></pre> <p>En este ejemplo, evaluamos una expresi\u00f3n condicional y asignamos el valor resultante a una variable. En la sentencia <code>if</code>, en lugar de una condici\u00f3n,  usamos el valor de la variable. Lo que espera la sentencia <code>if</code> es que pongamos algo cuyo valor sea True o False.</p> <p>Pero, \u00bfque pasar\u00eda si en la sentencia <code>if</code> ponemos una expresi\u00f3n o variable que no sea booleana? Por ejemplo:</p> Descuento.py<pre><code>importe = 1000\ndescuento = 5      # en tanto por ciento\n\nif descuento :\n    importe = importe - (importe*5/100)\n\nprint(\"A pagar:\", importe)\n</code></pre> <p>Esto muestra:</p> <pre><code>A pagar: 950.0\n</code></pre> <p>En teor\u00eda, deber\u00edamos escribir:</p> <pre><code>if descuento != 0 :\n    importe = importe - (importe*5/100)\n</code></pre> <p>pero Python considera que todo valor num\u00e9rico distinto de cero equivale a True, mientras que el cero equivale a False. De igual forma, una cadena de texto con cero caracteres, equivale a False:</p> NombreEnBlanco.py<pre><code>nombre = input(\"Introduzca su nombre: \")\nif nombre:\n    print(\"Bienvenido\", nombre)\n</code></pre> <p>En lugar de:</p> <pre><code>if len(nombre)&gt;0 :\n</code></pre> <p>escribimos:</p> <pre><code>if nombre :\n</code></pre> <p>Si el usuario teclea Enter directamente, obtenemos una cadena de texto sin caracteres, lo que se conoce como cadena vac\u00eda. Tambi\u00e9n podemos crear cadenas  vac\u00edas mediante:</p> <pre><code>texto = \"\"\n</code></pre> <p>Una cadena vac\u00eda equivale a False en el contexto de una sentencia <code>if</code>. Cualquier otra cadena equivale a True.</p>"},{"location":"008-03-Relacional.html","title":"Combinando condiciones","text":"<p>Hay veces que necesitamos indicar:</p> <pre><code>si se cumple la condici\u00f3n 1 y la condici\u00f3n 2 a la vez:\n    hacer la tarea\n</code></pre> <p>lo que puede resolverse mediante:</p> <pre><code>if condici\u00f3n 1 :\n    if condici\u00f3n 2 :\n        hacer tarea\n\notras sentencias\n</code></pre> <p>Es decir, si la condici\u00f3n 1 falla, no nos molestamos en comprobar la condici\u00f3n 2, porque deben cumplirse ambas a la vez.</p> <p>De todas formas, es m\u00e1s f\u00e1cil escribir:</p> <pre><code>if condici\u00f3n 1 and condici\u00f3n 2 :\n    hacer tarea\n</code></pre> <p>lo que combina dos condiciones en una sola expresi\u00f3n.</p>"},{"location":"008-03-Relacional.html#operadores-booleanos","title":"Operadores booleanos","text":"<p>Los operadores booleanos son aquellos cuyos operandos son booleanos:</p> <pre><code>True and True = True\nTrue and False = False\nFalse and False = False\n</code></pre> <p>Veamos un ejemplo:</p> CondicionesAnd.py<pre><code>a = 20\nb = 33\nc = 40\nif b &gt; a and c &gt; a:\n    print(\"Ambas condiciones se cumplen\")\n</code></pre> <p>Vemos que el operador <code>and</code> toma dos operandos, cuyo valor ha de ser Verdadero o Falso.</p> <p>Los operadores de comparaci\u00f3n, como es el caso de <code>&gt;</code>, tienen prioridad sobre los booleanos, por lo que se eval\u00faan antes:</p> <pre><code>if b &gt; a and c &gt; a:\n</code></pre> <p>El operador <code>or</code>, solo obliga a que alguna (o ambas) de las condiciones se cumpla:</p> CondicionesOr.py<pre><code>a = 20\nb = 33\nc = 40\nif b &gt; a or a &gt; c:\n    print(\"Al menos una de las condiciones se cumple\")\n</code></pre> <p>Es decir:</p> <pre><code>True or True = True\nTrue or False = True\nFalse or False = False\n</code></pre>"},{"location":"008-03-Relacional.html#el-operador-not","title":"El operador <code>not</code>","text":"<p>El operador <code>not</code> se antepone a una condici\u00f3n, y sirve para invertirla. Si la condici\u00f3n es verdadera, el conjunto es falso, y viceversa:</p> <pre><code>if not condici\u00f3n :\n    sentencias\n</code></pre> <p>Por ejemplo</p> <pre><code>a = 33\nb = 20\nif not a &gt; b:\n    print(\"a no es mayor que b\")\n</code></pre> <p>Es decir:</p> <pre><code> not True = False\n not False = True\n</code></pre> <p>En general, el uso de <code>not</code> suele resultar algo confuso, y generalmente es  preferible usar otra combinaci\u00f3n de operadores operador. En lugar de:</p> <pre><code>if not a &gt; b\n</code></pre> <p>podemos escribir</p> <pre><code>if a &lt;= b\n</code></pre> <p>pero en condiciones complejas, puede resultar \u00fatil:</p> <pre><code>if not (a&gt;b and c==b)\n</code></pre> <p>lo que significa \"si no se dan ambas condiciones...\"</p> <p>Los operadores <code>and</code>, <code>or</code> y <code>not</code> son conocidos como booleanos, porque sus operandos son valores booleanos.</p>"},{"location":"008-03-Relacional.html#cortocircuito","title":"Cortocircuito","text":"<p>Si combinamos dos condiciones:</p> <pre><code>if condici\u00f3n 1 and condici\u00f3n 2 :\n    hacer tarea\n</code></pre> <p>... a veces basta con evaluar el primer operando para saber el resultado final. En el ejemplo, si no se cumple la condici\u00f3n 1, no es necesario evaluar la  condici\u00f3n 2, ya que el resultado final va a ser False de todas formas.</p> <p>En este caso, Python no va a evaluar la segunda condici\u00f3n, lo que se conoce como cortocircuito. Otro ejemplo:</p> <pre><code>if condici\u00f3n 1 or condici\u00f3n 2 :\n    hacer tarea\n</code></pre> <p>Vemos que, si se cumple la primera condici\u00f3n, ya sabemos que el resultado final va a ser True.</p> <p>Si las condiciones son expresiones que incluyen la llamada a una funci\u00f3n, hay que tener en cuenta que es posible que la funci\u00f3n no sea invocada. Si la funci\u00f3n realiza una tarea importante (como modificar una variable o guardar datos en disco), esa tarea podr\u00eda quedarse sin realizar.</p>"},{"location":"008-04-Bucles.html","title":"Bucles","text":"<p>En los cap\u00edtulos anteriores hemos visto como introducir una sentencia condicional:</p> <pre><code>n = 5\nif n&gt;0:\n    print(n)\n</code></pre> <p>Un bucle consiste en ejecutar el bloque condicional de forma repetida, mientras se cumpla la condici\u00f3n. Hay que cambiar la palabra <code>if</code> por <code>while</code>:</p> CuentaAtras.py<pre><code>print(\"Cuenta atr\u00e1s:\")\nn = 5\nwhile n:\n    print(n)\n    n -= 1\n</code></pre> <p>Al ejecutarse, muestra:</p> <pre><code>Cuenta atr\u00e1s:\n5\n4\n3\n2\n1\n</code></pre> <p>A tener en cuenta:</p> <ul> <li> <p>Estamos usando una variable \"de control\" para verificar cuando debe detenerse el bucle.</p> </li> <li> <p>Podr\u00edamos escribir:</p> <pre><code>while n&gt;0 :\n</code></pre> <p>pero nos estamos aprovechando de que 0 equivale a False</p> </li> <li> <p>\u00a1Importante! No olvidar modificar la variable de control en cada iteraci\u00f3n     del bucle:</p> <pre><code>n -= 1\n</code></pre> <p>Sin ello, el bucle se ejecutar\u00eda indefinidamente.</p> </li> </ul>"},{"location":"008-04-Bucles.html#sentencia-break","title":"Sentencia break","text":"<p>Una sentencia break fuerza que se abandone el bucle y se vaya a las sentencias que hay a continuaci\u00f3n:</p> Contrase\u00f1a.py<pre><code>contrase\u00f1a = \"Hola\"\nintentos = 3\n\nwhile intentos &gt; 0:\n    texto = input(\"Introduzca contrase\u00f1a: \")\n\n    if texto == contrase\u00f1a:\n        print(\"contrase\u00f1a correcta\")\n        break\n    else:\n        print(\"contrase\u00f1a incorrecta\\n\")\n        intentos -= 1\n\nif intentos &gt; 0:\n    print(\"bienvenido\")\n</code></pre> <p>En el ejemplo, si el usuario adivina la contrase\u00f1a, se deja de preguntarle y se abandona el bucle. Seguidamente, si la variable intentos tiene un valor mayor que cero, significa que hemos salido con break.</p>"},{"location":"008-04-Bucles.html#bucles-infinitos","title":"Bucles infinitos","text":"<p>En el ejemplo anterior, al usuario le damos tres oportunidades para adivinar la contrase\u00f1a. Podr\u00edamos darle un n\u00famero indefinido de oportunidades mediante:</p> <pre><code>contrase\u00f1a = \"Hola\"\n\nwhile True:\n    texto = input(\"Introduzca contrase\u00f1a (en blanco para abandonar): \")\n\n    if len(texto)==0:\n        break\n\n    elif texto == contrase\u00f1a:\n        print(\"contrase\u00f1a correcta\")\n        break\n\n    else:\n        print(\"contrase\u00f1a incorrecta\\n\")\n\nif len(texto) &gt; 0:\n    print(\"bienvenido\")\n</code></pre> <p>Cuando en la cabecera de un bucle escribimos:</p> <pre><code>while True :\n</code></pre> <p>la expresi\u00f3n condicional es directamente True, y el bucle se ejecutar\u00e1 indefinidamente. Necesitamos alguna sentencia break para salir.</p>"},{"location":"008-04-Bucles.html#sentencia-continue","title":"Sentencia continue","text":"<p>Una sentencia <code>continue</code> es similar a <code>break</code>:</p> <ul> <li> <p>ambas ignoran el resto de sentencias que quedan dentro del bucle:</p> <pre><code>while condici\u00f3n:\n    sentencias que se ejecutan\n    break\n    sentencias que se ignoran\n</code></pre> </li> <li> <p><code>break</code> abandona las iteraciones, mientras que <code>continue</code> fuerza una     nueva iteraci\u00f3n.</p> </li> </ul> <p>Un ejemplo:</p> Impares.py<pre><code># mostrar n\u00fameros impares\n\nlimite = 10\nn=0\nwhile True:\n    n += 1\n    if n&gt;limite:\n        break\n    elif n%2==0:     ## Si es divisible por 2\n        continue\n    else:\n        print(n)\n</code></pre> <p>Al ejecutarse, muestra:</p> <pre><code>1\n3\n5\n7\n9\n</code></pre> <p>Recordemos que el operador <code>%</code> devuelve el resto de la divisi\u00f3n.  Si dividimos un n\u00famero entre 2 y el resto es cero, el n\u00famero es par.</p>"},{"location":"008-04-Bucles.html#sentencias-condicionales-en-el-shell","title":"Sentencias condicionales en el shell","text":"<p>Cuando introducimos en el shell una sentencia condicional o un bucle,  formados por un bloque de sentencias sangrado, hasta no completar el bloque, se sigue mostrando el prompt secundario. Al finalizar, se ejecuta todo el bloque:</p> <pre><code>&gt;&gt;&gt; n=5\n... while n:\n...     print(n)\n...     n -= 1\n... \n...     \n    5\n    4\n    3\n    2\n    1\n</code></pre> <p>Para indicar el final de la sangr\u00eda, en el shell necesitamos a\u00f1adir una l\u00ednea en blanco. En un programa, estas son decorativas.</p>"},{"location":"008-05-Adivinanzas.html","title":"El juego de las adivinanzas","text":"<p>Llegados a este punto, vamos a crear nuestro primer juego.</p>"},{"location":"008-05-Adivinanzas.html#el-programa","title":"El programa","text":"<p>El texto del programa es el siguiente:</p> AdivinarUnNumero.py<pre><code># Adivina un n\u00famero\n\nfrom random import randint\n\njugar = True\nwhile jugar:\n\n    print('Adivina un n\u00famero entre 1 y 100.')\n    print('Introduce 0 para abandonar.')\n\n    numero = randint(1,100)\n\n    while True:\n        intento = int(input(\"\\n&gt; \"))   # a\u00f1adir un salto de l\u00ednea previo\n\n        if intento == 0:\n            jugar = False\n            break\n        if intento == numero:\n            print(f\"Lo adivinaste. Es {numero}.\\n\")\n            break\n        elif intento &lt; numero:\n            print(\"Te quedaste corto\")\n        else:\n            print(\"Te pasaste\")\n\nprint(\"Adios.\")\n</code></pre> <p>Lo que muestra algo as\u00ed como:</p> <pre><code>Adivina un n\u00famero entre 1 y 100.\nIntroduce 0 para abandonar.\n\n&gt; 27\nTe quedaste corto\n\n&gt; 55\nTe pasaste\n\n&gt; 43\nTe pasaste\n\n&gt; 42\nLo adivinaste. Es 42.\n\nAdivina un n\u00famero entre 1 y 100.\nIntroduce 0 para abandonar.\n\n&gt; 0\nAdios.\n</code></pre> <p>\u00bfPara que necesitamos la variable jugar? Porque al escribir la sentencia:</p> <pre><code>break\n</code></pre> <p>salimos del bucle interno, pero no del externo. Estar\u00edamos abandonando el juego actual y forzando un nuevo juego. Necesitamos una forma de salir del programa definitivamente.</p>"},{"location":"008-05-Adivinanzas.html#control-de-errores","title":"Control de errores","text":"<p>\u00bfQue suceder\u00eda si el usuario introduce algo que no es un n\u00famero?</p> <pre><code>Adivina un n\u00famero entre 1 y 100.\nIntroduce 0 para abandonar.\n\n&gt; Hola\n\nTraceback (most recent call last):\n  File \"/usr/lib/python3.13/idlelib/run.py\", line 590, in runcode\n    exec(code, self.locals)\n    ~~~~^^^^^^^^^^^^^^^^^^^\n  File \"/mnt/compartidas/P\u00fablica/python/prueba/prueba.py\", line 14, in &lt;module&gt;\n    intento = int(input(\"\\n&gt; \"))\n\nValueError: invalid literal for int() with base 10: 'Hola'\n</code></pre> <p>La sentencia:</p> <pre><code>intento = int(input(\"\\n&gt; \"))\n</code></pre> <p>toma el texto devuelto por la funci\u00f3n <code>input()</code> y trata de convertirlo en  n\u00famero entero.</p> <p>Queremos evitar que se detenga el programa. En lugar de esta sentencia, escribimos:</p> <pre><code>try:\n    intento = int(input(\"\\n&gt; \"))\nexcept:\n    intento = 0\n</code></pre> <p>lo que significa:</p> <pre><code>intentar ejecutar lo siguiente:\n    sentencia1\n    sentencia2\n    sentencia3\nsi se produce alg\u00fan fallo, ejecutar:\n    sentencia4\n    sentencia5\n\notras sentencias a ejecutar\n</code></pre> <p>Los bloques <code>try</code> se ejecutar\u00e1n bajo supervisi\u00f3n, y en el caso de que se  produzca cualquier fallo, en lugar de detener el programa, gestionaremos el error de forma elegante ejecutando lo que hay en el bloque <code>except</code>.</p> <p>Como sucede con los bloques condicionales, no olvidar los dos puntos que hay tras las sentencias <code>try</code> y <code>except</code>.</p> <p>El programa completo:</p> AdivinarUnNumero.py<pre><code>## Adivina un n\u00famero\n\nfrom random import randint\n\njugar = True\nwhile jugar:\n\n    print('Adivina un n\u00famero entre 1 y 100.')\n    print('Introduce 0 para abandonar.')\n\n    numero = randint(1,100)\n\n    while True:\n\n        try:\n            intento = int(input(\"\\n&gt; \"))\n        except:\n            intento = 0\n\n        if intento == 0:\n            jugar = False\n            break\n        if intento == numero:\n            print(f\"Lo adivinaste. Es {numero}.\\n\")\n            break\n        elif intento &lt; numero:\n            print(\"Te quedaste corto\")\n        else:\n            print(\"Te pasaste\")\n\nprint(\"Adios.\")\n</code></pre>"},{"location":"009-01-Listas.html","title":"Listas","text":""},{"location":"009-01-Listas.html#que-es-una-lista","title":"\u00bfQue es una lista?","text":"<p>Supongamos que estamos preparando un programa para que nuestro colegio lleve el control de alumnos:</p> <pre><code>alumno1 = 'Ana'\nalumno2 = 'Juan'\nalumno3 = 'Andr\u00e9s'\n</code></pre> <p>\u00bfCuantas variables necesita nuestro programa? Posiblemente, cientos.  El programa ser\u00eda inmanejable, y no podemos plantearnos el hecho de tener que modificarlo cada vez que hay un nuevo alumno.</p> <p>La soluci\u00f3n es crear una variable que almacene todos los datos:</p> <pre><code>&gt;&gt;&gt; alumnos = [ 'Ana', 'Juan', 'Andr\u00e9s']\n&gt;&gt;&gt; print(alumnos)\n    [ 'Ana', 'Juan', 'Andr\u00e9s']\n</code></pre> <p>A estos paquetes de datos se les llama listas. Se escriben entre corchetes, con los elementos separados por comas. Si la lista es muy larga, podemos escribir:</p> <pre><code>alumnos = [ 'Ana', \n            'Juan', \n            'Andr\u00e9s'\n            ]\n</code></pre> <p>ya que el int\u00e9rprete de Python considerar\u00e1 la sentencia como incompleta hasta encontrar el corchete de cierre.</p>"},{"location":"009-01-Listas.html#indexacion","title":"Indexaci\u00f3n","text":"<p>Como sucede con las cadenas de texto, al aplicar un \u00edndice, obtenemos un elemento:</p> <pre><code>&gt;&gt;&gt; alumnos = [ 'Ana', 'Juan', 'Andr\u00e9s']\n&gt;&gt;&gt; alumnos[1]\n    'Juan'\n</code></pre> <p>recordemos que los \u00edndices de una colecci\u00f3n de n elementos van de cero a n-1</p>"},{"location":"009-01-Listas.html#tipos","title":"Tipos","text":"<p>Una lista admite elementos de diferente tipo:</p> <pre><code>&gt;&gt;&gt; datos_alumno=[\"Ana\", 17]\n&gt;&gt;&gt; print(f\"Nombre: {datos_alumno[0]}. Edad: {datos_alumno[1]}.\")\n    Nombre: Ana. Edad: 17.\n</code></pre> <p>El tipo de una lista es <code>list</code>. Los elementos ser\u00e1n del tipo que corresponda:</p> <pre><code>&gt;&gt;&gt; type(datos_alumno)\n    &lt;class 'list'&gt;\n\n&gt;&gt;&gt; type(datos_alumno[0])\n    &lt;class 'str'&gt;\n\n&gt;&gt;&gt; type(datos_alumno[1])\n    &lt;class 'int'&gt;\n</code></pre>"},{"location":"009-01-Listas.html#las-listas-son-mutables","title":"Las listas son mutables","text":"<p>A diferencia de las cadenas de texto, que son secuencias inmutables, las listas son colecciones mutables:</p> <pre><code>&gt;&gt;&gt; alumnos = [ 'Ana', 'Juan', 'Andr\u00e9s']\n&gt;&gt;&gt; alumnos[0] = 'Anita'\n&gt;&gt;&gt; alumnos\n    ['Anita', 'Juan', 'Andr\u00e9s']  \n</code></pre>"},{"location":"009-01-Listas.html#anadir-elementos","title":"A\u00f1adir elementos","text":"<p>Para a\u00f1adir un elemento al final de una lista, usar el m\u00e9todo append</p> <pre><code>&gt;&gt;&gt; alumnos = [ 'Ana', 'Juan', 'Andr\u00e9s']\n&gt;&gt;&gt; alumnos.append('Teresa')\n&gt;&gt;&gt; alumnos\n['Ana', 'Juan', 'Andr\u00e9s', 'Teresa']\n</code></pre> <p>Siendo las listas mutables, el m\u00e9todo <code>append()</code> no genera una nueva lista, sino que modifica la lista asociada.</p> <p>Para a\u00f1adir un elemento en mitad de la lista, usar el m\u00e9todo insert</p> <pre><code>&gt;&gt;&gt; alumnos = [ 'Ana', 'Juan', 'Andr\u00e9s']\n&gt;&gt;&gt; alumnos.insert(1,'Teresa')\n&gt;&gt;&gt; alumnos\n    ['Ana', 'Teresa', 'Juan', 'Andr\u00e9s']\n</code></pre> <p>El primer argumento de <code>insert</code> es la posici\u00f3n donde colocar el nuevo elemento.  Recu\u00e9rdese que el primer elemento tiene \u00edndice cero. El resto de elementos  se desplazan y pasan a tener un \u00edndice mayor.</p> <p>Tanto el m\u00e9todo <code>insert()</code> como <code>append()</code> modifican la lista sin crear una nueva.</p>"},{"location":"009-01-Listas.html#listas-vacias","title":"Listas vac\u00edas","text":"<p>Una lista vac\u00eda es aquella que no tiene elementos. Se suelen usar cuando vamos a a\u00f1adir los elementos posteriormente:</p> <pre><code>&gt;&gt;&gt; alumnos = []\n&gt;&gt;&gt; alumnos.append('Ana')\n&gt;&gt;&gt; alumnos.append('Juan')\n&gt;&gt;&gt; alumnos.append('Andr\u00e9s')\n&gt;&gt;&gt; alumnos\n    ['Ana', 'Juan', 'Andr\u00e9s']\n</code></pre>"},{"location":"009-01-Listas.html#numero-de-elementos","title":"N\u00famero de elementos","text":"<p>Al igual que sucede con las cadenas de texto, podemos averiguar el n\u00famero de elementos de la lista con ayuda de la funci\u00f3n <code>len()</code>:</p> <pre><code>&gt;&gt;&gt; alumnos = [ 'Ana', 'Juan', 'Andr\u00e9s']\n&gt;&gt;&gt; len(alumnos)\n    3\n</code></pre>"},{"location":"009-02-OpListas.html","title":"Operaciones con listas","text":"<p>Las listas son un mecanismo muy poderoso. Veamos algunas operaciones que podemos realizar con ellas.</p>"},{"location":"009-02-OpListas.html#borrar-elementos","title":"Borrar elementos","text":"<p>La sentencia <code>del</code> permite borrar un elemento de la lista indicando su \u00edndice:</p> <pre><code>&gt;&gt;&gt; alumnos = [ 'Ana', 'Juan', 'Andr\u00e9s']\n&gt;&gt;&gt; del alumnos[1]\n&gt;&gt;&gt; alumnos\n    ['Ana', 'Andr\u00e9s']\n</code></pre>"},{"location":"009-02-OpListas.html#concatenar-listas","title":"Concatenar listas","text":"<p>Como sucede con las cadenas de texto, el operador <code>+</code> concatena dos listas para  obtener una nueva m\u00e1s grande:</p> <pre><code>&gt;&gt;&gt; amigos = [ 'Ana', 'Juan', 'Andr\u00e9s']\n&gt;&gt;&gt; familia = [ 'Victor', 'Luisa', 'Cristina']\n&gt;&gt;&gt; invitados = familia + amigos\n&gt;&gt;&gt; print(invitados)\n    ['Victor', 'Luisa', 'Cristina', 'Ana', 'Juan', 'Andr\u00e9s']\n</code></pre> <p>N\u00f3tese que se respeta el orden de los elementos.</p> <p>Supongamos que no queremos crear una nueva lista, sino incorporar los elementos  de la segunda lista a la primera. En principio, basta con asignar la nueva lista a la variable inicial, perdiendo la lista original:</p> <pre><code>&gt;&gt;&gt; personas = [ 'Ana', 'Juan', 'Andr\u00e9s']\n&gt;&gt;&gt; vecinos = [ 'Victor', 'Luisa', 'Cristina']\n&gt;&gt;&gt; personas = personas + vecinos\n&gt;&gt;&gt; print(personas)\n    ['Victor', 'Luisa', 'Cristina', 'Ana', 'Juan', 'Andr\u00e9s']\n</code></pre> <p>Pero hay una alternativa. El m\u00e9todo <code>extend()</code> toma una colecci\u00f3n de cualquier  tipo y a\u00f1ade sus elementos a la lista asociada, sin crear una nueva:</p> <pre><code>&gt;&gt;&gt; personas = [ 'Ana', 'Juan', 'Andr\u00e9s']\n&gt;&gt;&gt; vecinos = [ 'Victor', 'Luisa', 'Cristina']\n&gt;&gt;&gt; personas.extend(vecinos)\n&gt;&gt;&gt; personas\n    ['Ana', 'Juan', 'Andr\u00e9s', 'Victor', 'Luisa', 'Cristina']\n</code></pre>"},{"location":"009-02-OpListas.html#slicing","title":"Slicing","text":"<p>Al igual que sucede con las cadenas de texto, podemos obtener una nueva lista extrayendo una porci\u00f3n de la lista original:</p> <pre><code>&gt;&gt;&gt; amigos = [ 'Ana', 'Juan', 'Andr\u00e9s', 'Victor', 'Luisa', 'Cristina']\n&gt;&gt;&gt; amigos[1:4]\n    ['Juan', 'Andr\u00e9s', 'Victor']\n</code></pre> <p>El mecanismo de doble \u00edndice es similar al de los string, y en general, al de cualquier colecci\u00f3n.</p>"},{"location":"009-02-OpListas.html#esta-un-elemento-en-la-lista","title":"\u00bfEsta un elemento en la lista?","text":"<p>Podemos examinar una lista mediante:</p> <pre><code>&gt;&gt;&gt; amigos = [ 'Ana', 'Juan', 'Andr\u00e9s']\n&gt;&gt;&gt; elemento = 'Juan'\n&gt;&gt;&gt; encontrado = False\n&gt;&gt;&gt; n = 0\n&gt;&gt;&gt; limite = len(amigos)\n&gt;&gt;&gt; while n &lt; limite:\n...     if amigos[n] == elemento:\n...         encontrado = True\n...         break\n...     else:\n...        n += 1\n...\n&gt;&gt;&gt; encontrado\n    True\n</code></pre> <p>Bien, esto es un poco complejo. Hay un operador que nos puede simplificar  la vida:</p> <pre><code>&gt;&gt;&gt; amigos = [ 'Ana', 'Juan', 'Andr\u00e9s']\n&gt;&gt;&gt; 'Juan'  in amigos\n    True\n</code></pre> <p>El operador  <code>in</code> tiene dos operandos, a la izquierda, el elemento a buscar, y a la derecha, la lista donde buscar:</p> <pre><code>elemento = `Juan`\nif elemento in lista:\n    cosas a hacer...\n</code></pre>"},{"location":"009-02-OpListas.html#obtener-posicion-de-un-elemento","title":"Obtener posici\u00f3n de un elemento","text":"<p>El m\u00e9todo <code>index</code> devuelve la posici\u00f3n del elemento pasado como argumento:</p> <pre><code>&gt;&gt;&gt; amigos = [ 'Ana', 'Juan', 'Andr\u00e9s']\n&gt;&gt;&gt; amigos.index('Juan')\n    1\n</code></pre> <p>De todas formas, plantea un problema. Genera un error si el elemento no existe en la lista:</p> <pre><code>&gt;&gt;&gt; amigos.index('Pedro')\n    Traceback (most recent call last):\n      File \"/usr/lib/python3.13/idlelib/run.py\", line 590, in runcode\n        exec(code, self.locals)\n        ~~~~^^^^^^^^^^^^^^^^^^^\n      File \"&lt;pyshell#9&gt;\", line 1, in &lt;module&gt;\n    ValueError: 'Pedro' is not in list\n</code></pre> <p>Lo que nos obliga a hacer una comprobaci\u00f3n previa:</p> <pre><code>&gt;&gt;&gt; if 'Juan' in amigos:\n...     amigos.index('Juan')\n...\n    1\n</code></pre>"},{"location":"009-02-OpListas.html#obtener-un-elemento-al-azar","title":"Obtener un elemento al azar","text":"<p>La biblioteca random proporciona funciones para trabajar con listas. La funci\u00f3n <code>choice()</code> devuelve un elemento de la lista tomado al azar:</p> Sorteo.py<pre><code># Programa para realizar un sorteo\n\nimport random\nparticipes = [ 'Ana', \n               'Juan', \n               'Andr\u00e9s', \n               'Victor', \n               'Luisa', \n               'Cristina']\n\nagraciado=random.choice(participes)\nprint(agraciado)\n\nagraciado=random.choice(participes)\nprint(agraciado)\n</code></pre> <p>Lo que muestra algo as\u00ed como:</p> <pre><code>Ana\nVictor\n</code></pre> <p>Pero este es un sorteo extra\u00f1o, ya que una persona puede recibir varios premios. Vamos a eliminar de la lista a quienes ya hayan sido agraciados:</p> Sorteo2.py<pre><code>import random\nparticipes = [ 'Ana',\n               'Juan',\n               'Andr\u00e9s',\n               'Victor',\n               'Luisa',\n               'Cristina']\n\npremio = 1\n\nprint(\"Resultado del sorteo:\")\nwhile premio &lt; 4:\n    agraciado=random.choice(participes)\n    participes.remove(agraciado)\n    print(f\"{premio}: {agraciado}\")\n    premio += 1\n</code></pre> <p>Lo que muestra algo as\u00ed como:</p> <pre><code>Resultado del sorteo:\n1: Cristina\n2: Andr\u00e9s\n3: Victor\n</code></pre>"},{"location":"009-02-OpListas.html#borrar-un-elemento-a-partir-de-su-valor","title":"Borrar un elemento a partir de su valor","text":"<p>En el ejemplo, vemos que el m\u00e9todo <code>remove()</code> suprime de la lista el elemento  que le pasemos como argumento. Es una alternativa a la sentencia <code>del</code> que borra elementos a partir de su n\u00famero \u00edndice.</p> <p>Pero \u00a1Ojo! Si no existe ese valor en la lista, obtendremos un error:</p> <pre><code>&gt;&gt;&gt; participes = [ 'Ana', 'Juan', 'Andr\u00e9s', 'Victor', 'Luisa', 'Cristina']\n&gt;&gt;&gt; participes.remove('Sergio')\n\n    Traceback (most recent call last):\n      File \"/usr/lib/python3.13/idlelib/run.py\", line 590, in runcode\n        exec(code, self.locals)\n        ~~~~^^^^^^^^^^^^^^^^^^^\n      File \"&lt;pyshell#51&gt;\", line 1, in &lt;module&gt;\n    ValueError: list.remove(x): x not in list\n</code></pre> <p>... lo que, a veces, nos obligar\u00e1 a hacer una comprobaci\u00f3n:</p> <pre><code>if 'Sergio' in participes:\n    participes.remove('Sergio')\n</code></pre> <p>o bien:</p> <pre><code>try:\n    participes.remove('Sergio')\nexcept:\n    pass\n</code></pre>"},{"location":"009-02-OpListas.html#ordenar-los-elementos-de-una-lista","title":"Ordenar los elementos de una lista","text":"<p>Una vez creadas, los elementos de una lista mantienen el orden en que son  incorporados a la lista:</p> <pre><code>&gt;&gt;&gt; personas = [ 'Ana', 'Juan', 'Andr\u00e9s', 'Victor', 'Luisa', 'Cristina']\n&gt;&gt;&gt; personas\n    ['Ana', 'Juan', 'Andr\u00e9s', 'Victor', 'Luisa', 'Cristina']\n</code></pre> <p>Podemos ordenar los elementos con el m\u00e9todo <code>sort()</code></p> <pre><code>&gt;&gt;&gt; personas.sort()\n&gt;&gt;&gt; personas\n    ['Ana', 'Andr\u00e9s', 'Cristina', 'Juan', 'Luisa', 'Victor']\n</code></pre> <p>El m\u00e9todo <code>sort()</code> no genera una nueva lista, sino que se beneficia del hecho de que las listas son objetos mutables.</p> <p>\u00bfQue hacer si queremos mantener la lista original y generar una nueva ordenada? Usar la funci\u00f3n <code>sorted()</code>:</p> <pre><code>&gt;&gt;&gt; personas = [ 'Ana', 'Juan', 'Andr\u00e9s', 'Victor', 'Luisa', 'Cristina']\n&gt;&gt;&gt; personas2 = sorted(personas)\n\n&gt;&gt;&gt; personas\n    ['Ana', 'Juan', 'Andr\u00e9s', 'Victor', 'Luisa', 'Cristina']\n\n&gt;&gt;&gt; personas2\n    ['Ana', 'Andr\u00e9s', 'Cristina', 'Juan', 'Luisa', 'Victor']\n</code></pre> <p>La funci\u00f3n sorted() no est\u00e1 ligada a un tipo de dato especial. Toma cualquier colecci\u00f3n y genera una lista ordenada.</p>"},{"location":"009-02-OpListas.html#desordenar-una-lista","title":"Desordenar una lista","text":"<p>Supongamos que estamos creando un juego. Tenemos una lista de personas y  queremos ordenarlas al azar:</p> <pre><code>&gt;&gt;&gt; import random\n&gt;&gt;&gt; personas = [ 'Ana', 'Juan', 'Andr\u00e9s', 'Victor', 'Luisa', 'Cristina']\n&gt;&gt;&gt; random.shuffle(personas)\n\n&gt;&gt;&gt; personas\n    ['Victor', 'Juan', 'Ana', 'Luisa', 'Cristina', 'Andr\u00e9s']\n</code></pre>"},{"location":"009-03-Tuplas.html","title":"Tuplas","text":""},{"location":"009-03-Tuplas.html#que-es-una-tupla","title":"\u00bfQue es una tupla?","text":"<p>Imaginemos la siguiente lista:</p> <pre><code>&gt;&gt;&gt; dias = [\n...     \"lunes\",\n...     \"martes\",\n...     \"mi\u00e9rcoles\",\n...     \"jueves\",\n...     \"viernes\",\n...     \"s\u00e1bado\",\n...     \"domingo\"\n...     ]\n\n&gt;&gt;&gt; dias[0]\n    'lunes'\n</code></pre> <p>Toda lista incluye un mecanismo interno complejo, con el prop\u00f3sito de poder realizar operaciones de modificaci\u00f3n de la lista, a\u00f1adir elementos, etc. Pero... \u00bfvamos a cambiar los d\u00edas de la semana? Algunas listas han de ser inmutables por naturaleza.</p> <p>Las tuplas son colecciones de datos m\u00e1s simples y eficientes. Al igual que las  listas, admiten elementos de cualquier tipo, incluso la posibilidad de mezclar tipos. Pero una vez creadas, no es posible modificarlas, a menos que creemos una nueva tupla (como har\u00edamos con las cadenas de texto, que tambi\u00e9n son inmutables).</p> <p>\u00bfComo se crea una tupla? Delimit\u00e1ndola entre par\u00e9ntesis, en lugar de  corchetes:</p> <pre><code>&gt;&gt;&gt; dias = (\n...     \"lunes\",\n...     \"martes\",\n...     \"mi\u00e9rcoles\",\n...     \"jueves\",\n...     \"viernes\",\n...     \"s\u00e1bado\",\n...     \"domingo\"\n...     )\n</code></pre>"},{"location":"009-03-Tuplas.html#operaciones-con-tuplas","title":"Operaciones con tuplas","text":"<p>Una vez creada una tupla, podemos hacer muchas de las operaciones que realizamos  con listas:</p> <ul> <li> <p>podemos obtener un elemento mediante \u00edndices que, al igual que sucede con  las listas, se escriben entre corchetes. Si us\u00e1ramos par\u00e9ntesis, estar\u00edamos  llamando a una funci\u00f3n del mismo nombre (y obtendr\u00edamos un error al no existir  esa funci\u00f3n).</p> <pre><code>&gt;&gt;&gt; dias[0]\n    'lunes'\n</code></pre> </li> <li> <p>podemos obtener una nueva tupla mediante slicing:</p> <pre><code>&gt;&gt;&gt; fin_de_semana = dias[5:]\n&gt;&gt;&gt; fin_de_semana\n    ('s\u00e1bado', 'domingo')\n</code></pre> </li> <li> <p>concatenar dos tuplas para formar una nueva:</p> </li> </ul> <pre><code>&gt;&gt;&gt; dias_laborables = dias[:-2]\n&gt;&gt;&gt; dias_laborables\n    ('lunes', 'martes', 'mi\u00e9rcoles', 'jueves', 'viernes')\n&gt;&gt;&gt; dias_laborables + fin_de_semana\n    ('lunes', 'martes', 'mi\u00e9rcoles', 'jueves', 'viernes', 's\u00e1bado', 'domingo')\n</code></pre>"},{"location":"009-03-Tuplas.html#omitir-parentesis","title":"Omitir par\u00e9ntesis","text":"<p>En situaciones donde no hay ambig\u00fcedades, se puede prescindir de los par\u00e9ntesis:</p> <pre><code>dias = 'lunes', 'martes', 'mi\u00e9rcoles', 'jueves', 'viernes', 's\u00e1bado', 'domingo'\n</code></pre> <p>Pero obtendr\u00edamos un error si escribimos:</p> <pre><code>dias = \"lunes\",\n       \"martes\",\n       \"mi\u00e9rcoles\",\n       \"jueves\",\n       \"viernes\",\n       \"s\u00e1bado\",\n       \"domingo\"\n</code></pre> <p>... porque en la primera l\u00ednea estamos creando un string, y la coma sobra. Las l\u00edneas sucesivas no tienen sentido para el int\u00e9rprete. En este caso, se necesitan los par\u00e9ntesis para delimitar todo el conjunto.</p>"},{"location":"009-03-Tuplas.html#tuplas-formadas-por-un-elemento","title":"Tuplas formadas por un elemento","text":"<p>Lo siguiente pretende ser una tupla de un elemento:</p> <pre><code>saludos = (\"Hola\")\n</code></pre> <p>pero todo lo que conseguimos es una cadena de texto entre par\u00e9ntesis. Los  par\u00e9ntesis se considerar\u00edan como parte de una expresi\u00f3n.</p> <p>Cuando una tupla solo tiene un elemento, este debe ir acompa\u00f1ado de una coma:</p> <pre><code>saludos = (\"Hola\", )\n</code></pre> <p>o bien:</p> <pre><code>saludos = \"Hola\",\n</code></pre>"},{"location":"009-04-For.html","title":"Bucles for","text":""},{"location":"009-04-For.html#sentencia-for","title":"Sentencia for","text":"<p>Imaginemos una colecci\u00f3n cualquiera, una lista, una tupla, o una cadena de caracteres. Podemos recorrerla elemento a elemento mediante:</p> RecorrerLista.py<pre><code>personas = [ 'Ana',\n             'Juan',\n             'Andr\u00e9s',\n             'Victor',\n             'Luisa',\n             'Cristina']\n\ntama\u00f1o = len(personas)\nn = 0\n\nwhile n&lt;tama\u00f1o:\n    print(personas[n])\n    n += 1\n</code></pre> <p>Lo que muestra:</p> <pre><code>Ana\nJuan\nAndr\u00e9s\nVictor\nLuisa\nCristina\n</code></pre> <p>Como alternativa a una sentencia <code>while</code>, tenemos la sentencia <code>for</code>:</p> RecorrerLista2.py<pre><code>personas = [ 'Ana',\n             'Juan',\n             'Andr\u00e9s',\n             'Victor',\n             'Luisa',\n             'Cristina']\n\nfor persona in personas:\n    print(persona)\n</code></pre> <p>La sentencia <code>for</code> recorre una colecci\u00f3n, controlando internamente su tama\u00f1o sin que tengamos que preocuparnos por ello. Para cada elemento, lo copia en  una variable de trabajo (en este caso, <code>persona</code>). </p> <p>N\u00f3tese que en el bloque interno no tenemos acceso a la colecci\u00f3n, sino a la copia del elemento de turno.</p>"},{"location":"009-04-For.html#iteradores-e-iterables","title":"Iteradores e Iterables","text":"<p>Un iterable es un objeto que se puede recorrer con un mecanismo <code>for</code> o similar, para obtener elementos. Las listas, tuplas, o cadenas de texto, son iterables.</p> <p>Un iterador es un mecanismo que genera elementos a medida que se le va  preguntando. Por ejemplo:</p> Range<pre><code>numeros = range(1,10)\nfor n in numeros:\n    print(n)\n</code></pre> <p>Muestra:</p> <pre><code>1\n2\n3\n4\n5\n6\n7\n8\n9\n</code></pre> <p>La funci\u00f3n <code>range(a,b)</code> crea un objeto que, al ser recorrido, genera valores entre a y b-1 (el valor b quedar\u00e1 excluido de la secuencia).</p> <p>Ver la diferencia entre:</p> <pre><code>numeros1 = [1,2,3,4,5,6,7,8,9]\nnumeros2 = range(1,10)\n</code></pre> <p>Aparentemente son similares, pero la primera crea una lista, almacenando los valores en la memoria. La segunda crea una lista virtual. Los valores se van generando uno a uno a medida que se van necesitando, y se suprimen para hacer  espacio al siguiente.</p> <p>Podemos crear listas o tuplas a partir de un iterador mediante:</p> Range2<pre><code>numeros = range(1,10)\nnumeros2 = list(numeros)\nnumeros3 = tuple(numeros)\n\nprint(numeros)\nprint(numeros2)\nprint(numeros3) \n</code></pre> <p>Lo que muestra:</p> <pre><code>range(1, 10)\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n(1, 2, 3, 4, 5, 6, 7, 8, 9)\n</code></pre> <p>En el primer caso, tenemos un iterador, no una colecci\u00f3n de datos. En el segundo, una lista entre corchetes, y en el tercero, una tupla.</p>"},{"location":"009-05-Diccionarios.html","title":"Diccionarios","text":""},{"location":"009-05-Diccionarios.html#que-es-un-diccionario","title":"\u00bfQue es un diccionario?","text":"<p>Supongamos que tenemos una lista con las temperaturas medias de los primeros  meses del a\u00f1o:</p> <pre><code>&gt;&gt;&gt; temperaturas = [12.5, 10.2, 13.4, 16.4, 19.1, 22.7]\n</code></pre> <p>Obtenemos la temperatura de enero con:</p> <pre><code>&gt;&gt;&gt; print(temperaturas[0])\n12.5\n</code></pre> <p>\u00bfPodr\u00edamos usar un texto como \u00edndice?</p> <pre><code>print( temperaturas[\"enero\"] )\n</code></pre> <p>Con una lista no se puede hacer eso. Pero podemos utilizar un diccionario en  su lugar.</p> <p>Los diccionarios son colecciones en las que se accede a cada elemento mediante una clave, en lugar de usar un n\u00famero \u00edndice. Los elementos se almacenan en formato <code>clave:valor</code>:</p> <pre><code>&gt;&gt;&gt; temperaturas = {\"enero\"  : 12.5,\n...                 \"febrero\": 10.2,\n...                 \"marzo\"  : 13.4, \n...                 \"abril\"  : 16.4,\n...                 \"mayo\"   : 19.1,\n...                 \"junio\"  : 22.7,\n...                 }\n\n&gt;&gt;&gt; temperaturas[\"enero\"]\n12.5\n</code></pre> <p>Los diccionarios se escriben de la siguiente manera:</p> <ul> <li>todo el conjunto se delimita entre llaves, en lugar de entre corchetes</li> <li>los elementos se separan por comas, como hacemos en listas y tuplas</li> <li>cada elemento se escribe en formato <code>clave:valor</code></li> </ul>"},{"location":"009-05-Diccionarios.html#un-ejemplo","title":"Un ejemplo","text":"Listin.py<pre><code>telefonos = {\n    \"Ana\"      : 2743,\n    \"Juan\"     : 7145,\n    \"Andr\u00e9s\"   : 2812,\n    \"Victor\"   : 3343,\n    \"Luisa\"    : 1067,\n    \"Cristina\" : 7373\n    }\n\nprint(\"List\u00edn telef\u00f3nico\\n\")\nwhile True:\n    nombre = input(\"Introduzca nombre de persona. En blanco para salir: \")\n    if len(nombre) == 0:\n        print(\"Adios\")\n        break\n    try:\n        telefono = telefonos[nombre]\n        print(f\"{nombre}: {telefono}\\n\")\n    except:\n        print(\"Tel\u00e9fono no encontrado\\n\")\n</code></pre> <p>Al ejecutarse, muestra algo as\u00ed como:</p> <pre><code>List\u00edn telef\u00f3nico\n\nIntroduzca nombre de persona. En blanco para salir: Ana\nAna: 2743\n\nIntroduzca nombre de persona. En blanco para salir: Pedro\nTel\u00e9fono no encontrado\n\nIntroduzca nombre de persona. En blanco para salir: \nAdios\n</code></pre>"},{"location":"009-05-Diccionarios.html#estructuras","title":"Estructuras","text":"<p>Los elementos pueden ser de diferente tipo, lo que permite crear estructuras de  datos complejas:</p> <pre><code>&gt;&gt;&gt; coche = {\n...   \"marca\": \"Renault\",\n...   \"modelo\": \"Clio\",\n...   \"a\u00f1o\": 2020\n...   }\n\n&gt;&gt;&gt; coche\n    {'marca': 'Renault', 'modelo': 'Clio', 'a\u00f1o': 2020}\n\n&gt;&gt;&gt; coche[\"marca\"]\n    'Renault'\n</code></pre>"},{"location":"009-05-Diccionarios.html#orden-de-los-elementos","title":"Orden de los elementos","text":"<p>Las listas y tuplas mantienen sus elementos en el mismo orden en que se  incorporan a la colecci\u00f3n. Hasta la versi\u00f3n 3.6 de Python, los diccionarios  se almacenaban con los elementos desordenados, ya que no es necesario conocer su posici\u00f3n, dado que no accedemos a cada elemento por un n\u00famero \u00edndice. En las versiones actuales de Python, los elementos mantienen su orden.</p>"},{"location":"009-05-Diccionarios.html#tamano-de-un-diccionarios","title":"Tama\u00f1o de un diccionarios","text":"<p>El n\u00famero de elementos se obtiene con la funci\u00f3n <code>len()</code>:</p> <pre><code>&gt;&gt;&gt; print(len(coche))\n3\n</code></pre>"},{"location":"009-05-Diccionarios.html#colecciones-anidadas","title":"Colecciones anidadas","text":"<p>Los elementos de un diccionario pueden ser colecciones de datos. Por ejemplo, una lista</p> <pre><code>&gt;&gt;&gt; coche = {\n...   \"marca\": \"Renault\",\n...   \"modelo\": \"Clio\",\n...   \"a\u00f1o\": 2014,\n...   \"colores\": [\"rojo\", \"blanco\", \"azul\"]\n...   }\n\n&gt;&gt;&gt; coche[\"colores\"][0]\n    'rojo'\n</code></pre>"},{"location":"009-05-Diccionarios.html#acceso-a-elementos","title":"Acceso a elementos","text":"<p>En principio, se accede a un elemento poniendo la clave entre corchetes:</p> <pre><code>&gt;&gt;&gt; persona = dict(nombre = \"Juan\", edad = 36, pais = \"Mexico\")\n&gt;&gt;&gt; persona[\"nombre\"]\n'Juan'\n</code></pre> <p>... aunque el m\u00e9todo get() hace lo mismo:</p> <pre><code>x = persona.get(\"nombre\")\n</code></pre>"},{"location":"009-05-Diccionarios.html#anadir-elementos","title":"A\u00f1adir elementos","text":"<p>A\u00f1adir un elemento es tan f\u00e1cil como hacer una asignaci\u00f3n. Si la clave no  existe, se a\u00f1ade. Si ya existe, se le asigna el nuevo valor</p> <pre><code>&gt;&gt;&gt; telefonos = {\n...     \"Ana\"      : 2743,\n...     \"Juan\"     : 7145,\n...     \"Andr\u00e9s\"   : 2812\n...     }\n\n&gt;&gt;&gt; telefonos\n    {'Ana': 2743, 'Juan': 7145, 'Andr\u00e9s': 2812}\n\n&gt;&gt;&gt; telefonos[\"Victor\"] = 3343\n&gt;&gt;&gt; telefonos\n    {'Ana': 2743, 'Juan': 7145, 'Andr\u00e9s': 2812, 'Victor': 3343}\n</code></pre>"},{"location":"009-06-OpDiccionarios.html","title":"Operaciones con diccionarios","text":""},{"location":"009-06-OpDiccionarios.html#borrar-elementos","title":"Borrar elementos","text":"<p>El m\u00e9todo <code>pop()</code> elimina un elemento pas\u00e1ndole la clave</p> <pre><code>&gt;&gt;&gt; telefonos = {\n...     \"Ana\"      : 2743,\n...     \"Juan\"     : 7145,\n...     \"Andr\u00e9s\"   : 2812,\n...     \"Victor\"   : 3343,\n...     \"Luisa\"    : 1067,\n...     \"Cristina\" : 7373\n...     }\n\n&gt;&gt;&gt; telefonos.pop(\"Ana\")\n     2743\n\n&gt;&gt;&gt; telefonos\n    {'Juan': 7145, 'Andr\u00e9s': 2812, 'Victor': 3343, 'Luisa': 1067, 'Cristina': 7373}\n</code></pre> <p>V\u00e9ase que el m\u00e9todo <code>pop()</code> devuelve el valor del elemento suprimido del  diccionario, que podemos almacenar en otra variable:</p> <pre><code>suprimido = telefonos.pop(\"Ana\")\n</code></pre> <p>Si la clave no existe, obtendremos un error, lo que nos obliga a escribir:</p> <pre><code>try:\n    suprimido = telefonos.pop(\"Ana\")\nexcept:\n    suprimido = 0\n</code></pre> <p>y examinando la variable, veremos si hay un tel\u00e9fono suprimido.</p> <p>El m\u00e9todo <code>popitem()</code> elimina el \u00faltimo elemento a\u00f1adido (en versiones antiguas  de Python eliminaba un elemento al azar, ya que no estaban ordenados):</p> <pre><code>telefonos.popitem()\n</code></pre> <p>La palabra <code>del</code> tambi\u00e9n elimina un elemento:</p> <pre><code>del telefonos[\"Ana\"]\n</code></pre> <p>...o el diccionario completo:</p> <pre><code>del telefonos\n</code></pre> <p>El m\u00e9todo <code>clear()</code> suprime todos los elementos y vac\u00eda el diccionario:</p> <pre><code>telefonos.clear()\n</code></pre>"},{"location":"009-06-OpDiccionarios.html#unir-diccionarios","title":"Unir diccionarios","text":"<p>El m\u00e9todo <code>update()</code> permite a\u00f1adir elementos de otro diccionario. Los  a\u00f1adidos se usan de dos maneras:</p> <ul> <li>si el elemento ya existe, se sustituye por el nuevo</li> <li>si no existe, se incorpora el nuevo</li> </ul> <p>Por ejemplo:</p> <pre><code>&gt;&gt;&gt; telefonos = {\n...     \"Ana\"      : 2743,\n...     \"Juan\"     : 7145,\n...     \"Andr\u00e9s\"   : 2812\n...     }\n\n&gt;&gt;&gt; nuevos_telefonos = {\n...     \"Ana\"      : 4545,\n...     \"Luisa\"    : 1067,\n...     \"Cristina\" : 7373\n...     }\n\n&gt;&gt;&gt; telefonos.update(nuevos_telefonos)\n\n&gt;&gt;&gt; telefonos\n&gt;&gt;&gt; {'Ana': 4545, 'Juan': 7145, 'Andr\u00e9s': 2812, 'Luisa': 1067, 'Cristina': 7373}\n</code></pre>"},{"location":"009-06-OpDiccionarios.html#obtener-una-lista-de-claves","title":"Obtener una lista de claves","text":"<p>Podemos obtener una colecci\u00f3n de claves con el m\u00e9todo <code>keys()</code></p> <pre><code>&gt;&gt;&gt; persona = {'nombre': 'Teresa', \n...            'edad': 27, \n...            'ciudad': 'Buenos Aires', \n...            'veh\u00edculo': 'Ford'}\n\n&gt;&gt;&gt; claves = persona.keys()\n</code></pre> <p>La lista as\u00ed obtenida es un objeto de la clase <code>dict_keys</code>:</p> <pre><code>&gt;&gt;&gt; type(claves)\n&lt;class 'dict_keys'&gt;\n</code></pre> <p>\u00bfQue tiene de particular? Almacena una referencia al diccionario, pero no se  trata de crear una nueva lista. es decir, si modificamos el diccionario,  cambia la lista de claves, sin necesidad de crearla de nuevo:</p> <pre><code>&gt;&gt;&gt; claves\n    dict_keys(['nombre', 'edad', 'ciudad', 'veh\u00edculo'])\n\n&gt;&gt;&gt; persona.pop(\"veh\u00edculo\")\n    'Ford'\n\n&gt;&gt;&gt; claves\n    dict_keys(['nombre', 'edad', 'ciudad'])\n</code></pre>"},{"location":"009-06-OpDiccionarios.html#obtener-una-lista-de-valores","title":"Obtener una lista de valores","text":"<p>El m\u00e9todo values() devuelve una lista de valores:</p> <pre><code>&gt;&gt;&gt; persona = {'nombre': 'Teresa', \n...            'edad': 27, \n...            'ciudad': 'Buenos Aires', \n...            'veh\u00edculo': 'Ford'}\n\n&gt;&gt;&gt; persona.values()\ndict_values(['Teresa', 27, 'Buenos Aires', 'Ford'])\n</code></pre> <p>Como sucede con las claves, en lugar de obtener una lista ordinaria,  se consigue un objeto de la clase <code>dict_values</code> ligado al diccionario original.  Un cambio en este modifica la lista as\u00ed obtenida.</p>"},{"location":"009-06-OpDiccionarios.html#obtener-una-lista-de-parejas","title":"Obtener una lista de parejas","text":"<p>El m\u00e9todo items() devuelve una lista de tuplas:</p> <pre><code>&gt;&gt;&gt; persona.items()\ndict_items([('nombre', 'Teresa'), ('edad', 27), ('ciudad', 'Buenos Aires'), ('veh\u00edculo', 'Ford')])\n&gt;&gt;&gt; \n</code></pre> <p>Como sucede con los anteriores, la lista obtenida reflejar\u00e1 los cambios en el  diccionario original. Si lo que queremos es obtener una lista independiente,  generala con una llamada a la funci\u00f3n <code>list()</code>:</p> <pre><code>&gt;&gt;&gt; persona = {'nombre': 'Teresa', 'edad': 27, 'ciudad': 'Buenos Aires', 'veh\u00edculo': 'Ford'}\n&gt;&gt;&gt; elementos=persona.items()\n&gt;&gt;&gt; for x in elementos:\n...     print(x)\n... \n('nombre', 'Teresa')\n('edad', 27)\n('ciudad', 'Buenos Aires')\n('veh\u00edculo', 'Ford')\n\n&gt;&gt;&gt; type(elementos)\n&lt;class 'dict_items'&gt;\n\n&gt;&gt;&gt; lista=list(elementos)\n&gt;&gt;&gt; type(lista)\n&lt;class 'list'&gt;\n</code></pre>"},{"location":"009-06-OpDiccionarios.html#pertenencia","title":"Pertenencia","text":"<p>Podemos comprobar si una clave est\u00e1 presente, escribimos:</p> <pre><code>&gt;&gt;&gt; \"veh\u00edculo\" in persona\nTrue\n&gt;&gt;&gt; \"profesi\u00f3n\" in persona\nFalse\n&gt;&gt;&gt; \"profesi\u00f3n\" not in persona\nTrue\n</code></pre>"},{"location":"009-06-OpDiccionarios.html#recorrer-diccionarios","title":"Recorrer diccionarios","text":"<p>Podr\u00eda pensarse que la sentencia <code>for</code> recorre el diccionario y devuelve parejas, pero en realidad lo que devuelve son las claves:</p> <pre><code>&gt;&gt;&gt; for clave in persona:\n...     print(clave)\n\n    nombre\n    edad\n    ciudad\n    veh\u00edculo\n</code></pre> <p>Si lo que queremos son los valores, escribimos:</p> <pre><code>&gt;&gt;&gt; for clave in persona:\n...     print(persona[clave])\n... \n\n    Teresa\n    27\n    Buenos Aires\n    Ford\n</code></pre> <p>Tambi\u00e9n podemos obtener una lista de valores mediante el m\u00e9todo <code>values()</code></p> <pre><code>&gt;&gt;&gt; for valor in persona.values():\n...     print(valor)\n</code></pre> <p>O para obtener una lista de claves:</p> <pre><code>&gt;&gt;&gt; for clave in persona.keys():\n...     print(clave)\n</code></pre> <p>O una lista de parejas con:</p> <pre><code>&gt;&gt;&gt; for clave, valor in persona.items():\n...     print(clave, valor)\n</code></pre>"},{"location":"009-06-OpDiccionarios.html#metodo-fromkeys","title":"M\u00e9todo fromkeys()","text":"<p>El m\u00e9todo <code>dict.fromkeys(iterable, valor)</code> crea un diccionario a partir de  una lista de claves, asignando el mismo valor a todas las parejas:</p> <pre><code>claves = ['clave1', 'clave2', 'clave3']\nvalor = 0\n\nmidiccionario = dict.fromkeys(claves, valor)\n</code></pre>"},{"location":"009-06-OpDiccionarios.html#anidar-diccionarios","title":"Anidar diccionarios","text":"<p>Los valores de un diccionario pueden ser diccionarios a su vez:</p> <pre><code>familia = {\n  \"hijo1\"    : {\n    \"nombre\" : \"Juan\",\n    \"a\u00f1o\"    : 1987\n  },\n  \"hijo2\"    : {\n    \"nombre\" : \"Antonio\",\n    \"a\u00f1o\"    : 1990\n  },\n  \"hijo3 \"   : {\n    \"nombre\" : \"Ana\",\n    \"a\u00f1o\"    : 1995\n  }\n}\n</code></pre> <p>Podemos crear los diccionarios por separado y luego ponerlos en el  diccionario principal:</p> <pre><code>hijo1      = {\n  \"nombre\" : \"Juan\",\n  \"a\u00f1o\"    : 1987\n}\n\nhijo2      = {\n  \"nombre\" : \"Antonio\",\n  \"a\u00f1o\"    : 1990\n}\n\nhijo3      = {\n  \"nombre\" : \"Ana\",\n  \"a\u00f1o\"    : 1995\n}\n\nfamilia = {\n  \"hijo1\" : hijo1,\n  \"hijo2\" : hijo2,\n  \"hijo3\" : hijo3\n}\n</code></pre> <p>El acceso ser\u00e1 mediante doble clave:</p> <pre><code>print(familia[\"hijo2\"][\"nombre\"])\n</code></pre> <p>Para recorrer un diccionario anidado, lo hacemos usando un bucle <code>for</code> para cada nivel de anidamiento</p> <pre><code>for hijo, dic in familia.items():\n  for clave, valor in dic.items():\n     print(hijo, clave, valor)\n  print()\n</code></pre>"},{"location":"009-06-OpDiccionarios.html#copiar-diccionarios","title":"Copiar diccionarios","text":"<p>Supongamos que queremos crear un diccionario copiando el contenido de otro</p> <pre><code>diccionario2 = diccionario1\n</code></pre> <p>En realidad, lo que conseguimos son dos diccionarios ligados al mismo paquete de datos. Si modificamos los datos de uno de los diccionarios, se modificar\u00e1 el otro.</p> <p>Para crear un nuevo paquete de datos tenemos que usar el m\u00e9todo <code>copy()</code>:</p> <pre><code>dict2 = dict1.copy()\n</code></pre> <p>y ahora los paquetes de datos son independientes el uno del otro.</p>"},{"location":"010-01-Funciones.html","title":"Funciones de usuario","text":""},{"location":"010-01-Funciones.html#funciones","title":"Funciones","text":"<p>En un programa hay cuatro tipos de funciones:</p> <ul> <li> <p>las funciones built-in proporcionadas por el propio lenguaje Python:</p> <pre><code>print(\"Hola\")\n</code></pre> </li> <li> <p>las funciones de la biblioteca est\u00e1ndar. Por ejemplo, para averiguar cual es     nuestro sistema operativo, escribimos:</p> <pre><code>&gt;&gt;&gt; import platform\n&gt;&gt;&gt; platform.system()\n    Linux\n</code></pre> </li> <li> <p>funciones de bibliotecas de terceros que instalemos en nuestra computadora.      Por ejemplo, la biblioteca pygame permite     crear juegos 3D</p> </li> <li> <p>funciones creadas por nosotros.</p> </li> </ul>"},{"location":"010-01-Funciones.html#como-crear-una-funcion","title":"Como crear una funci\u00f3n","text":"<p>Supongamos que escribimos el siguiente programa:</p> <pre><code>saludar(\"Ana\")\nsaludar(\"Juan\")\nsaludar(\"Luis\")\n</code></pre> <p>Lo que muestra</p> <pre><code>Hola, Ana\nHola, Juan\nHola, Luis\n</code></pre> <p>La funci\u00f3n saludar debe recibir un texto como argumento y mostrar un saludo. La definimos de la siguiente forma:</p> Saludar.py<pre><code>def saludar(nombre):\n    texto = \"Hola, \"+nombre\n    print(texto)\n\nsaludar(\"Ana\")\nsaludar(\"Juan\")\nsaludar(\"Luis\")\n</code></pre> <p>La definici\u00f3n de una funci\u00f3n tiene dos partes:</p> <ul> <li> <p>una l\u00ednea de cabecera, que comienza con la palabra <code>def</code>, seguida     del nombre de la funci\u00f3n y, entre par\u00e9ntesis, una lista de variables      receptoras de argumentos. Esta l\u00ednea finaliza con dos puntos <code>:</code></p> </li> <li> <p>un cuerpo de sentencias a ejecutar cada vez que se invoca la funci\u00f3n.      El bloque ha de estar sangrado.</p> </li> </ul> <p>Las funciones deben definirse antes de ser invocadas. En el ejemplo, primero creamos la funci\u00f3n <code>saludar()</code> y posteriormente la llamamos tres veces.</p>"},{"location":"010-01-Funciones.html#parametros","title":"Par\u00e1metros","text":"<p>Toda funci\u00f3n puede recibir argumentos, que almacenar\u00e1 en las variables que definamos entre par\u00e9ntesis. En el ejemplo anterior, definimos una variable  llamada \"nombre\". Nos limitamos a establecer el nombre de la variable, sin asignarle un valor, ya que la variable est\u00e1 concebida para almacenar  el valor recibido.</p> <p>A las variables destinadas a almacenar los argumentos recibidos por una funci\u00f3n, se las llama par\u00e1metros. Una funci\u00f3n puede definirse con varios par\u00e1metros:</p> Saludar2.py<pre><code>def saludar(nombre, apellido):\n    texto = \"Hola, \"+nombre+\" \"+apellido\n    print(texto)\n\nsaludar(\"Ana\", \"L\u00f3pez\")\nsaludar(\"Juan\", \"Garc\u00eda\")\nsaludar(\"Iker\", \"P\u00e9rez\")\n</code></pre> <p>Si no se prev\u00e9 recibir argumentos, se escriben par\u00e9ntesis vac\u00edos</p> <pre><code>def saludar():\n    print(\"Hola\")\n</code></pre>"},{"location":"010-01-Funciones.html#funciones-que-devuelven-un-resultado","title":"Funciones que devuelven un resultado:","text":"<p>Una funci\u00f3n puede devolver un resultado</p> Perimetro.py<pre><code>def perimetro(r)\n    pi = 3.14159\n    p = r * pi * 2\n    return p\n\nradio = 5\nprint(perimetro(radio))\n</code></pre> <p>La sentencia <code>return</code> establece el valor a devolver. Si no va acompa\u00f1ada de nada, se limita a finalizar la ejecuci\u00f3n de la funci\u00f3n:</p> <pre><code>def saludar():\n    print(\"Hola\")\n    return\n</code></pre> <p>De todas formas, toda funci\u00f3n concluye su ejecuci\u00f3n al llegar a la \u00faltima  sentencia, por lo que en este caso, no ser\u00eda necesaria la sentencia <code>return</code>.  Pero puede ser \u00fatil para finalizar anticipadamente:</p> NumerosPrimos.py<pre><code>def es_primo(numero):\n    for divisor in range(2,numero):\n        if (numero%divisor) == 0:     # divisible por otro numero\n            return False\n    return True\n\nlimite = 100\nprimos = []\n\nfor n in range(2,100):\n    if es_primo(n):\n        primos.append(n)\n\nprint(primos)\n</code></pre> <p>esto muestra una lista con los n\u00fameros primos menores de 100:</p> <pre><code>[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, \n61, 67, 71, 73, 79, 83, 89, 97]\n</code></pre>"},{"location":"010-01-Funciones.html#argumentos-por-nombre","title":"Argumentos por nombre","text":"<p>Las funciones se pueden invocar pasando el nombre del par\u00e1metro en el caso de alg\u00fan argumento (o de todos):</p> Saludar2.py<pre><code>def saludar(nombre, apellido):\n    texto = \"Hola, \"+nombre+\" \"+apellido\n    print(texto)\n\nsaludar(\"Ana\", apellido=\"L\u00f3pez\")\nsaludar(\"Juan\", \"Garc\u00eda\")\nsaludar(\"Iker\", \"P\u00e9rez\")\n</code></pre> <p>Esto permite escribir los argumentos en un orden diferente del previsto:</p> <pre><code>saludar(apellido=\"L\u00f3pez\", nombre=\"Ana\")\n</code></pre> <p>Por lo tanto, una funci\u00f3n puede invocarse de tres formas:</p> <ul> <li>indicando el nombre de todos los par\u00e1metros</li> <li>con todos los argumentos sin nombre. Se asignan seg\u00fan su posici\u00f3n.</li> <li>con algunos argumentos posicionales y otros por nombre</li> </ul> <p>En el tercer caso, los argumentos posicionales han de ir en primer lugar, y corresponderse con los primeros par\u00e1metros.</p>"},{"location":"010-01-Funciones.html#parametros-opcionales","title":"Par\u00e1metros opcionales","text":"<p>Los argumentos pueden omitirse, si en la definici\u00f3n de la funci\u00f3n establecemos un valor por defecto:</p> Saludar3.py<pre><code>def saludar(nombre, saludo=\"Hola\"):\n    texto = saludo+\", \"+nombre\n    print(texto)\n\nsaludar(\"Ana\", saludo=\"Buenos d\u00edas\")\nsaludar(\"Juan\")\nsaludar(\"Iker\")\n</code></pre> <p>Lo que muestra:</p> <pre><code>Buenos d\u00edas, Ana\nHola, Juan\nHola, Iker\n</code></pre> <p>Los par\u00e1metros obligatorios deben definirse antes que los opcionales.</p>"},{"location":"010-02-Ambito.html","title":"Ambito de las variables","text":""},{"location":"010-02-Ambito.html#variables-locales","title":"Variables locales","text":"<p>Una variable definida dentro de una funci\u00f3n, se considera de \u00e1mbito local, se crea cada vez que se ejecuta la funci\u00f3n, y se destruye al finalizar esta:</p> Perimetro.py<pre><code>def perimetro(r):\n    pi = 3.14159\n    p = r * pi * 2\n    return p\n\nradio = 5\nprint(perimetro(radio))\n</code></pre> <p>En este ejemplo, las variables <code>pi</code> y <code>p</code> son locales, y no ser\u00e1n reconocidas fuera del bloque de sentencias de la funci\u00f3n. Por ejemplo:</p> Perimetro2.py<pre><code>def calc_perimetro(r):\n    pi = 3.14159\n    p = r * pi * 2\n    return p\n\ndef mostrar_perimetro(rd):\n    perim = calc_perimetro(rd)\n    print(perim)\n\nradio = 5\nmostrar_perimetro(radio)\n</code></pre> <p>En este caso:</p> <ul> <li> <p>Desde el bloque principal llamamos a la funci\u00f3n <code>mostrar_perimetro()</code> y  desde esta, a su vez, a la funci\u00f3n <code>calc_perimetro()</code>.</p> </li> <li> <p>Cuando llamamos a <code>mostrar_perimetro()</code>, se crea la variable local <code>perim</code>, que se destruye autom\u00e1ticamente al finalizar la ejecuci\u00f3n de  <code>mostrar_perimetro()</code>. Durante este tiempo, la variable <code>perim</code> existe y ocupa temporalmente un espacio en la memoria RAM, pero no es visible para la funci\u00f3n <code>calc_perimetro()</code>, ya que su \u00e1mbito se limita a la funci\u00f3n donde se define.</p> </li> </ul>"},{"location":"010-02-Ambito.html#parametros","title":"Par\u00e1metros","text":"<p>Los par\u00e1metros de una funci\u00f3n act\u00faan como variables locales. En el ejemplo,  la variable <code>rd</code> es de \u00e1mbito local y accesible solo para la funci\u00f3n  <code>mostrar_perimetro</code>, </p>"},{"location":"010-02-Ambito.html#variables-globales","title":"Variables globales","text":"<p>Las variables definidas fuera de toda funci\u00f3n se consideran de \u00e1mbito global, y son accesibles desde cualquier punto del programa. Por ejemplo:</p> Perimetro.py<pre><code>def perimetro(r):\n    pi = 3.14159\n    p = r * pi * 2\n    return p\n\nradio = 5\nprint(perimetro(radio))\n</code></pre> <p>La variable <code>radio</code> es global, y por lo tanto, no es necesario pasarla como argumento. El programa podr\u00eda quedar as\u00ed:</p> Perimetro3.py<pre><code>def perimetro():\n    pi = 3.14159\n    p = radio * pi * 2\n    return p\n\nradio = 5\nprint(perimetro())\n</code></pre>"},{"location":"010-02-Ambito.html#tapando-variables","title":"Tapando variables","text":"<p>En los ejemplos, hemos hecho que la variable pasada a una funci\u00f3n y el par\u00e1metro receptor tengan diferentes nombres:</p> <pre><code>def perimetro(r):\n    ...\n\nperimetro(radio)\n</code></pre> <p>Pero... \u00bfque pasa si tienen igual nombre? Cada funci\u00f3n tiene su propio espacio de nombres, y dos variables pueden llamarse igual si pertenecen a diferentes  funciones. Por otra parte, si una variable local se llama como una global,  las menciones a la variable dentro de la funci\u00f3n se referir\u00e1n a la local, que \"tapar\u00e1\" a la global:</p> Ambito.py<pre><code>def test1():\n    print(\"Accediendo a x global en test1:\", x)\n\ndef test2():    \n    x = 1\n    print(\"Accediendo a x local en test2:\", x)\n\nx = 0\nprint(\"Valor inicial x global:\", x)\ntest1()\ntest2()\nprint(\"Valor final x global:\", x)\n</code></pre> <p>Muestra:</p> <pre><code>Valor inicial x global: 0\nAccediendo a x global en test1: 0\nAccediendo a x local en test2: 1\nValor final x global: 0\n</code></pre> <p>En la funci\u00f3n <code>test2()</code> hemos creado una variable local, asign\u00e1ndole el valor 1. Esta variable tapa a la global temporalmente. Al finalizar la funci\u00f3n, el acceso a la variable global se recupera, y su valor sigue siendo el original.</p>"},{"location":"010-02-Ambito.html#modificar-variables-globales","title":"Modificar variables globales","text":"<p>Una variable global puede ser accedida y modificada por cualquier funci\u00f3n. Pero hay dos inconvenientes:</p> <ul> <li> <p>En un programa complejo, con muchas funciones, es dificil controlar  cual de ellas est\u00e1 modificando una variable global. El programa puede volverse bastante ingobernable. Conviene limitar el uso de variables globales.</p> </li> <li> <p>Si en una funci\u00f3n intentamos modificar una variable global, en realidad  estaremos creando una nueva variable local:</p> <pre><code>def test():    \n    x = 1\n\nx = 0\ntest()\nprint(x)\n</code></pre> </li> </ul> <p>En este ejemplo, al finalizar la funci\u00f3n <code>test()</code>, la variable global no ha sido modificada y el programa mostrar\u00e1 un valor 0.  Hemos creado una variable local con valor 1, que ha existido brevemente y se ha destruido al finalizar la funci\u00f3n.</p> <p>Este problema se puede solucionar declarando, al inicio de la funci\u00f3n, las variables que han de ser consideradas como globales:</p> Ambito2.py<pre><code>def test():\n    global x\n    x = 1\n\nx = 0\ntest()\nprint(x)\n</code></pre> <p>Y ahora, el programa mostrar\u00e1 la variable x con valor 1.</p>"},{"location":"010-03-Modulos.html","title":"M\u00f3dulos que definen funciones","text":"<p>Supongamos el siguiente programa:</p> Circulo.py<pre><code>pi = 3.14159\n\ndef perimetro(r):\n    perim = r * pi * 2\n    return perim\n\ndef area(r):    \n    area = pi * (r**2)\n    return area\n\nradio = 5\nprint(perimetro(radio))\nprint(area(radio))\n</code></pre> <p>Aqu\u00ed tenemos tres identificadores que podr\u00edamos en un fichero aparte,  de forma que sean reutilizables en varios proyectos:</p> <ul> <li>valor de PI</li> <li>funci\u00f3n <code>perimetro()</code></li> <li>funci\u00f3n <code>area()</code></li> </ul>"},{"location":"010-03-Modulos.html#crear-un-modulo-con-definiciones","title":"Crear un m\u00f3dulo con definiciones","text":"<p>Colocamos esas definiciones en un archivo MisFunciones.py:</p> MisFunciones.py<pre><code>pi = 3.14159\n\ndef perimetro(r):\n    perim = r * pi * 2\n    return perim\n\ndef area(r):    \n    area = pi * (r**2)\n    return area\n</code></pre> <p>De forma que el programa principal queda as\u00ed:</p> Circulo.py<pre><code>import misfunciones\nradio = 5\nprint(misfunciones.perimetro(radio))\nprint(misfunciones.area(radio))\n</code></pre> <p>Vemos que:</p> <ul> <li>Los m\u00f3dulos a utilizar en nuestro programa han de importarse.</li> <li>Las funciones de m\u00f3dulos importados van precedidas por el nombre del m\u00f3dulo.</li> </ul> <p>Podr\u00edamos importar directamente las funciones:</p> Circulo.py<pre><code>from misfunciones import perimetro, area\nradio = 5\nprint(perimetro(radio))\nprint(area(radio))\n</code></pre>"},{"location":"010-03-Modulos.html#ruta-de-importacion","title":"Ruta de importaci\u00f3n","text":"<p>Python busca los m\u00f3dulos importados:</p> <ul> <li>en la misma carpeta que el programa principal</li> <li>en las carpetas definidas por el sistema</li> </ul> <p>\u00bfCuales son las carpetas donde se ubican los m\u00f3dulos de Python?  Lo podemos averiguar importando el m\u00f3dulo <code>sys</code> y examinando la lista <code>sys.path</code>:</p> <pre><code>&gt;&gt;&gt; import sys\n&gt;&gt;&gt; for carpeta in sys.path:\n...     print(carpeta)\n\n    /home/usuario/proyectos/circulo\n    /home/usuario\n    /usr/bin\n    /usr/lib/python3.13\n    /usr/lib/python3.13/lib-dynload\n    /usr/local/lib/python3.13/dist-packages\n    /usr/lib/python3/dist-packages\n</code></pre> <p>Cada sistema operativo es un mundo y tiene sus propias rutas. En este ejemplo  vemos que primero se busca en la misma carpeta que el programa principal.</p>"},{"location":"010-03-Modulos.html#el-directorio-__pycache__","title":"El directorio <code>__pycache__</code>","text":"<p>Cuando el int\u00e9rprete de Python ejecuta un programa, toma el texto de las instrucciones y hace una traducci\u00f3n \"al vuelo\", obteniendo el mismo programa en formato de ceros y unos, algo que es conocido como \"lenguaje m\u00e1quina\", y que  el ordenador es capaz de entender y ejecutar.</p> <p>En el caso de importar un m\u00f3dulo, este tambi\u00e9n se traduce. Pero para evitar tener que estar haciendo esta compilaci\u00f3n cada vez que ejecutamos el programa, autom\u00e1ticamente se guarda el m\u00f3dulo en formato binario en un archivo especial  con extensi\u00f3n <code>.pyc</code> (python compilado) en una carpeta llamada <code>__pycache__</code>,  dentro de la misma carpeta que el m\u00f3dulo.</p> <p>Los archivos dentro de la carpeta <code>__pycache__</code> se reconstruir\u00e1n si el int\u00e9rprete de Python detecta que el m\u00f3dulo ha sido modificado.</p> <p>Los archivos <code>.pyc</code> tienen el mismo nombre que el m\u00f3dulo en cuesti\u00f3n, a lo que se a\u00f1ade la palabra <code>cpython</code> seguido por la versi\u00f3n de Python que estamos utilizando.</p>"},{"location":"011-01-Fechas.html","title":"Trabajar con fechas","text":"<p>Hasta ahora hemos trabajado con diferentes tipos de datos:</p> <ul> <li>N\u00fameros enteros, sin decimales, que son objetos de la clase <code>int</code></li> <li>N\u00fameros con decimales, que son objetos de la clase <code>float</code></li> <li>Cadenas de texto, que son objetos de la clase <code>str</code></li> <li>Valores booleanos, True y False, que son objetos de la clase <code>bool</code></li> <li>Listas que son objetos de la clase <code>list</code></li> <li>Tuplas que son objetos de la clase <code>tuple</code></li> <li>Diccionarios que son objetos de la clase <code>dict</code></li> </ul> <p>Todos estos tipos son <code>built-in</code>, es decir, definidos por el lenguaje. Pero  la biblioteca de Python incluye m\u00f3dulos que definen otro tipos de datos. Uno de ellos es el m\u00f3dulo <code>datetime</code>, que proporciona mecanismos para trabajar con fechas, horas, minutos y segundos.</p>"},{"location":"011-01-Fechas.html#objetos-datetime","title":"Objetos datetime","text":"<p>El tipo de dato datetime almacena momentos. Un momento es, por ejemplo:</p> <pre><code>d\u00eda 12 de junio de 2025 a las 12:34\n</code></pre> <p>O bien, si solo queremos la fecha:</p> <pre><code>d\u00eda 12 de junio de 2025 a las 00:00\n</code></pre> <p>Una fecha se  crea as\u00ed:</p> Fecha.py<pre><code>from datetime import datetime\nhoy = datetime(2025, 6, 12)\nprint(hoy)\nprint(type(hoy))\n</code></pre> <p>Lo que muestra:</p> <pre><code>2025-06-12 00:00:00\n&lt;class 'datetime.datetime'&gt;\n</code></pre> <p>Vemos que el m\u00f3dulo <code>datetime</code> define un tipo de igual nombre, <code>datetime</code>. Por ese motivo, importamos el tipo, no el m\u00f3dulo:</p> <pre><code>from datetime import datetime\n</code></pre> <p>Podemos crear un objeto de cualquier tipo (incluidos los tipos built in)  invocando una funci\u00f3n constructora del mismo nombre que el tipo:</p> <pre><code>x = float(0)\ntexto = str(0)\nhoy = datetime(2025, 6, 12)\n</code></pre> <p>La funci\u00f3n datetime() permite especificar horas, minutos y segundos, que son par\u00e1metros opcionales (el valor por defecto es cero)</p> <pre><code>from datetime import datetime\nhoy = datetime(2025, 6, 12, 11, 35, 0)\nprint(hoy)\n</code></pre> <p>Lo que muestra:</p> <pre><code>2025-06-12 11:35:00\n</code></pre>"},{"location":"011-01-Fechas.html#obtener-el-momento-actual","title":"Obtener el momento actual","text":"<p>El m\u00e9todon <code>now()</code> asociado al tipo <code>datetime</code> devuelve la fecha y hora actual:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; ahora=datetime.now()\n&gt;&gt;&gt; print(ahora)\n    2024-06-10 12:12:17.348933\n</code></pre>"},{"location":"011-01-Fechas.html#lapso-entre-dos-fechas","title":"Lapso entre dos fechas","text":"<p>El lapso de tiempo entre dos momentos es un objeto del tipo timedelta</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; fecha = datetime(2004,3,27)\n&gt;&gt;&gt; print(fecha)\n    2004-03-27 00:00:00\n\n&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; dias=timedelta(days=10)\n&gt;&gt;&gt; fecha2 = fecha+dias\n&gt;&gt;&gt; fecha2\n    2004-04-06 00:00:00\n\n&gt;&gt;&gt; semanas=timedelta(weeks=20)\n&gt;&gt;&gt; fecha3 = fecha+semanas\n    2004-08-14 00:00:00\n</code></pre> <p>Los lapsos se pueden sumar o restar a una fecha para obtener otra fecha. Se crean mediante:</p> <pre><code>dias=timedelta(days=10)\nsemanas=timedelta(weeks=20)\n</code></pre> <p>Podemos pasar las siguientes unidades: </p> <ul> <li>weeks</li> <li>days</li> <li>hours</li> <li>minutes</li> <li>seconds</li> <li>milliseconds</li> <li>microseconds</li> </ul> <p>Podemos combinar unidades de tiempo para obtener un lapso:</p> <pre><code>intervalo = datetime.timedelta(\n    days=1,\n    hours=10,\n    minutes=22)\n</code></pre> <p>Podemos calcular el intervalo entre dos fechas:</p> <pre><code>&gt;&gt;&gt; ahora=datetime.now()\n&gt;&gt;&gt; ahora\n&gt;&gt;&gt; print(ahora)\n    2024-06-10 12:12:17.348933\n\n&gt;&gt;&gt; fecha = datetime(2024,3,27)\n&gt;&gt;&gt; ahora-fecha\n    datetime.timedelta(days=75, seconds=43937, microseconds=348933)\n</code></pre>"},{"location":"011-01-Fechas.html#extraer-componentes","title":"Extraer componentes","text":"<p>La clase datetime tiene m\u00e9todos para extraer los componentes de una fecha:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; ahora = datetime.now()\n&gt;&gt;&gt; print(\n... ahora.year,\n... ahora.month,\n... ahora.day,\n... ahora.hour,\n... ahora.minute,\n... ahora.second,\n... )\n\n    2025 7 12 11 51 4\n</code></pre> <p>La clase timedelta tambi\u00e9n permite extraer sus componentes:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; ahora = datetime.now()\n&gt;&gt;&gt; fecha = datetime(2025, 6, 12)\n&gt;&gt;&gt; lapso = ahora-fecha\n\n&gt;&gt;&gt; lapso.seconds\n    43545\n\n&gt;&gt;&gt; lapso.days\n     30\n\n&gt;&gt;&gt; horas=lapso.seconds/3600\n&gt;&gt;&gt; horas\n    12.095833333333333\n</code></pre>"},{"location":"012-01-Binario.html","title":"Un mundo binario","text":"<p>Toda la informaci\u00f3n que maneja un ordenador se almacena en la memoria RAM en forma de ceros y unos.</p> <p>Los ordenadores son potentes m\u00e1quinas de c\u00e1lculo, pero solo saben manejarse con dos d\u00edgitos. A esto se le llama sistema de numeraci\u00f3n binario.</p>"},{"location":"012-01-Binario.html#bits-y-bytes","title":"Bits y bytes","text":"<p>A los d\u00edgitos binarios se les llama bits, abreviatura de binary digits.  \u00bfCuantos bytes necesita una variable? Depende del tipo de dato. </p> <p>Supongamos, por ejemplo, la siguiente variable:</p> <pre><code>&gt;&gt;&gt; x = 7\n</code></pre> <p>La variable es del tipo <code>int</code>:</p> <pre><code>&gt;&gt;&gt; type(x)\n    &lt;class 'int'&gt;\n</code></pre> <p>Los objetos de la clase <code>int</code> tienen un m\u00e9todo <code>bit_length()</code> asociado, que nos indica cuantos bits ocupa:</p> <pre><code>&gt;&gt;&gt; x.bit_length()\n    3\n</code></pre> <p>Por lo tanto, se necesitan 3 d\u00edgitos binarios para representar ese valor.  \u00bfPodemos obtener una representaci\u00f3n en forma de ceros y unos? La funci\u00f3n  <code>bin()</code> nos devuelve un texto:</p> <pre><code>&gt;&gt;&gt; bin(x)\n    0b111\n</code></pre> <p>La funci\u00f3n <code>bin()</code> toma el dato y nos devuelve un texto con los unos y ceros necesarios para representar ese valor, con un prefijo <code>0b</code> que indica el sistema de numeraci\u00f3n.</p> <p>De todas formas, los ordenadores utilizan paquetes de 8 bits, llamados bytes, por lo que el valor <code>111</code> se guardar\u00e1 como <code>00000111</code></p> <p>\u00bfQue pasa cuando tenemos valores muy grandes, que requieren muchos bits? Que la variable tomar\u00e1 de la memoria RAM tantos bytes como necesite. Por ejemplo,  supongamos que en una sesi\u00f3n shell introducimos la siguiente expresi\u00f3n:</p> <pre><code>&gt;&gt;&gt; resultado = 123 ** 234\n</code></pre> <p>El operador <code>**</code> significa \"elevado a\". El resultado es:</p> <pre><code>&gt;&gt;&gt; resultado.bit_length()\n    854\n\n&gt;&gt;&gt; resultado\n    11437436793461719009988029522806627674621807845185022977\n    58879750523695047856668964466065683652015421696499747277\n    30628842345343196581134895919942820874449837212099476648\n    95835902379607854904194900780722062535652692672966406484\n    6685758382803707100766740220839267\n\n&gt;&gt;&gt; bin(resultado)\n    '0b111100111100000100011101000110011110001000010101100001101\n    011000011101011111101110101111100010000110110001100101111110\n    000011111011111001010010110000010110001100000001010101011010\n    001001001010001101110011110101000001111100000011100001101001\n    100010010111111011100101111011011010100110011111001101000001\n    100010011110111101100001000101001011000000111001101100010100\n    101110011000110000011101000010110010100110111011100010110111\n    101100111101011100000011011001000011111001001000101111001101\n    110111101000000001000100101001100001100011010100110101000000\n    001111000100111110101001110101011001011001111001110111001101\n    101100001111101000100111001010000110111011101110100110111100\n    100110001110111001001110111110111100111010101001110100011010\n    110010010011111100100101001111010100000101101111110101000110\n    010100110011101111001010011101011111001101000000000110001010\n    11000010101100011'\n</code></pre>"},{"location":"012-01-Binario.html#representacion-binaria-de-los-textos","title":"Representaci\u00f3n binaria de los textos","text":"<p>Los textos son secuencias de caracteres, y cada car\u00e1cter se almacena asignando un c\u00f3digo a las letras del alfabeto. Si por ejemplo tenemos la variable:</p> <pre><code>nombre = \"Juan\"\n</code></pre> <p>en la memoria RAM tendremos una secuencia de c\u00f3digos, uno por cada letra:</p> <pre><code>    J   u   a   n\n    74  117 97  110\n</code></pre> <p>Podemos averiguar que c\u00f3digo le corresponde a un car\u00e1cter mediante la funci\u00f3n  <code>ord()</code>:</p> <pre><code>&gt;&gt;&gt; ord(\"A\")\n    65\n&gt;&gt;&gt; ord(\"a\")\n    97\n&gt;&gt;&gt; ord(\"\u00f1\")\n    241\n</code></pre> <p>Las variables que representan paquetes de datos, como por ejemplo las listas,  tambi\u00e9n son colecciones de n\u00fameros:</p> <pre><code>persona = [\"Juan\", 27]\n</code></pre> <p>en la memoria RAM:</p> <pre><code>    J   u   a   n    27\n    74  117 97  110  27\n</code></pre> <p>Cada dato se almacena en formato binario:</p> <pre><code>74   01001010\n117  01110101\n97   01100001\n110  01101110\n27   00011011\n</code></pre> <p>Con lo que la siguiente lista:</p> <pre><code>persona = [\"Juan\", 27]\n</code></pre> <p>en la memoria RAM se representa mediante:</p> <pre><code>0100101001110101011000010110111000011011\n</code></pre> <p>... aunque lo habitual es que esta secuencia est\u00e9 troceada en varios paquetes  de ceros y unos, uno por cada dato, y acompa\u00f1ada de informaci\u00f3n sobre los  datos.</p>"},{"location":"012-01-Binario.html#otros-objetos","title":"Otros objetos","text":"<p>En resumen, todo dato, sea de la clase que sea, se representa mediante paquetes de ceros y unos. Veamos como ejemplo, los valores booleanos:</p> <pre><code>&gt;&gt;&gt; bin(True)\n    '0b1'\n&gt;&gt;&gt; bin(False)\n    '0b0'\n</code></pre> <p>Internamente, los conceptos de verdadero y falso se representan mediante un 1 y un cero.</p>"},{"location":"012-01-Binario.html#unidades-de-medida","title":"Unidades de medida","text":"<p>Cuando manejamos grandes vol\u00famenes de datos, se utilizan diferentes unidades  de medida:</p> <ul> <li> <p>un byte son ocho bits</p> </li> <li> <p>Un kilobyte son 1024 bytes y se representa con el s\u00edmbolo Kb (o con una k).  Como veremos m\u00e1s adelante, 1024 es un n\u00famero \"redondo\" en el sistema de  numeraci\u00f3n binario.</p> <p>Por ejemplo, si determinado archivo tiene un tama\u00f1o de 10k, en realidad  contendr\u00e1 10 \u00d7 1.024 bytes, o lo que es lo mismo, 10 \u00d7 1.024 \u00d7 8 bits  (ceros y unos). Trat\u00e1ndose de un archivo de texto, cada car\u00e1cter del juego b\u00e1sico de caracteres (letras, n\u00fameros y s\u00edmbolos) requiere un byte. Otros caracteres tales como los s\u00edmbolos matem\u00e1ticos, emojis, etc. pueden necesitar varios bytes por car\u00e1cter.</p> </li> <li> <p>Un Megabyte  (MB) son 1.024 kilobytes</p> </li> <li>Un Gigabyte  (GB) son 1.024 megabytes</li> <li>Un Terabyte  (TB) son 1.024 gigabytes</li> <li>Un Petabyte  (PB) son 1.024 terabytes  </li> <li>Un Exabyte   (EB) son 1.024 petabytes  </li> <li>Un Zettabyte (ZB) son 1.024 exabytes   </li> <li>Un Yottabyte (YB) son 1.024 zettabytes </li> </ul>"},{"location":"012-02-SistBinario.html","title":"El sistema binario","text":""},{"location":"012-02-SistBinario.html#el-sistema-de-numeracion-binario","title":"El sistema de numeraci\u00f3n binario","text":"<p>Dado que los ordenadores almacenan la informaci\u00f3n en forma de ceros y unos, tendremos que habituarnos al sistema de numeraci\u00f3n binario.</p> <p>Para un principiante acostumbrado al sistema decimal, puede resultar bastante  extra\u00f1o tener que utilizar solo dos d\u00edgitos, pero no debemos olvidar que hay  muchas formas de contar. A veces lo hacemos por docenas, y tenemos que calcular  mentalmente que cinco docenas son sesenta unidades. </p> <p>Recordemos, por ejemplo, los antiguos n\u00fameros romanos, una aritm\u00e9tica con  grandes limitaciones, donde no exist\u00eda el cero ni los n\u00fameros negativos.  Tampoco hab\u00eda decimales, aunque en su lugar se utilizaban fracciones.  En otras culturas como la china, la hebrea o la maya utilizaban sus propios  sistemas de numeraci\u00f3n, y parece ser que fueron los \u00e1rabes quienes, a lo largo  de sus conquistas, descubrieron la aritm\u00e9tica decimal, inventada en la India, y  la expandieron all\u00e1 por donde viajaron, siendo el origen del actual sistema de  numeraci\u00f3n utilizado en la cultura occidental.</p> <p>\u00bfA que se debe que contemos de diez en diez? Seg\u00fan los antrop\u00f3logos, al hecho de que tengamos diez dedos en las manos. Es f\u00e1cil observar que los ni\u00f1os los  utilizan como una calculadora natural, y es de suponer que el hombre primitivo  har\u00eda lo mismo. \u00bfQu\u00e9 hubiera pasado si en lugar de tener cinco dedos en cada  mano tuvi\u00e9semos cuatro? Pues seguramente que contar\u00edamos de ocho en ocho, y en  lugar de un sistema decimal tendr\u00edamos uno octal.</p> <p>En realidad podemos utilizar el sistema de numeraci\u00f3n que queramos.  Si dese\u00e1ramos contar de cinco en cinco, tendr\u00edamos un sistema \"quinario\",  si de tres en tres, uno \"ternario\". Y as\u00ed sucesivamente.  Los ordenadores s\u00f3lo son capaces de utilizar ceros y unos, de ah\u00ed que los  c\u00e1lculos se hagan con aritm\u00e9tica binaria. </p>"},{"location":"012-02-SistBinario.html#examinando-el-sistema-binario","title":"Examinando el sistema binario","text":"<p>Veamos una comparativa entre n\u00fameros decimales y su equivalente en binario:</p> tabla_binaria.py<pre><code>for x in range(20):\n    print(f\"{x:2} = {x:6b}\")\n</code></pre> <p>La ejecuci\u00f3n muestra:</p> <pre><code> 0 =      0\n 1 =      1\n 2 =     10\n 3 =     11\n 4 =    100\n 5 =    101\n 6 =    110\n 7 =    111\n 8 =   1000\n 9 =   1001\n10 =   1010\n11 =   1011\n12 =   1100\n13 =   1101\n14 =   1110\n15 =   1111\n16 =  10000\n17 =  10001\n18 =  10010\n19 =  10011\n</code></pre> <p>V\u00e9ase que mostramos cada valor usando un f-string:</p> <pre><code>print(f\"{x:2} = {x:6b}\")\n</code></pre> <p>en ambos placeholders <code>{}</code> ponemos la variable x seguida de dos puntos y un  especificador de formato:</p> <ul> <li> <p><code>{x:2}</code> indica que insertamos el valor de x ocupando dos posiciones.  Trat\u00e1ndose de un n\u00famero, se alinear\u00e1 a la derecha y se rellenar\u00e1 con espacios  en blanco por la izquierda.</p> </li> <li> <p><code>{x:6b}</code> vuelve a insertar la misma variable, con un ancho de 6 posiciones.  La letra <code>b</code> es para que que el dato se muestre en binario.</p> </li> </ul> <p>\u00bfComo interpretar los n\u00fameros binarios? En sistema decimal, cuando llegamos  al nueve, se nos agotan los d\u00edgitos:</p> <pre><code>1, 2, 3, 4, 5, 6, 7, 8, 9 ...\n</code></pre> <p>y empezamos a combinarlos tom\u00e1ndolos de dos en dos, de tres en tres ...</p> <pre><code>10, 11 12 ... 98, 99, 100, 101 ...\n</code></pre> <p>En binario, los d\u00edgitos se agotan antes, y tenemos que combinarlos de la misma  forma:</p> <pre><code>0, 1, 10, 11, 100, 101, 110, 111 ...\n</code></pre>"},{"location":"012-02-SistBinario.html#conversiones","title":"Conversiones","text":"<p>Dado un n\u00famero binario, \u00bfcu\u00e1l es su equivalencia en decimal? En la tabla anterior vemos que si tomamos como ejemplo el <code>10011</code>, equivale a 19.  Pero \u00bfc\u00f3mo podemos hacer el c\u00e1lculo para n\u00fameros m\u00e1s grandes sin tener que  consultar esta tabla? Necesitamos una regla de conversi\u00f3n.</p> <p>Analicemos un n\u00famero decimal cualquiera, por ejemplo, el 723. Cada d\u00edgito toma  un valor dependiendo de la posici\u00f3n en que se encuentra.  El primer d\u00edgito, el siete, est\u00e1 en la posici\u00f3n de las centenas, por lo que vale  700 en lugar de 7. El segundo est\u00e1 en la posici\u00f3n de las decenas, por lo que  vale 20 en lugar de 2. La suma de los d\u00edgitos aplicando su peso real es igual a 700+20+3=723:</p> <pre><code>D\u00edgito:            7    2   3\nSu peso:         100   10   1  \nMultiplicando:   700   20   3    Suma: 723\n</code></pre> <p>La serie de pesos se obtiene multiplicando cada peso por diez:</p> <pre><code>1, 10, 100, 1.000, 10.000, 100.000, ...\n</code></pre> <p>En el sistema binario hacemos lo mismo, pero para obtener cada peso tenemos que  multiplicar por dos en lugar de hacerlo por diez. Los pesos binarios son:</p> <pre><code>1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, ...\n</code></pre> <p>Utilizaremos estos pesos como hac\u00edamos con el sistema decimal, aplic\u00e1ndolos de derecha a izquierda. Por ejemplo, dado el n\u00famero binario <code>11010111</code>:</p> <pre><code>D\u00edgito:            1    1    0    1    0    1    1     1\nSu peso:         128   64   32   16    8    4    2     1  \nMultiplicando:   128   64    0   16    0    4    2     2     Suma: 215\n</code></pre> <p>Por lo tanto, el n\u00famero binario <code>11010111</code> equivale al 215 en el sistema decimal.  V\u00e9ase que los d\u00edgitos de la derecha son los que se corresponden con los pesos de menos valor.</p> <p>En realidad el c\u00e1lculo es f\u00e1cil: basta con memorizar estos pesos y sumar los  correspondientes a los d\u00edgitos 1, despreciando los que est\u00e1n en la posici\u00f3n  de los d\u00edgitos 0.</p> <p>Para convertir a la inversa, hacemos lo siguiente. Tomemos el n\u00famero 215.  El mayor peso posible es 128. Si vamos restando los pesos obtenidos y tomamos  el mayor posible para el resto, obtendremos que 215 = 128 +64 +16 + 4 +2 +1.  Basta con poner un 1 en las posiciones correspondientes a estos pesos y dejar  el resto a cero, obteniendo como resultado <code>11010111</code>.</p> <p>Hay un detalle adicional que no debemos perder de vista. En el sistema decimal,  a los n\u00fameros tales como 10, 100, 1000, etc. les llamamos n\u00fameros \u201credondos\u201d.  En el sistema binario, los n\u00fameros redondos son los que acabamos de ver:  1, 2, 4, 8, 16, 32, 64, 128, 256 y 1024, es decir, las potencias de dos:</p> <pre><code>2 elevado a 0 = 1\n2 elevado a 1 = 2\n2 elevado a 2 = 4\n2 elevado a 3 = 8\n2 elevado a 4 = 16\n2 elevado a 5 = 32\n2 elevado a 6 = 64\n2 elevado a 7 = 128\n2 elevado a 8 = 256\n2 elevado a 9 = 512\n2 elevado a 10 = 1024\n</code></pre> <p>Estos n\u00fameros aparecen con frecuencia en el mundo de la inform\u00e1tica.  Por ejemplo, se suele decir que un byte son 8 bits, o que un mega es igual a un mill\u00f3n de bytes aproximadamente. En realidad son 1.048.576 bytes, resultado  de multiplicar 1.024 x 1.024.</p>"},{"location":"012-02-SistBinario.html#literales-binarios","title":"Literales binarios","text":"<p>Supongamos la siguiente sentencia en un programa Python:</p> <pre><code>x = 12345\n</code></pre> <p>Le estamos diciendo al ordenador que tenemos una variable llamado \"x\", que ocupa un espacio en la memoria RAM, y que queremos almacenar en ese lugar un valor  12345. Cuando escribimos un programa, escribir los literales en sistema decimal  es lo que podr\u00edamos considerar como escritura natural, pero no nos da visi\u00f3n  sobre los bits a almacenar en la memoria del ordenador.  Podr\u00edamos escribir el literal en binario: </p> <pre><code>x = 0b11000000111001\n</code></pre> <p>Ya hemos visto que, en lenguaje Python, los literales binarios  llevan un prefijo <code>0b</code>.</p> <p>Escribir los n\u00fameros en binario nos dan mayor control de lo que se almacena en  memoria, pero tambi\u00e9n puede ser una fuente de errores, ya que con tantos ceros  y unos es f\u00e1cil equivocarse. Una posible soluci\u00f3n es intercalar caracteres de  subrayado:</p> <pre><code>x = 0b11_0000_0011_1001\n</code></pre> <p>En todo literal num\u00e9rico, sea en formato decimal o binario, los caracteres de  subrayado son decorativos y ser\u00e1n ignorados.</p> <p>Otra alternativa es representar los literales num\u00e9ricos usando otros sistemas  de numeraci\u00f3n, el octal o el hexadecimal. Lo veremos en los siguientes cap\u00edtulos.</p>"},{"location":"012-03-OtrosSistemas.html","title":"Otros sistemas de numeraci\u00f3n","text":"<p>Ya hemos visto que, en la escritura de programas, podemos utilizar el sistema decimal o el binario:</p> <pre><code>x = 12345\nx = 0b11000000111001\n</code></pre> <p>Los literales en sistema decimal es lo que podr\u00edamos considerar como escritura natural, pero no nos da visi\u00f3n sobre los bits en la memoria del ordenador.  Pero el sistema binario es farragoso, con tantos ceros y unos.</p> <p>En los inicios de la inform\u00e1tica, los matem\u00e1ticos descubrieron una tercera  alternativa, el sistema de numeraci\u00f3n octal. </p>"},{"location":"012-03-OtrosSistemas.html#el-sistema-octal","title":"El sistema octal","text":"<p>La ventaja del sistema de numeraci\u00f3n octal est\u00e1 en el hecho de que las  conversiones de octal a binario son f\u00e1ciles de realizar. </p> <p>En el sistema octal se cuenta de ocho en ocho, por lo que debemos limitarnos a  ocho s\u00edmbolos disponibles para representar n\u00fameros:</p> <pre><code>En decimal:  0 1 2 3 4 5 6 7 8 9\nEn octal:    0 1 2 3 4 5 6 7\n</code></pre> <p>Como sucede en el sistema decimal, para n\u00fameros m\u00e1s grandes, necesitamos  combinar varios d\u00edgitos. Veamos la representaci\u00f3n de los primeros n\u00fameros en  decimal y su equivalente en octal:</p> tabla_octal.py<pre><code>print(\"decimal\",\"octal\")\nprint(\"-------\",\"-----\")\nfor x in range(20):\n    print(f\"{x:6} {x:5o}\")\n</code></pre> <p>Lo que muestra:</p> <pre><code>decimal octal\n------- -----\n     0     0\n     1     1\n     2     2\n     3     3\n     4     4\n     5     5\n     6     6\n     7     7\n     8    10\n     9    11\n    10    12\n    11    13\n    12    14\n    13    15\n    14    16\n    15    17\n    16    20\n    17    21\n    18    22\n    19    23\n</code></pre> <p>Al llegar al n\u00ba 8 se acaban los d\u00edgitos octales, y tenemos que  comenzar a combinar n\u00fameros, pasando al 10. Y as\u00ed sucesivamente.  Al 47 le suceder\u00e1 el 50, y al 77, el 100.</p> <p>El especificador de formato para mostrar n\u00fameros en formato octal es una letra  <code>o</code> (may\u00fascula o min\u00fascula) en lugar de una <code>b</code>:</p> <pre><code>print(f\"{n:6} {n:5o}\")\n</code></pre> <p>La ventaja de utilizar el sistema octal en la escritura de programas es que  basta con sustituir cada d\u00edgito octal por tres d\u00edgitos binarios de acuerdo a  la siguiente tabla:</p> Binario Octal 000 0 001 1 010 2 011 3 100 4 101 5 110 6 111 7 <p>Por ejemplo:</p> <pre><code>en decimal :     51966\nen binario :     1 100 101 011 111 110\nen octal   :     1 4   5   3   7   6    = 145376\n</code></pre> <p>Por lo tanto, si en nuestro programa escribimos 145376 e indicamos de alguna  forma que se trata de un n\u00famero octal, ser\u00e1 f\u00e1cil convertir a binario  sustituyendo cada d\u00edgito octal por sus tres d\u00edgitos binarios correspondientes. </p> <p>En lenguaje Python, los literales octales se escriben anteponiendo un prefijo  <code>0o</code> o bien <code>0O</code> (d\u00edgito cero y letra o, may\u00fascula o min\u00fascula).  Las tres instrucciones siguientes son equivalentes:</p> <pre><code>x = 0b1100101011111110   (en binario)\nx = 0o145376             (octal)\nx = 51966                (decimal)\n</code></pre> <p>De todas formas, el uso del sistema octal en los programas est\u00e1 algo pasado  de moda. Se usa m\u00e1s el sistema hexadecimal.</p>"},{"location":"012-03-OtrosSistemas.html#el-sistema-hexadecimal","title":"El sistema hexadecimal","text":"<p>El sistema octal tiene una pega: la memoria RAM est\u00e1 formada por bytes, que son paquetes de ocho bits, y lo ideal ser\u00eda poder coger los d\u00edgitos binarios de  cuatro en cuatro, en lugar de hacerlo de tres en tres. </p> <p>Esto llev\u00f3 en su momento a considerar el uso del sistema \"hexadecimal\"  en la escritura de programas.</p> <p>El sistema de numeraci\u00f3n hexadecimal cuenta de 16 en 16.  Al igual que hac\u00edamos con los n\u00fameros romanos, utilizaremos letras para  algunos s\u00edmbolos:</p> <pre><code>decimal:      0 1 2 3 4 5 6 7 8 9\nhexadecimal:  0 1 2 3 4 5 6 7 8 9 A B C D E F\n</code></pre> <p>Al escribir un programa se suele utilizar indistintamente may\u00fasculas o  min\u00fasculas. Veamos como se cuenta en decimal y en hexadecimal:</p> tabla_hex.py<pre><code>print(\"decimal\",\"hexadecimal\")\nprint(\"-------\",\"-----------\")\nfor n in range(40):\n    print(f\"{n:6} {n:5X}\")\n</code></pre> <p>Muestra:</p> <pre><code>decimal hexadecimal\n------- -----------\n     0     0\n     1     1\n     2     2\n     3     3\n     4     4\n     5     5\n     6     6\n     7     7\n     8     8\n     9     9\n    10     A\n    11     B\n    12     C\n    13     D\n    14     E\n    15     F\n    16    10\n    17    11\n    18    12\n    19    13\n    20    14\n    21    15\n    22    16\n    23    17\n    24    18\n    25    19\n    26    1A\n    27    1B\n    28    1C\n    29    1D\n    30    1E\n    31    1F\n    32    20\n    33    21\n    34    22\n    35    23\n    36    24\n    37    25\n    38    26\n    39    27\n</code></pre> <p>N\u00f3tese que el especificador de formato para n\u00fameros hexadecimales es una  letra <code>x</code> (may\u00fascula o min\u00fascula):</p> <pre><code>print(f\"{n:6} {n:5X}\")\n</code></pre> <p>En el ejemplo vemos que al llegar al n\u00famero <code>F</code> se agotan las posibilidades  y pasamos al <code>10</code>. Al llegar al <code>1F</code> pasaremos al 20, y al llegar al <code>FF</code>,  el n\u00famero siguiente ser\u00e1 el 100.</p> <p>Cuando escribimos un programa, lo habitual es escribir los n\u00fameros en decimal  o en hexadecimal indistintamente. El uso de literales binarios u octales es m\u00e1s  infrecuente, y se limita a situaciones puntuales.</p> <p>Las conversiones de hexadecimal a binario son f\u00e1ciles. Basta con tomar los bits  de cuatro en cuatro y convertirlos de acuerdo a la siguiente tabla:</p> Binario Hexadecimal Binario Hexadecimal 0000 0 1000 8 0001 1 1001 9 0010 2 1010 A 0011 3 1011 B 0100 4 1100 C 0101 5 1101 D 0110 6 1110 E 0111 7 1111 F <p>De esta forma, todo byte se puede representar con dos d\u00edgitos hexadecimales.  Es decir:</p> <ul> <li>en binario, un byte toma valores de 00000000 a 11111111</li> <li>convirtiendo a decimal, de 0 a 255</li> <li>en octal, de 00 a 0377</li> <li>en hexadecimal, de 00 a FF</li> </ul> <p>Cada paquete de cuatro bits se denomina nibble. Un byte est\u00e1 formado por dos  nibbles, representado cada uno por un d\u00edgito hexadecimal.</p> <p>El sistema hexadecimal resulta bastante pr\u00e1ctico, una vez que nos acostumbramos  a su uso. En lenguaje Python, los literales hexadecimales se escriben  anteponiendo un prefijo <code>0x</code>. Las cuatro instrucciones siguientes son  equivalentes, ya que representan el mismo valor:</p> <pre><code>x = 51966               (en decinal)\nx = 0145376             (en octal)\nx = 0b1100101011111110  (binario)\nx = 0xCAFE              (hexadecimal)\n</code></pre> <p>Cualquiera de las cuatro equivale el n\u00famero binario <code>1100 1010 1111 1110</code>,  pero si no queremos escribir tantos ceros y unos, el formato hexadecimal es el  que m\u00e1s se aproxima a la representaci\u00f3n binaria.</p>"},{"location":"013-01-Clases.html","title":"Clases y objetos","text":""},{"location":"013-01-Clases.html#objetos","title":"Objetos","text":"<p>En un programa Python, todos los datos, variables y dem\u00e1s elementos, son  objetos que pertenecen a una clase:</p> <pre><code>&gt;&gt;&gt; type(123)\n    &lt;class 'int'&gt;\n\n&gt;&gt;&gt; type(\"123\")\n    &lt;class 'str'&gt;\n\n&gt;&gt;&gt; type(print)\n    &lt;class 'builtin_function_or_method'&gt;\n</code></pre>"},{"location":"013-01-Clases.html#clases-de-usuario","title":"Clases de usuario","text":"<p>Como sucede con las funciones, podemos crear nuestras propias clases:</p> Clases1.py<pre><code>class Loro:\n    pass\n\nPoly = Loro()\nJenny = Loro()\nprint(\"Poly:\", type(Poly))\nprint(\"Jenny:\", type(Jenny))\n</code></pre> <p>Lo que muestra:</p> <pre><code>Poly: &lt;class '__main__.Loro'&gt;\nJenny: &lt;class '__main__.Loro'&gt;\n</code></pre> <p>Veamos una explicaci\u00f3n de todo esto. Las clases se definen mediante:</p> <pre><code>class nombre :\n    definici\u00f3n de m\u00e9todos\n</code></pre> <p>El cuerpo de la clase lleva una lista de m\u00e9todos. Como en este caso no definimos nada, nos limitamos a la sentencia <code>pass</code>.</p> <p>Los objetos se crean llamando a una funci\u00f3n constructora con el mismo nombre que la clase:</p> <pre><code>x = int(0)\ntexto = str(0)\nPoly = Loro()\n</code></pre> <p>La funci\u00f3n <code>type()</code> crea un objeto de la clase type, con informaci\u00f3n sobre un  objeto. Al ser representado en forma de texto, muestra el nombre de la clase precedido por el nombre del m\u00f3dulo donde se define. Como nuestra clase Loro  no ha sido definida en otro m\u00f3dulo, sino directamente en el programa,  el nombre del m\u00f3dulo es <code>_main_</code></p> <pre><code>Poly: &lt;class '__main__.Loro'&gt;\nJenny: &lt;class '__main__.Loro'&gt;\n</code></pre>"},{"location":"013-02-Me%CC%81todos.html","title":"M\u00e9todos","text":"<p>Una vez creada una clase, tenemos que definir sus m\u00e9todos.</p>"},{"location":"013-02-Me%CC%81todos.html#definir-metodos","title":"Definir m\u00e9todos","text":"<p>Vamos a crear una clase Loro que haga dos cosas, saludar y despedirse:</p> Clases2.py<pre><code>class Loro:\n\n    def saludo(esteLoro):\n        print (\"Hola\")\n\n    def despedida(esteLoro):\n        print (\"Adios\")\n\nPoly = Loro()\nJenny = Loro()\n\nprint(\"Habla Poly\")\nPoly.saludo()\nPoly.despedida()\n\nprint(\"Habla Jenny\")\nJenny.saludo()\nJenny.despedida()\n</code></pre> <p>Muestra:</p> <pre><code>Habla Poly:\nHola\nAdios\nHabla Jenny:\nHola\nAdios\n</code></pre> <p>Los m\u00e9todos se definen como cualquier funci\u00f3n, pero dentro de la clase. Esto obliga a dos niveles de sangrado, uno para el cuerpo de la clase, y otro para las sentencias de cada m\u00e9todo.</p> <p>Los objetos se crean mediante:</p> <pre><code>objeto = NombreClase()\n</code></pre> <p>Los m\u00e9todos se invocan mediante:</p> <pre><code>nombreObjeto.metodo()\n</code></pre> <p>Los m\u00e9todos reciben un primer par\u00e1metro autom\u00e1tico, una variable que se refiere al propio objeto.</p> <p>A los objetos se les llama \"instancias\" de la clase, dado que esta sirve de modelo para crear objetos, que son como una especie de replicas de la clase, heredando su estructura de m\u00e9todos y datos. </p>"},{"location":"013-02-Me%CC%81todos.html#el-parametro-self","title":"El par\u00e1metro <code>self</code>","text":"<p>Todo m\u00e9todo recibe de manera intr\u00ednseca una referencia al objeto asociado, para poder interaccionar con el mismo:</p> <pre><code>def saludo(esteLoro):\n    print (\"Hola\")\n    esteLoro.despedida()\n</code></pre> <p>Lo que mostrar\u00e1:</p> <pre><code>Hola\nAdios\n</code></pre> <p>Este par\u00e1metro ha de ser el primero, y no debe pasarse como argumento, ya que se incluye en la llamada autom\u00e1ticamente:</p> <pre><code>Poly.saludo()\nPoly.despedida()\n</code></pre> <p>En la definici\u00f3n del m\u00e9todo podemos darle el nombre que queramos, pero es  costumbre llamarlo <code>self</code>, haciendo referencia al propio objeto:</p> <pre><code>def saludo(self):\n    print (\"Hola\")\n    self.despedida()\n</code></pre>"},{"location":"013-02-Me%CC%81todos.html#el-metodo-__init__","title":"El m\u00e9todo <code>__init__()</code>","text":"<p>El m\u00e9todo <code>__init__()</code>, si lo incluimos, es especial. Se ejecuta autom\u00e1ticamente cada vez que creamos una instancia:</p> Clases3.py<pre><code>class Loro:\n\n    def __init__(self, nombre):\n        print (\"Creando\", nombre)\n\n    def saludo(self):\n        print (\"Hola\")\n\n    def despedida(self):\n        print (\"Adios\")\n\nPoly = Loro(\"Poly\")\nJenny = Loro(\"Jenny\")\n\nprint(\"Habla Poly\")\nPoly.saludo()\nPoly.despedida()\n\nprint(\"Habla Jenny\")\nJenny.saludo()\nJenny.despedida()\n\ndel Poly\ndel Jenny\n</code></pre> <p>Lo que muestra:</p> <pre><code>Creando Poly\nCreando Jenny\nHabla Poly\nHola\nAdios\nHabla Jenny\nHola\nAdios\n</code></pre> <p>V\u00e9ase que a la funci\u00f3n constructora le pasamos un argumento:</p> <pre><code>Poly = Loro(\"Poly\")\nJenny = Loro(\"Jenny\")\n</code></pre> <p>pero en realidad recibe dos, el intr\u00ednseco (siempre en primer lugar) y uno  expl\u00edcito:</p> <pre><code>def __init__(self, nombre):\n    print (\"Creando\", nombre)\n</code></pre>"},{"location":"013-03-Propiedades.html","title":"Propiedades","text":"<p>Las propiedades son variables que van precedidas por el nombre del objeto, y que se almacenan como parte de este.</p>"},{"location":"013-03-Propiedades.html#definiendo-propiedades","title":"Definiendo propiedades","text":"Clases4.py<pre><code>class Loro:\n\n    def __init__(self, nombre):\n        self.nombre = nombre\n        print (\"Creando loro\", nombre)\n\n    def saludo(self):\n        print (\"Hola\", self.nombre)\n\n    def despedida(self):\n        print (\"Adios\", self.nombre)\n\nPoly = Loro(\"Poly\")\nJenny = Loro(\"Jenny\")\n\nPoly.saludo()\nPoly.despedida()\n\nJenny.saludo()\nJenny.despedida()\n</code></pre> <p>T\u00edpicamente, las propiedades se crean en el m\u00e9todo <code>__init__()</code> </p> <p>Hacemos referencia a las propiedades mediante:</p> <ul> <li>desde un m\u00e9todo: <code>self.nombre_propiedad</code></li> <li>desde fuera de la clase: <code>nombre_objeto.nombre_propiedad</code></li> </ul>"},{"location":"013-03-Propiedades.html#examinar-objetos","title":"Examinar objetos","text":"<p>La funci\u00f3n <code>dir()</code> proporciona una lista de los m\u00e9todos y propiedades de un  objeto:</p> Clases5.py<pre><code>class Loro:\n\n    def __init__(self, nombre):\n        self.nombre = nombre\n        print (\"Creando loro\", nombre)\n\n    def saludo(self):\n        print (\"Hola\", self.nombre)\n\n    def despedida(self):\n        print (\"Adios\", self.nombre)\n\nPoly = Loro(\"Poly\")\n\nprint(\"\\nContenido de Poly:\")\nlista = dir(Poly)\nfor elemento in lista:\n    print(elemento)\n</code></pre> <p>Esto muestra una serie de m\u00e9todos y propiedades heredados del mecanismo interno de Python, m\u00e1s los que hemos a\u00f1adido nosotros:</p> <pre><code>nombre\nsaludo\ndespedida\n</code></pre> <p>Python suele a\u00f1adir prefijos y sufijos formados por caracteres de subrayado en el caso de identificadores de uso interno. </p>"},{"location":"013-04-Herencia.html","title":"Herencia","text":""},{"location":"013-04-Herencia.html#clases-padre-e-hija","title":"Clases padre e hija","text":"<p>Una clase se puede copiar de otra:</p> Clases5.py<pre><code>class Ave:\n\n    def __init__(self, nombre):\n        self.nombre = nombre\n\n    def volar(self):\n        print (self.nombre, \"est\u00e1 volando\")\n\nclass Loro (Ave):\n\n    def saludar(self):\n        print (self.nombre, \"dice hola\")\n\n    def despedirse(self):\n        print (self.nombre, \"dice adios\")\n\nPoly = Loro(\"Poly\")\nprint(\"Creando\", Poly.nombre)\nprint(\"\\nContenido de Poly:\")\nlista = dir(Poly)\nfor elemento in lista:\n    if elemento[0] == '_':\n        pass\n    else:\n        print(\"- \"+elemento)\n\nprint()\nPoly.volar()\nPoly.saludar()\nPoly.despedirse()\n\nprint()\nprint(Poly.nombre, \"es suprimido\")\ndel Poly\n</code></pre> <p>Lo que muestra:</p> <pre><code>Creando Poly\n\nContenido de Poly:\n- despedirse\n- nombre\n- saludar\n- volar\n\nPoly est\u00e1 volando\nPoly dice hola\nPoly dice adios\n\nPoly es suprimido\n</code></pre> <p>En este ejemplo:</p> <ul> <li> <p>creamos una clase <code>Ave</code> con un m\u00e9todo <code>volar()</code> y una propiedad <code>nombre</code>.</p> </li> <li> <p>creamos una clase <code>Loro</code> derivada de <code>Ave</code> </p> <pre><code>class Loro (Ave):\n    m\u00e9todo a\u00f1adidos por la clase Loro\n</code></pre> </li> <li> <p>todos los loros son aves, y la clase <code>Loro</code> hereda las caracter\u00edsticas     de la clase <code>Ave</code>, a\u00f1adiendo las suyas propias.</p> </li> <li> <p>A la clase original se le llama clase padre</p> </li> <li>La clase derivada se llama clase hija</li> </ul> <p>Si la clase hija define un m\u00e9todo con el mismo nombre que otro de la clase padre, lo sustituye:</p> Clases6.py<pre><code>class Ave:\n\n    def __init__(self, nombre):\n        self.nombre = nombre\n\n    def volar(self):\n        print (self.nombre, \"est\u00e1 volando\")\n\nclass Loro (Ave):\n\n    # m\u00e9todo redefinido\n    def __init__(self, nombre):\n        self.nombre = \"Loro \"+nombre\n\n    def saludar(self):\n        print (self.nombre, \"dice hola\")\n\n    def despedirse(self):\n        print (self.nombre, \"dice adios\")\n\nPoly = Loro(\"Poly\")\nPiolin = Ave(\"Piolin\")\n\nPoly.volar()\nPiolin.volar()\n</code></pre> <p>Muestra:</p> <pre><code>Loro Poly est\u00e1 volando\nPiolin est\u00e1 volando\n</code></pre> <p>Hemos redefinido el m\u00e9todo <code>__init__()</code> de la clase <code>Loro</code> para que el nombre de los objetos de esta clase incluya el nombre de la misma.</p>"},{"location":"013-04-Herencia.html#llamada-a-metodos-de-la-clase-padre","title":"Llamada a m\u00e9todos de la clase padre","text":"<p>Si reescribimos un m\u00e9todo en la clase hija, a veces es necesario dejar las  sentencias comunes en la clase padre y a\u00f1adir en la hija las sentencias especializadas. En este caso, hay que acordarse de invocar desde la clase hija el m\u00e9todo original:</p> Clases6.py<pre><code>class Ave:\n\n    def __init__(self, nombre):\n        self.nombre = nombre\n\n    def volar(self):\n        print (self.nombre, \"est\u00e1 volando\")\n\nclass Loro (Ave):\n\n    # m\u00e9todo redefinido\n    def __init__(self, nombre):\n        super().__init__(nombre)\n        self.nombre = \"Loro \"+self.nombre\n\n    def saludar(self):\n        print (self.nombre, \"dice hola\")\n\n    def despedirse(self):\n        print (self.nombre, \"dice adios\")\n\nPoly = Loro(\"Poly\")\nPiolin = Ave(\"Piolin\")\n\nPoly.volar()\nPiolin.volar()\n</code></pre> <p>Muestra:</p> <pre><code>Loro Poly est\u00e1 volando\nPiolin est\u00e1 volando\n</code></pre> <p>En el m\u00e9todo de la clase padre definimos la propiedad nombre. El m\u00e9todo de la clase hija llama al de la clase padre y, una vez creada la propiedad, le a\u00f1ade el prefijo \"Loro\".</p> <p>La llamada a la clase padre se hace creando una instancia an\u00f3nima:</p> <pre><code>super().__init__(nombre)\n</code></pre> <p>La palabra <code>super</code> hace referencia a la clase padre.</p>"},{"location":"013-05-Modulos.html","title":"Modulos que definen clases","text":"<p>Al igual que suced\u00eda con las funciones, podemos crear un m\u00f3dulo con clases de utilidad, e importarlo:</p> MisClases.py<pre><code>class Ave:\n\n    def __init__(self, nombre):\n        self.nombre = nombre\n\n    def volar(self):\n        print (self.nombre, \"est\u00e1 volando\")\n\nclass Loro (Ave):\n\n    def saludar(self):\n        print (self.nombre, \"dice hola\")\n\n    def despedirse(self):\n        print (self.nombre, \"dice adios\")\n</code></pre> Loro.py<pre><code>from MisClases import Loro\n\nPoly = Loro(\"Poly\")\n\nprint(\"Creando\", Poly.nombre)\nPoly.volar()\nPoly.saludar()\nPoly.despedirse()\n\ndel Poly\n</code></pre> <p>Lo que muestra:</p> <pre><code>Creando Poly\nPoly est\u00e1 volando\nPoly dice hola\nPoly dice adios\n</code></pre> <p>N\u00f3tese que solo importamos los identificadores a los que se hace referencia en el programa principal. No es necesario importar la clase <code>Ave</code>, porque no se menciona expl\u00edcitamente, aunque la clase <code>Loro</code> la utiliza.</p>"},{"location":"014-01-Pip.html","title":"Instalar otras bibliotecas","text":"<p>La instalaci\u00f3n del int\u00e9rprete de Python viene acompa\u00f1ada de dos herramientas muy poderosas, el editor IDLE y la biblioteca est\u00e1ndar. Esta nos proporciona una buena cantidad de todo tipo de recursos, funciones, clases y un largo  etc\u00e9tera.</p> <p>Pero hay m\u00e1s. En torno a Python se ha ido desarrollando una enorme comunidad de  programadores, capaces de aportar soluciones que  complementan las capacidades del lenguaje. Estas herramientas de terceros  incluyen otros editores alternativos a IDLE o bibliotecas que aportan nuevas  funcionalidades.</p>"},{"location":"014-01-Pip.html#bibliotecas-instaladas","title":"Bibliotecas instaladas","text":"<p>Podemos averiguar cuales son los m\u00f3dulos de biblioteca instalados en nuestro equipo, tanto los est\u00e1ndar como los de terceros, usando el comando Python:</p> <pre><code>&gt;&gt;&gt; help(\"modules\")\n</code></pre> <p>Si queremos explorar el ecosistema Python y descubir bibliotecas a nuestra disposici\u00f3n, podemos acudir a la p\u00e1gina web  The Python Package Index.</p>"},{"location":"014-01-Pip.html#instalar-una-biblioteca","title":"Instalar una biblioteca","text":"<p>Vamos a instalar Pillow, una biblioteca que a\u00f1ade capacidades de procesamiento de im\u00e1genes. La instalaci\u00f3n  se hace mediante comandos del sistema operativo. El primer paso es abrir una ventana shell de comandos, tal y como se explic\u00f3 en un cap\u00edtulo anterior:</p> <ul> <li>en Windows, escribir \"cmd\" en el cuadro de b\u00fasqueda del escritorio.</li> <li>en ordenadores Mac, buscar el programa Terminal, en la carpeta \"Aplicaciones &gt;&gt; Utilidades\". </li> <li>en Linux, ejecutar el programa Terminal.</li> </ul> <p>El programa para instalar bibliotecas Python es <code>pip</code> (instalador de  paquetes Python). Comprobamos que ya lo tenemos en nuestro ordenadores abriendo un terminal de comandos y ejecutando el comando:</p> <pre><code>pip --version\n</code></pre> <p>N\u00f3tese que el gui\u00f3n <code>--</code> es doble. Esto deber\u00eda mostrar la versi\u00f3n instalada:</p> <pre><code>pip 24.3.1\n</code></pre> <p>Si lo que obtenemos es un mensaje de error, es posible que el comando sea  <code>pip3</code> (depende de como hayamos instalado Python):</p> <pre><code>pip3 --version\n</code></pre> <p>Si hemos instalado la versi\u00f3n m\u00e1s reciente de Python en Windows o Mac, el programa <code>pip</code> suele venir de serie. En Linux, es posible que tengamos que acudir al repositorio de software de nuestra distribuci\u00f3n para descargar e instalar <code>pip</code> por separado.</p> <p>Una vez comprobado que tenemos <code>pip</code>, lo usamos para averiguar que bibliotecas de terceros hemos instalado. En un terminal del sistema operativo, introducimos el comando:</p> <pre><code>pip list\n</code></pre> <p>o bien:</p> <pre><code>pip3 list\n</code></pre> <p>Para instalar un nuevo paquete, ejecutar el comando:</p> <pre><code>pip install nombre_paquete\n</code></pre> <p>Por ejemplo, en el caso de <code>Pillow</code>:</p> <pre><code>pip install pillow\n</code></pre> <p>Ver las instrucciones en la documentaci\u00f3n de cada paquete.  Las de Pillow est\u00e1n en:</p> <p>https://pillow.readthedocs.io/en/stable/installation/basic-installation.html</p>"},{"location":"014-01-Pip.html#suprimir-una-biblioteca","title":"Suprimir una biblioteca","text":"<p>Podemos eliminar una biblioteca que hayamos instalado con el comando:</p> <pre><code>pip uninstall nombre_paquete\n</code></pre>"},{"location":"014-01-Pip.html#informacion-sobre-una-biblioteca","title":"Informaci\u00f3n sobre una biblioteca","text":"<p>Podemos averiguar informaci\u00f3n sobre una biblioteca ya instalada con:</p> <pre><code>pip show nombre_paquete\n</code></pre> <p>Por ejemplo:</p> <pre><code>Name: pillow\nVersion: 11.1.0\nSummary: Python Imaging Library (Fork)\nHome-page: https://python-pillow.github.io\nAuthor: \nAuthor-email: \"Jeffrey A. Clark\" &lt;aclark@aclark.net&gt;\nLicense: MIT-CMU\nLocation: /Users/usuario/Library/Python/3.13/lib/python/site-packages\nRequires: \nRequired-by: weasyprint\n</code></pre>"},{"location":"014-01-Pip.html#actualizar-una-biblioteca","title":"Actualizar una biblioteca","text":"<p>Apostar por una biblioteca desarrollada por alguien desconocido es algo que  hacemos asumiendo ciertos riesgos. En el ecosistema Python hay  herramientas de gran calidad y otras mediocres. Hay bibliotecas que,  una vez desarrolladas, son abandonadas por sus autores, y otras, por el contrario, se someten a un proceso de continua mejora, publicando nuevas  versiones de forma peri\u00f3dica.</p> <p>Si detectamos que hay nuevas versiones, podemos actualizar la que tenemos  instalada con el comando:</p> <pre><code>pip install --upgrade nombre_paquete\n</code></pre>"},{"location":"014-01-Pip.html#ejecutar-pip-como-modulo","title":"Ejecutar pip como m\u00f3dulo","text":"<p>La ejecuci\u00f3n de <code>pip</code> se puede hacer de la forma indicada. Pero en algunos  ordenadores, es posible que esto no funcione, dependiendo de la configuraci\u00f3n del sistema. En ese caso, podemos escribir en su lugar:</p> <pre><code>python -m pip\n</code></pre> <p>o bien</p> <pre><code>python3 -m pip3\n</code></pre> <p>indicando que pip es un m\u00f3dulo de Python.</p> <p>Por ejemplo, para instalar Pillow, escribimos:</p> <pre><code>python3 -m pip3 install pillow\n</code></pre> <p>en lugar de:</p> <pre><code>pip3 install pillow\n</code></pre>"},{"location":"014-02-Pillow.html","title":"Buscar archivos de im\u00e1genes","text":"<p>Si hemos instalado Pillow, siguiendo las instrucciones del cap\u00edtulo anterior, podemos comprobar la versi\u00f3n con:</p> <pre><code>&gt;&gt;&gt; import PIL\n&gt;&gt;&gt; PIL.__version__\n    '11.1.0'\n</code></pre> <p>Pillow es un proyecto derivado de otro anterior, llamado PIL. Muchos t\u00e9rminos se han mantenido sin ser modificados.</p> <p>Vamos a usar Pillow para hacer una b\u00fasqueda de archivos de im\u00e1genes en nuestro equipo, y mostrar su resoluci\u00f3n.</p>"},{"location":"014-02-Pillow.html#buscar-archivos-en-disco","title":"Buscar archivos en disco","text":"<p>Comencemos por examinar un directorio:</p> Directorio.py<pre><code>import os\ncarpeta = '/Users/usuario/Documents/'\nfor archivo in os.listdir(carpeta):\n    print(archivo)\n</code></pre> <p>Lo que muestra una lista de ficheros en esa carpeta. Podemos mostrarlos con su ruta completa mediante:</p> <pre><code>print(carpeta+archivo)\n</code></pre> <p>... aunque tendremos que a\u00f1adir manualmente la barra final para que esto funcione:</p> <pre><code>carpeta = '/Users/usuario/Documents/'\n</code></pre> <p>Vemos que el m\u00f3dulo est\u00e1ndar <code>os</code> cuenta con una funci\u00f3n <code>listdir(x)</code> que  devuelve una lista de ficheros en la carpeta x.</p>"},{"location":"014-02-Pillow.html#buscar-archivos-de-forma-recursiva","title":"Buscar archivos de forma recursiva","text":"<p>Si uno de los archivos encontrados es una carpeta, vamos a interrumpir  temporalmente el proceso de la carpeta actual, y examinar esa subcarpeta:</p> Directorio2.py<pre><code>import os\n\ndef buscar(carpeta):\n    for archivo in os.listdir(carpeta):\n\n        # Obtener la ruta completa del archivo\n\n        if carpeta[-1] == \"/\":\n            archivo = carpeta+archivo\n        else:\n            archivo = carpeta+\"/\"+archivo\n\n        # Si es una subcarpeta, examinarla\n\n        if os.path.isdir(archivo):\n            buscar(archivo)\n        else:\n            print(archivo)\n\ncarpeta = '/Users/usuario/Documents/'\nbuscar(carpeta)\n</code></pre> <p>La funci\u00f3n <code>os.path.isdir(x)</code> examina la entrada x en un directorio y devuelve True si se trata de una carpeta. En ese caso, hacemos una nueva llamada a <code>buscar()</code> para examinar la carpeta encontrada.</p> <p>Con este ejemplo, vemos que una funci\u00f3n puede llamarse a si mismo de forma recursiva. Es una t\u00e9cnica un poco peligrosa, porque la funci\u00f3n puede estar  autoinvoc\u00e1ndose de forma indefinida hasta colapsar el sistema, meti\u00e9ndose en un bucle indefinidamente. Cuando hagamos uso de estas llamadas recursivas,  debemos estar seguros de que en alg\u00fan momento se interrumpir\u00e1 la recursi\u00f3n.</p>"},{"location":"014-02-Pillow.html#seleccionar-archivos-de-imagenes","title":"Seleccionar archivos de im\u00e1genes","text":"<p>Al procesar un archivo, vamos a intentar abrirlo con Pillow. Si no es un archivo de imagen (png, jpeg, etc) se producir\u00e1 un error, y con un bloque <code>try...axcept</code> lo ignoramos.</p> <p>En el caso de que consigamos abrir el fichero, mostramos su nombre y usamos el m\u00e9todo <code>close()</code> para borrarlo de la memoria RAM.</p> <p>Para hacer uso del Pillow, tenemos que importar el m\u00f3dulo <code>Image</code>:</p> <pre><code>from PIL import Image\n</code></pre> <p>El programa queda as\u00ed:</p> ListaImagenes.py<pre><code>import os\nfrom PIL import Image\n\ndef buscar(carpeta):\n    for archivo in os.listdir(carpeta):\n        if carpeta[-1] == \"/\":\n            archivo = carpeta+archivo\n        else:\n            archivo = carpeta+\"/\"+archivo\n\n        if os.path.isdir(archivo):\n            buscar(archivo)\n        else:\n            try:\n                imagen=Image.open(archivo)\n                print(archivo)\n                imagen.close()\n            except:\n                pass\n\ncarpeta = '/Users/usuario/Documents/'\nbuscar(carpeta)\n</code></pre>"},{"location":"014-02-Pillow.html#anadir-informacion-sobre-cada-imagen","title":"A\u00f1adir informaci\u00f3n sobre cada imagen","text":"<p>Vamos a utilizar las capacidades de Pillow para averiguar la resoluci\u00f3n de las im\u00e1genes:</p> ListaImagenes2.py<pre><code>import os\nfrom PIL import Image\n\ndef buscar(carpeta):\n    for archivo in os.listdir(carpeta):\n        if carpeta[-1] == \"/\":\n            archivo = carpeta+archivo\n        else:\n            archivo = carpeta+\"/\"+archivo\n\n        if os.path.isdir(archivo):\n            buscar(archivo)\n        else:\n            try:\n                imagen=Image.open(archivo)\n                tama\u00f1o=imagen.size\n                print(f\"{archivo} ({tama\u00f1o[0]}x{tama\u00f1o[1]})\")\n                imagen.close()\n            except:\n                pass\n\ncarpeta = '/Users/usuario/Documents/'\nbuscar(carpeta)\n</code></pre> <p>La funci\u00f3n <code>Image.open()</code> crea un objeto en memoria que tiene una propiedad <code>size</code>. Consiste en una tupla de dos elementos, ancho y alto de la imagen, medido en n\u00famero de pixels (puntos de color).</p> <p>Con esto obtenemos en la consola una lista de archivos de imagen, con su  resoluci\u00f3n:</p> <pre><code>Documents/imagenes/Imagen01.png (600x270)\nDocuments/imagenes/Imagen03.png (600x288)\nDocuments/imagenes/Imagen02.png (600x355)\nDocuments/imagenes/Imagen10.png (600x316)\nDocuments/imagenes/Imagen04.png (600x321)\nDocuments/imagenes/Imagen09.png (1002x328)\nDocuments/imagenes/Imagen08.png (600x216)\n...\n</code></pre>"},{"location":"015-01-Tkinter.html","title":"La biblioteca tkinter","text":"<p>Entre los m\u00f3dulos de la biblioteca est\u00e1ndar, Python incluye tkinter, un m\u00f3dulo que contiene funciones para crear ventanas gr\u00e1ficas y mostrarlas en el escritorio de la computadora.</p>"},{"location":"015-01-Tkinter.html#un-primer-ejemplo","title":"Un primer ejemplo","text":"<p>Vamos a crear un programa que, al ejecutarse, muestre la siguiente ventana:</p> <p></p> <p>Las ventana tiene las siguientes caracter\u00edsticas:</p> <ul> <li>Medidas: 500 x 300 pixels. Un pixel es un punto de color en la pantalla,     y los objetos gr\u00e1ficos tienen un tama\u00f1o medida en pixels.</li> <li>T\u00edtulo de la ventana: \"Prueba tkinter\"</li> <li>Un espacio con fondo color beige donde podemos escribir y dibujar. All\u00ed hemos     puesto la palabra \"Hola\". A este espacio se le llama canvas (lienzo).</li> <li>Una barra inferior donde ponemos un bot\u00f3n Terminar. Pulsando, se cierra     la ventana y acaba el programa.</li> </ul> <p>El programa es el siguiente:</p> Tkinter1.py<pre><code>from tkinter import *\n\nventana = Tk()\n\nlienzo= Canvas(ventana)\nlienzo.configure(width=500)\nlienzo.configure(height=300)\nlienzo.configure(bg='AntiqueWhite')\nlienzo.pack()\n\nlienzo.create_text(30,30, text=\"Hola\")\n\nboton=Button(ventana)\nboton.configure(text=\"Terminar\")\nboton.configure(command=ventana.destroy)\nboton.pack()\n\nventana.title(\"Prueba tkinter\")\nventana.mainloop()\n</code></pre>"},{"location":"015-01-Tkinter.html#explicacion-del-programa","title":"Explicaci\u00f3n del programa","text":"<p>Comenzamos por importar los elementos de la biblioteca tkinter:</p> <pre><code>from tkinter import *\n</code></pre> <p>La ventana es un objeto de la clase <code>Tk</code>:</p> <pre><code>ventana = Tk()\n</code></pre> <p>Los objetos se crean invocando una funci\u00f3n constructora, cuyo nombre es el de la clase. </p> <p>En nuestra ventana, colocamos dos objetos, un lienzo donde pintar,  y un bot\u00f3n. El primero es un objeto de la clase <code>Canvas</code>, y el segundo, de la  clase <code>Button</code>:</p> <pre><code>lienzo= Canvas(ventana)\nboton=Button(ventana)\n\nlienzo.pack()\nboton.pack()\n</code></pre> <p>Los creamos pasando como argumento el componente \"padre\", que es la ventana.  Esto significa que deben quedar insertados y ligados a la ventana. Los colocamos uno a continuaci\u00f3n del otro haciendo una llamada al m\u00e9todo <code>pack()</code>. Se situar\u00e1n verticalmente, y el tama\u00f1o de la ventana se ajustar\u00e1 autom\u00e1ticamente para dar  cabida a ambos componentes.</p> <p>El t\u00edtulo de la ventana se establece con el m\u00e9todo <code>title</code>:</p> <pre><code>ventana.title(\"Prueba tkinter\")\n</code></pre> <p>El m\u00e9todo <code>mainloop()</code> pone en marcha el proceso gestor de eventos, que permite controlar cuando el usuario pulsa en el bot\u00f3n.</p>"},{"location":"015-01-Tkinter.html#configurando-un-objeto","title":"Configurando un objeto","text":"<p>Los objetos de tkinter tienen un m\u00e9todo <code>configure()</code> que permite establecer  varios par\u00e1metros del lienzo, las dimensiones, color de fondo, etc:</p> <pre><code>lienzo.configure(width=500)            # ancho en pixels\nlienzo.configure(height=300)           # alto en pixels\nlienzo.configure(bg='AntiqueWhite')    # color de fondo (background)\n</code></pre>"},{"location":"015-01-Tkinter.html#escribiendo-en-un-canvas","title":"Escribiendo en un Canvas","text":"<p>El m\u00e9todo <code>create_text()</code> permite poner un texto en el lienzo. Como argumentos debemos pasar las coordenadas. La esquina superior izquierda se  corresponde con las coordenadas 0,0 </p> <pre><code>lienzo.create_text(30,30, text=\"Hola\")\n</code></pre> <p>Ponemos el texto 30 puntos a la derecha de la esquina, y otros 30 hacia abajo, dejando un margen.</p>"},{"location":"015-01-Tkinter.html#configurando-un-boton","title":"Configurando un bot\u00f3n","text":"<p>Para definir el texto del bot\u00f3n, escribimos:</p> <pre><code>boton.configure(text=\"Terminar\")\n</code></pre> <p>Para definir la acci\u00f3n a ejecutar usamos el par\u00e1metro <code>command</code>. Le asignamos el nombre de una funci\u00f3n o un m\u00e9todo:</p> <pre><code>boton.configure(command=mifuncion)\n</code></pre> <p>N\u00f3tese que asignamos el nombre de la funci\u00f3n sin par\u00e9ntesis, porque con ellos, estar\u00edamos ejecut\u00e1ndola y asignando su resultado.</p> <p>En nuestro ejemplo, asignamos el m\u00e9todo <code>destroy()</code> de la ventana, con lo que esta se cierra y finaliza el programa:</p> <pre><code>boton.configure(command=ventana.destroy)\n</code></pre>"},{"location":"015-01-Tkinter.html#acerca-de-tkinter","title":"Acerca de Tkinter","text":"<p>Tkinter es una biblioteca gr\u00e1fica  basada en la biblioteca Tk, concebida inicialmente para el lenguaje Tcl. No es una biblioteca espec\u00edfica de Python, y muchas de sus caracter\u00edsticas se derivan de sus origenes tan  peculiares. De todas formas, se incluye entre las herramientas Python desde las primeras versiones, y se ha ido convirtiendo en el est\u00e1ndar de facto.</p>"},{"location":"015-01-Tkinter.html#alternativas-a-tkinter","title":"Alternativas a tkinter","text":"<p>Entre las bibliotecas de terceros hay otras alternativas m\u00e1s  potentes que podemos instalar y usar en nuestros programas:</p> <ul> <li>PyQt</li> <li>PySide</li> <li>wxPython</li> <li>Kivy</li> <li>Toga</li> </ul> <p>V\u00e9ase Wiki de Python para obtener una lista m\u00e1s amplia.</p>"},{"location":"015-01-Tkinter.html#ejecutar-aplicaciones-sin-ventana-de-consola","title":"Ejecutar aplicaciones sin ventana de consola","text":"<p>Cuando ejecutamos un programa Python, este se muestra en una ventana de texto. Y en el caso de programas tkinter, se abren dos ventanas, la consola, y la gr\u00e1fica.</p> <p>Para evitar la ventana de texto, debemos empaquetar el programa en formato binario nativo, independiente del int\u00e9rprete de Python. Se hace con herramientas especiales, tales como:</p> <ul> <li>py2exe genera archivos ejecutables Windows</li> <li>py2app genera archivos ejecutables Mac</li> <li>pyinstaller es v\u00e1lido para Windows, MacOS X, y Linux</li> <li>Python for Android genera archivos binarios que pueden ejecutarse en Android.</li> </ul> <p>De todas formas, esto va m\u00e1s all\u00e1 del prop\u00f3sito de este cuaderno.</p>"},{"location":"015-02-Tkinter-colores.html","title":"Colores en tkinter","text":""},{"location":"015-02-Tkinter-colores.html#seleccionar-color-de-fondo","title":"Seleccionar color de fondo","text":"<p>Vamos a crear un panel cuyo color de fondo pueda cambiarse a voluntad. El color seleccionado se mostrar\u00e1 en la barra de t\u00edtulo:</p> <p></p> <p>El color se muestra en forma de c\u00f3digos. En el ejemplo, un color azulado se  muestra como:</p> <pre><code>( (166,253,255) , '#a6fdff' )\n</code></pre>"},{"location":"015-02-Tkinter-colores.html#codigos-de-colores","title":"C\u00f3digos de colores","text":"<p>\u00bfQue significan los c\u00f3digos? Todo color es una combinaci\u00f3n de tres b\u00e1sicos,  rojo, verde y azul. A este esquema se le llama RGB, abreviatura de  red, green, blue. La cantidad que pongamos de cada color b\u00e1sico determina el color final, y se expresa en forma de tupla:</p> <pre><code>(166,253,255)\n</code></pre> <p>Los valores individuales van de 0 a 255. Con esto tenemos 256 posibles tonalidades para cada color b\u00e1sico, lo que hace m\u00e1s de diecis\u00e9is millones de combinaciones, suficiente para mostrar una amplia gama de colores.</p> <p>En Tkinter, los colores se expresan mediante una tupla de dos elementos:</p> <ul> <li>una tupla anidada con los tres colores b\u00e1sicos: <code>(166,253,255)</code></li> <li> <p>un string formado por seis d\u00edgitos hexadecimales, dos por cada color b\u00e1sico:     <code>'#a6fdff'</code>:</p> <ul> <li>166 es la cantidad de rojo, en hexadecimal, A6</li> <li>253 es la cantidad de verde, en hexadecimal, FD</li> <li>255 es la cantidad de azul, en hexadecimal, FF</li> </ul> <p>El conjunto lleva el prefijo <code>#</code>, y lo podemos escribir en min\u00fasculas.</p> </li> </ul> <p>Veamos varios ejemplos de colores:</p> Color Rojo Verde Azul C\u00f3digo hex rojo 255 0 0 <code>#FF0000</code> verde 0 255 0 <code>#00FF00</code> azul 0 0 255 <code>#0000FF</code> amarillo 255 255 0 <code>#FFFF00</code> cian 0 255 255 <code>#00FFFF</code> fucsia 255 0 255 <code>#FF00FF</code> negro 0 0 0 <code>#000000</code> gris 128 128 128 <code>#808080</code> gris claro 192 192 192 <code>#C0C0C0</code> blanco 255 255 255 <code>#FFFFFF</code> marr\u00f3n 128 0 0 <code>#800000</code> verde oscuro 0 128 0 <code>#008000</code> azul oscuro 0 0 128 <code>#000080</code> dorado 128 128 0 <code>#808000</code> p\u00farpura 128 0 128 <code>#800080</code> verde azulado 0 128 128 <code>#008080</code> <p>Poniendo las mismas cantidades de color para cada uno de los b\u00e1sicos, vamos de  (0,0,0) a (255,255,255), con lo que obtenemos una gama de 256 grises.</p>"},{"location":"015-02-Tkinter-colores.html#el-programa","title":"El programa","text":"<p>Nuestro programa es el siguiente:</p> SeleccionarColor.py<pre><code>from tkinter import *\nfrom tkinter import colorchooser\n\ndef cambiar_color():\n    color=colorchooser.askcolor()\n    if color[1] != None:\n        lienzo.configure(bg=color[1])\n        ventana.title(\"Color:\"+str(color))\n\nventana = Tk()\n\nlienzo= Canvas(ventana)\nlienzo.configure(width=500)\nlienzo.configure(height=300)\nlienzo.configure(bg='AntiqueWhite')\nlienzo.pack()\n\npanelBotones = Frame(ventana)\npanelBotones.pack()\n\nbtnTerminar=Button(panelBotones)\nbtnTerminar.configure(text=\"Terminar\")\nbtnTerminar.configure(command=ventana.destroy)\nbtnTerminar.pack(side='left')\n\nbtnColores=Button(panelBotones)\nbtnColores.configure(text=\"Cambiar color\")\nbtnColores.configure(command=cambiar_color)\nbtnColores.pack(side='left')\n\nventana.title(\"Color:\"+lienzo[\"background\"])\nventana.mainloop()\n</code></pre>"},{"location":"015-02-Tkinter-colores.html#explicacion-del-programa","title":"Explicaci\u00f3n del programa","text":"<p>Hemos creado dos botones y un marco para alojarlos:</p> <pre><code>panelBotones = Frame(ventana)\nbtnTerminar=Button(panelBotones)\nbtnColores=Button(panelBotones)\n</code></pre> <p>Los botones se \"empaquetan\" dejando el anterior a su izquierda. Por defecto, se situar\u00edan en vertical:</p> <pre><code>btnTerminar.pack(side='left')\n</code></pre> <p>El bot\u00f3n para cambiar el color, invoca una funci\u00f3n llamada <code>cambiar_color()</code>.  Como de costumbre, la especificamos sin par\u00e9ntesis para evitar que se ejecute y se asigne el resultado.</p> <pre><code>btnColores.configure(command=cambiar_color)\n</code></pre> <p>La sentencia:</p> <pre><code>from tkinter import colorchooser\n</code></pre> <p>importa un subm\u00f3dulo de Tkinter. Dentro de una biblioteca puede haber varios m\u00f3dulos.</p> <p>La sentencia:</p> <pre><code>color=colorchooser.askcolor()\n</code></pre> <p>Muestra una ventana para seleccionar colores, y devuelve una tupla de dos  elementos. El primero es, a su vez, una tupla con los  tres colores b\u00e1sicos, rojo, verde y azul, como ya hemos visto. El segundo  elemento de la tupla es el string que tenemos que asignar:</p> <pre><code>lienzo.configure(bg=color[1])\n</code></pre>"},{"location":"015-02-Tkinter-colores.html#nombres-de-colores","title":"Nombres de colores","text":"<p>En tkinter podemos usar c\u00f3digos de color o nombres de colores:</p> <pre><code>lienzo.configure(bg='white')\nlienzo.configure(bg='#FFFFFF')\n</code></pre> <p>Podemos averiguar el c\u00f3digo que se corresponde con cada nombre examinando la  documentaci\u00f3n de la biblioteca Tk:</p> <p>https://www.tcl-lang.org/man/tcl/TkCmd/colors.html</p> <p>Podemos obtener una paleta de colores con un programa que he encontrado navegando por Internet:</p> <p></p> <p>El programa es el siguiente:</p> Tk_paleta.py<pre><code>import tkinter as tk\n\nCOLORES = ['snow', 'ghost white', 'white smoke', 'gainsboro', 'floral white', \n           'old lace', 'linen', 'antique white', 'papaya whip', 'blanched almond',\n           'bisque', 'peach puff', 'navajo white', 'lemon chiffon', 'mint cream',\n           'azure', 'alice blue', 'lavender', 'lavender blush', 'misty rose', \n           'dark slate gray', 'dim gray', 'slate gray', 'light slate gray', 'gray',\n           'light gray', 'midnight blue', 'navy', 'cornflower blue', 'dark slate blue',\n           'slate blue', 'medium slate blue', 'light slate blue', 'medium blue', \n           'royal blue',  'blue', 'dodger blue', 'deep sky blue', 'sky blue', \n           'light sky blue', 'steel blue', 'light steel blue', 'light blue', \n           'powder blue', 'pale turquoise', 'dark turquoise', 'medium turquoise',\n           'turquoise', 'cyan', 'light cyan', 'cadet blue', 'medium aquamarine', \n           'aquamarine', 'dark green', 'dark olive green', 'dark sea green', \n           'sea green', 'medium sea green', 'light sea green', 'pale green', \n           'spring green', 'lawn green', 'medium spring green', 'green yellow', \n           'lime green', 'yellow green', 'forest green', 'olive drab', 'dark khaki',\n           'khaki', 'pale goldenrod', 'light goldenrod yellow', 'light yellow', \n           'yellow', 'gold', 'light goldenrod', 'goldenrod', 'dark goldenrod', \n           'rosy brown', 'indian red', 'saddle brown', 'sandy brown', 'dark salmon', \n           'salmon', 'light salmon', 'orange', 'dark orange', 'coral', 'light coral', \n           'tomato', 'orange red', 'red', 'hot pink', 'deep pink', 'pink', 'light pink',\n          'pale violet red', 'maroon', 'medium violet red', 'violet red',\n          'medium orchid', 'dark orchid', 'dark violet', 'blue violet', 'purple', \n          'medium purple', 'thistle', 'snow2', 'snow3', 'snow4', 'seashell2', \n          'seashell3', 'seashell4', 'AntiqueWhite1', 'AntiqueWhite2',\n          'AntiqueWhite3', 'AntiqueWhite4', 'bisque2', 'bisque3', 'bisque4', \n          'PeachPuff2', 'PeachPuff3', 'PeachPuff4', 'NavajoWhite2', 'NavajoWhite3', \n          'NavajoWhite4', 'LemonChiffon2', 'LemonChiffon3', 'LemonChiffon4', \n          'cornsilk2', 'cornsilk3', 'cornsilk4', 'ivory2', 'ivory3', 'ivory4', \n          'honeydew2', 'honeydew3', 'honeydew4', 'LavenderBlush2', 'LavenderBlush3', \n          'LavenderBlush4', 'MistyRose2', 'MistyRose3', 'MistyRose4', 'azure2', \n          'azure3', 'azure4', 'SlateBlue1', 'SlateBlue2', 'SlateBlue3',\n          'SlateBlue4', 'RoyalBlue1', 'RoyalBlue2', 'RoyalBlue3', 'RoyalBlue4', \n          'blue2', 'blue4', 'DodgerBlue2', 'DodgerBlue3', 'DodgerBlue4', 'SteelBlue1', \n          'SteelBlue2', 'SteelBlue3', 'SteelBlue4', 'DeepSkyBlue2', 'DeepSkyBlue3', \n          'DeepSkyBlue4', 'SkyBlue1', 'SkyBlue2', 'SkyBlue3', 'SkyBlue4', \n          'LightSkyBlue1', 'LightSkyBlue2', 'LightSkyBlue3', 'LightSkyBlue4', \n          'Slategray1', 'Slategray2', 'Slategray3', 'Slategray4', 'LightSteelBlue1', \n          'LightSteelBlue2', 'LightSteelBlue3', 'LightSteelBlue4', 'LightBlue1', \n          'LightBlue2', 'LightBlue3', 'LightBlue4', 'LightCyan2', 'LightCyan3', \n          'LightCyan4', 'PaleTurquoise1', 'PaleTurquoise2', 'PaleTurquoise3', \n          'PaleTurquoise4', 'CadetBlue1', 'CadetBlue2', 'CadetBlue3', 'CadetBlue4', \n          'turquoise1', 'turquoise2', 'turquoise3', 'turquoise4', 'cyan2', 'cyan3',\n          'cyan4', 'DarkSlategray1', 'DarkSlategray2', 'DarkSlategray3', 'DarkSlategray4',\n          'aquamarine2', 'aquamarine4', 'DarkSeaGreen1', 'DarkSeaGreen2', 'DarkSeaGreen3',\n          'DarkSeaGreen4', 'SeaGreen1', 'SeaGreen2', 'SeaGreen3', 'PaleGreen1', \n          'PaleGreen2', 'PaleGreen3', 'PaleGreen4', 'SpringGreen2', 'SpringGreen3', \n          'SpringGreen4', 'green2', 'green3', 'green4', 'chartreuse2', 'chartreuse3', \n          'chartreuse4',  'OliveDrab1', 'OliveDrab2', 'OliveDrab4', 'DarkOliveGreen1', \n          'DarkOliveGreen2', 'DarkOliveGreen3', 'DarkOliveGreen4', 'khaki1', 'khaki2', \n          'khaki3', 'khaki4', 'LightGoldenrod1', 'LightGoldenrod2', 'LightGoldenrod3', \n          'LightGoldenrod4', 'LightYellow2', 'LightYellow3', 'LightYellow4', 'yellow2', \n          'yellow3', 'yellow4', 'gold2', 'gold3', 'gold4', 'goldenrod1', 'goldenrod2', \n          'goldenrod3', 'goldenrod4',  'DarkGoldenrod1', 'DarkGoldenrod2', 'DarkGoldenrod3', \n          'DarkGoldenrod4', 'RosyBrown1', 'RosyBrown2', 'RosyBrown3', 'RosyBrown4', \n          'IndianRed1', 'IndianRed2', 'IndianRed3', 'IndianRed4', 'sienna1', 'sienna2', \n          'sienna3', 'sienna4', 'burlywood1', 'burlywood2', 'burlywood3', 'burlywood4', \n          'wheat1', 'wheat2', 'wheat3', 'wheat4', 'tan1', 'tan2', 'tan4', 'chocolate1', \n          'chocolate2', 'chocolate3', 'firebrick1', 'firebrick2', 'firebrick3', \n          'firebrick4', 'brown1', 'brown2', 'brown3', 'brown4', 'salmon1', 'salmon2',\n          'salmon3', 'salmon4', 'LightSalmon2', 'LightSalmon3', 'LightSalmon4', 'orange2',\n          'orange3', 'orange4', 'DarkOrange1', 'DarkOrange2', 'DarkOrange3', 'DarkOrange4',\n          'coral1', 'coral2', 'coral3', 'coral4', 'tomato2', 'tomato3', 'tomato4', \n          'OrangeRed2', 'OrangeRed3', 'OrangeRed4', 'red2', 'red3', 'red4', 'DeepPink2', \n          'DeepPink3', 'DeepPink4', 'HotPink1', 'HotPink2', 'HotPink3', 'HotPink4', \n          'pink1', 'pink2', 'pink3', 'pink4', 'LightPink1', 'LightPink2', 'LightPink3', \n          'LightPink4', 'PaleVioletRed1', 'PaleVioletRed2', 'PaleVioletRed3', \n          'PaleVioletRed4', 'maroon1', 'maroon2', 'maroon3', 'maroon4', 'VioletRed1', \n          'VioletRed2', 'VioletRed3', 'VioletRed4', 'magenta2', 'magenta3', 'magenta4', \n          'orchid1', 'orchid2', 'orchid3', 'orchid4', 'plum1',\n          'plum2', 'plum3', 'plum4', 'MediumOrchid1', 'MediumOrchid2', 'MediumOrchid3',\n          'MediumOrchid4', 'DarkOrchid1', 'DarkOrchid2', 'DarkOrchid3', 'DarkOrchid4',\n          'purple1', 'purple2', 'purple3', 'purple4', 'MediumPurple1', 'MediumPurple2',\n          'MediumPurple3', 'MediumPurple4', 'thistle1', 'thistle2', 'thistle3', 'thistle4',\n          'grey1', 'grey2', 'grey3', 'grey4', 'grey5', 'grey6', 'grey7', 'grey8', 'grey9', 'grey10',\n          'grey11', 'grey12', 'grey13', 'grey14', 'grey15', 'grey16', 'grey17', 'grey18', 'grey19',\n          'grey20', 'grey21', 'grey22', 'grey23', 'grey24', 'grey25', 'grey26', 'grey27', 'grey28',\n          'grey29', 'grey30', 'grey31', 'grey32', 'grey33', 'grey34', 'grey35', 'grey36', 'grey37',\n          'grey38', 'grey39', 'grey40', 'grey42', 'grey43', 'grey44', 'grey45', 'grey46', 'grey47',\n          'grey48', 'grey49', 'grey50', 'grey51', 'grey52', 'grey53', 'grey54', 'grey55', 'grey56',\n          'grey57', 'grey58', 'grey59', 'grey60', 'grey61', 'grey62', 'grey63', 'grey64', 'grey65',\n          'grey66', 'grey67', 'grey68', 'grey69', 'grey70', 'grey71', 'grey72', 'grey73', 'grey74',\n          'grey75', 'grey76', 'grey77', 'grey78', 'grey79', 'grey80', 'grey81', 'grey82', 'grey83',\n          'grey84', 'grey85', 'grey86', 'grey87', 'grey88', 'grey89', 'grey90', 'grey91', 'grey92',\n          'grey93', 'grey94', 'grey95', 'grey97', 'grey98', 'grey99']\n\nclass Cuadricula(tk.Frame):\n\n    MAX_FILAS = 41\n\n    TAMA\u00d1O_FUENTE = 12\n\n    def __init__(self, ventana):\n        tk.Frame.__init__(self, ventana)\n        fila = 0\n        columna = 0\n        panel = tk.Frame(ventana)\n        lumcheck = 32768\n\n        for color in COLORES:\n            etiqueta = tk.Label(self, text=color, bg=color,\n                                width=17,\n                                font=(\"Times\",\n                                self. TAMA\u00d1O_FUENTE, \"bold\"))\n\n            colorlum = int(sum(ventana. winfo_rgb(color))/3)\n            if colorlum &gt; lumcheck:\n                etiqueta.configure(fg=\"grey4\")\n            else:\n                etiqueta.configure(fg=\"snow\")\n\n            etiqueta.grid(row=fila, column=columna, sticky=\"ew\")\n            fila += 1\n            if fila &gt; self.MAX_FILAS:\n                fila = 0\n                columna += 1\n\nventana = tk.Tk()\nalto = ventana.winfo_screenheight()\nancho = ventana.winfo_screenwidth()\nventana.geometry(str(ancho) + \"x\" + str(alto))\nventana.title(\"Nombres de colores tkinter\")\n\nc = Cuadricula(ventana)\nc.pack(expand=1, fill=\"both\")\n\nventana.mainloop()\n</code></pre>"},{"location":"015-03-Tkinter-coordenadas.html","title":"Coordenadas","text":"<p>Todo lo que pongamos en un Canvas, y en general, en una ventana, se sit\u00faa en una posici\u00f3n que podemos establecer mediante unas coordenadas x, y. </p> <p>La primera coordenada <code>x</code> se refiere a la distancia respecto al margen izquierdo, medida en pixels (puntos). La segunda coordenada <code>y</code> es la distancia vertical respecto al margen superior. El punto 0,0 es la esquina superior izquierda.</p> <p>El siguiente programa muestra un Canvas y un texto en el margen inferior de la ventana. Cada vez que pulsamos sobre el Canvas con el rat\u00f3n, en la barra  inferior se muestran las coordenadas:</p> Coordenadas.py<pre><code>import tkinter as tk\n\nventana = tk.Tk()\nventana.title(\"Obtener coordenadas\")\n\nlienzo= tk.Canvas(ventana)\nlienzo.configure(width=1000)\nlienzo.configure(height=600)\nlienzo.configure(bg='AntiqueWhite')\nlienzo.pack()\n\netiqueta=tk.Label(ventana)\netiqueta.configure(text=\"\")\netiqueta.pack()\n\ndef mostrar_posicion(evento):\n    x, y = evento.x, evento.y\n    etiqueta.configure(text=f'{x}, {y}')\n\nlienzo.bind('&lt;Button&gt;', mostrar_posicion)\n\nventana.mainloop()\n</code></pre> <p>El texto inferior es un objeto de la clase Label. Inicialmente muestra un texto en blanco:</p> <pre><code>etiqueta.configure(text=\"\")\n</code></pre> <p>Todos los objetos pueden tener eventos. Ligamos el evento <code>&lt;Button&gt;</code> del objeto Canvas, que se genera cada vez que pulsamos con el rat\u00f3n,  a la ejecuci\u00f3n de la funci\u00f3n <code>mostrar_posicion</code>. Esta recibe informaci\u00f3n sobre el evento:</p> <pre><code>def mostrar_posicion(evento):\n</code></pre> <p>Esta variable  <code>evento</code> recoge un objeto de la clase:</p> <pre><code>&lt;class 'tkinter.Event'&gt;\n</code></pre> <p>Tiene dos propiedades x,y con las coordenadas. Las mostramos cambiando el texto de la barra inferior:</p> <pre><code>etiqueta.configure(text=f'{x}, {y}')\n</code></pre> <p>La sentencia:</p> <pre><code>ventana.mainloop()\n</code></pre> <p>Se encarga de gestionar los eventos y llamar a las funciones que hemos asociado a los mismos.</p>"},{"location":"015-04-Tkinter-dibujar.html","title":"Dibujar con tkinter","text":"<p>En este cap\u00edtulo vamos a hacer algunos dibujos en un Canvas.</p>"},{"location":"015-04-Tkinter-dibujar.html#dibujar-linea","title":"Dibujar l\u00ednea","text":"<p>Una l\u00ednea se dibuja con el m\u00e9todo <code>create_line()</code>. se le pasan las coordenadas  de ambos extremos</p> Linea.py<pre><code>import tkinter as tk\n\nventana = tk.Tk()\nlienzo= tk.Canvas(ventana, width=600, height=400)\nlienzo.pack()\n\nlienzo.create_line(10,10,550,390)\nventana.mainloop()\n</code></pre> <p>Lo que muestra:</p> <p></p>"},{"location":"015-04-Tkinter-dibujar.html#dibujar-rectangulo","title":"Dibujar rect\u00e1ngulo","text":"<p>Un rect\u00e1ngulo se dibuja con el m\u00e9todo <code>create_rectangle()</code>. Las coordenadas se refieren a la esquina superior izquierda y la inferior derecha:</p> Rectangulo.py<pre><code>import tkinter as tk\n\nventana = tk.Tk()\nlienzo= tk.Canvas(ventana, width=500, height=300)\nlienzo.pack()\n\nlienzo.create_rectangle(100,100,300,200)\nventana.mainloop()\n</code></pre> <p>Muestra:</p> <p></p>"},{"location":"015-04-Tkinter-dibujar.html#cuadros-al-azar","title":"Cuadros al azar","text":"<p>Vamos a dibujar 100 cuadros al azar:</p> <p></p> <p>El programa es:</p> Cuadros_azar.py<pre><code>import tkinter as tk\nimport random as r\n\nventana = tk.Tk()\nancho=1000\nalto=600\n\nlienzo= tk.Canvas(ventana, width=ancho, height=alto)\nlienzo.pack()\n\nfor x in range(0,100):\n    x1 = r.randrange(ancho)\n    y1 = r.randrange(alto)\n\n    ancho_max = ancho-x1\n    alto_max = alto-y1\n\n    x2 = x1 + r.randrange(0,ancho_max)\n    y2 = y1 + r.randrange(0,alto_max)\n\n    lienzo.create_rectangle(x1, y1, x2, y2)\n\nventana.mainloop()\n</code></pre> <p>Usamos un bucle <code>for</code> para recorrer una secuencia de 0 a 99. Las coordenadas x,y de cada cuadro se obtienen mediante una llamada a la funci\u00f3n <code>randrange(n)</code> del m\u00f3dulo <code>random</code>. Esta funci\u00f3n devuelve un valor entre 0 y n:</p> <pre><code>x1 = randrange(ancho)\ny1 = randrange(alto)\n</code></pre> <p>El ancho y alto m\u00e1ximos del cuadro se calculan restando las coordenadas obtenidas de las dimensiones del Canvas:</p> <pre><code>ancho_max = ancho-x1\nalto_max = alto-y1\n</code></pre> <p>Con otra llamada a <code>radrange()</code> se obtiene el ancho y alto del cuadro, lo que sumado a las coordenadas de la esquina superior, nos da las coordenadas de la inferior.</p>"},{"location":"015-04-Tkinter-dibujar.html#rectangulo-de-color","title":"Rect\u00e1ngulo de color","text":"<p>Para rellenar un rect\u00e1ngulo con un color, usar el par\u00e1metro <code>fill</code> en la llamada a <code>create_rectangle</code>:</p> Rectangulo2.py<pre><code>import tkinter as tk\n\nventana = tk.Tk()\nlienzo= tk.Canvas(ventana, width=500, height=300)\nlienzo.pack()\n\nlienzo.create_rectangle(100,100,300,200, fill=\"#008080\")\nventana.mainloop()\n</code></pre> <p></p>"},{"location":"015-04-Tkinter-dibujar.html#color-y-grosor-de-linea","title":"Color y grosor de l\u00ednea","text":"<p>Al dibujar una l\u00ednea, el color y grosor en pixels se determina mediante:</p> <pre><code>lienzo.create_line(10,10,500,300, fill=\"red\", width=10)\n</code></pre> <p>Los valores por defecto son 'black' y 1</p> <p>En los rect\u00e1ngulos, se usa <code>fill</code> para el color interior, <code>outline</code> para el color del marco, y <code>width</code> para su grosor:</p> <pre><code>lienzo.create_rectangle(100,100,300,200, fill=\"#008080\", outline=\"red\", width=5)\n</code></pre>"},{"location":"015-04-Tkinter-dibujar.html#arcos","title":"Arcos","text":"<p>Un arco es un fragmento de circunferencia u ovalo. Se crea con la funci\u00f3n:</p> <pre><code>lienzo.create_arc()\n</code></pre> <p>Por ejemplo:</p> Arco.py<pre><code>import tkinter as tk\n\nventana = tk.Tk()\nlienzo= tk.Canvas(ventana, width=1000, height=600)\nlienzo.pack()\n\nlienzo.create_arc(10,10,             # coordenadas esquina\n                  500,300,           # ancho y alto\n                  extent=90,         # grados del arco\n                  start=45,          # punto de inicio\n                  style=tk.PIESLICE, # tipo: ARC, CHORD, PIESLICE\n                  width=5,           # grosor l\u00ednea\n                  outline='red',     # color l\u00ednea\n                  fill='green'       # color \u00e1rea\n                  )\n\nventana.mainloop()\n</code></pre> <p>Muestra:</p> <p></p> <p>El ancho y alto se refiere al \u00e1rea ocupada por el ovalo completo. El dibujo se inicia a los 45 grados, y se va dibujando en sentido contrario a las agujas del reloj, completando 90 grados de arco.</p> <p>El estilo puede ser:</p> <ul> <li>ARC - dibuja solo la l\u00ednea</li> <li>PIESLICE - dibuja el area desde el centro del ovalo, como vemos en el ejemplo</li> <li> <p>CHORD - como PIESLICE, pero uniendo los dos extremos del arco con una l\u00ednea     recta:</p> <p></p> </li> </ul>"},{"location":"015-04-Tkinter-dibujar.html#poligonos","title":"Pol\u00edgonos","text":"<p>Un pol\u00edgono es una figura formada por n lados. Cada lado tiene dos coordenadas, la de inicio y la del final. El pol\u00edgono se define por una secuencia de coordenadas.</p> Poligono.py<pre><code>import tkinter as tk\n\nventana = tk.Tk()\nlienzo= tk.Canvas(ventana, width=600, height=400)\nlienzo.pack()\n\nlienzo.create_polygon(200,100,\n                      80,150,\n                      400,200,\n                      400,320,\n                      350,200,\n                      140,200,\n                      140,320,\n                      120,200,\n                      width=5,           # grosor l\u00ednea\n                      outline='red',     # color l\u00ednea\n                      fill='green'       # color \u00e1rea\n                  )\n\nventana.mainloop()\n</code></pre> <p>Si la \u00faltima coordenada no coincide con la primera, tkinter a\u00f1adir\u00e1 una coordenada adicional para completar la superficie:</p> <p></p>"},{"location":"015-05-Tkinter-textos.html","title":"Textos en un Canvas","text":"<p>Ya hemos visto que podemos crear un texto con</p> <pre><code>lienzo.create_texto(x,y, texto)\n</code></pre> <p>las coordenadas son, por defecto, las del centro del area imaginario ocupada por el texto. Por ejemplo:</p> Texto.py<pre><code>import tkinter as tk\n\nventana = tk.Tk()\nlienzo= tk.Canvas(ventana, width=300, height=200)\nlienzo.pack()\n\nx, y = 50, 50\n\nlienzo.create_text(x,y, text=\"Hola\")\nlienzo.create_rectangle(x-30,y-30,x+30,y+30)\n\nventana.mainloop()\n</code></pre> <p>Lo que muestra:</p> <p></p> <p>...de forma que, las coordenadas indicadas, vendr\u00edan a estar en el punto central del recuadro.</p> <p>Podemos establecer otro anclaje mediante el par\u00e1metro <code>anchor</code>. Por defecto  es:</p> <pre><code>lienzo.create_text(50,50, text=\"Hola\", anchor = None )\n</code></pre> <p>Para que las coordenadas sean</p> <ul> <li>Centro del margen superior del texto: <code>anchor=\"n\"</code></li> <li>Centro del margen inferior del texto: <code>anchor=\"s\"</code></li> <li>Centro del margen derecho del texto: <code>anchor=\"e\"</code></li> <li>Centro del margen izquierdo del texto: <code>anchor=\"w\"</code></li> </ul> <p>Los valores son las iniciales de north, south, east y west. Es la forma en que tkinter establece los anclajes. Podemos combinar valores:</p> <ul> <li><code>nw</code> - esquina superior izquierda</li> <li><code>ne</code>, <code>sw</code>, <code>se</code> - resto de esquinas</li> </ul> <p>Por ejemplo:</p> Anclajes.py<pre><code>import tkinter as tk\n\nventana = tk.Tk()\nlienzo= tk.Canvas(ventana, width=600, height=300)\nlienzo.pack()\n\nx = 100\ny = 50\n\nfor anclaje in [\"n\", \"s\", \"e\", \"w\"]:\n    lienzo.create_rectangle(x-1,y-1,x+1,y+1, fill=\"red\")\n    lienzo.create_text(x,y, text=\"Anchor \"+anclaje, anchor=anclaje)\n    x += 100\n\nx = 100\ny = 150\n\nfor anclaje in [\"ne\", \"se\", \"nw\", \"sw\"]:\n    lienzo.create_rectangle(x-1,y-1,x+1,y+1, fill=\"red\")\n    lienzo.create_text(x,y, text=\"Anchor \"+anclaje, anchor=anclaje)\n    x += 100\n\nventana.mainloop()\n</code></pre> <p>Lo que muestra las coordenadas como un punto rojo:</p> <p></p> <p>Po0r ejemplo, si queremos que las coordenadas se refieran a la esquina superior izquierda del area ocupada por el texto, tenemos que especificar <code>anchor=\"nw\"</code> </p>"},{"location":"015-05-Tkinter-textos.html#tipo-de-letra","title":"Tipo de letra","text":"<p>El argumento font es una tupla con tipo de letra, tama\u00f1o y modificadores</p> Fuentes.py<pre><code>import tkinter as tk\n\nventana = tk.Tk()\nlienzo= tk.Canvas(ventana, width=500, height=400)\nlienzo.pack()\n\nlienzo.create_text(30,10,  text=\"rojo\",         anchor=\"nw\", fill='red')\n\nlienzo.create_text(30,50,  text=\"Times 15\",     anchor=\"nw\", font=(\"Times\",15))\nlienzo.create_text(30,100, text=\"Helvetica 20\", anchor=\"nw\", font=(\"Helvetica\",20))\nlienzo.create_text(30,150, text=\"Courier 25\",   anchor=\"nw\", font=(\"Courier\",25))\n\nlienzo.create_text(30,200, text=\"Negrita\",      anchor=\"nw\", font=(\"Courier\",25,'bold'))\nlienzo.create_text(30,250, text=\"Cursiva\",      anchor=\"nw\", font=(\"Courier\",25,'italic'))\nlienzo.create_text(30,300, text=\"Subrayado\",    anchor=\"nw\", font=(\"Courier\",25,'underline'))\nlienzo.create_text(30,350, text=\"Tachado\",      anchor=\"nw\", font=(\"Courier\",25,'overstrike'))\n\nventana.mainloop()\n</code></pre> <p></p>"},{"location":"016-01-Tkinter-imagenes1.html","title":"Visualizar imagenes en tkinter","text":"<p>Vamos a crear un programa que permita visualizar archivos de im\u00e1genes.</p>"},{"location":"016-01-Tkinter-imagenes1.html#crear-ventana","title":"Crear ventana","text":"<p>Todas las funciones de nuestra aplicaci\u00f3n van a ser m\u00e9todos de una clase que representa la aplicaci\u00f3n:</p> Visor02.py<pre><code>import tkinter as tk\n\nclass App:\n    def __init__(self, ventana):\n        self.ventana = ventana                     # guarda una referencia a la ventana\n                                                   # como parte de la info que maneja la app\n\n        self.ventana.title('Visor de im\u00e1genes')    # accedemos a la ventana gracias a la\n        self.ventana.geometry('800x600')           # propiedad \"ventana\"\n\nventana = tk.Tk()    # Crea la ventana\nApp(ventana)         # Crea una instancia de la clase App\n                     # No la guardamos en ninguna variable porque no es necesario\nventana.mainloop()   # Inicia el gestor de eventos\n</code></pre> <p>Ejecutando esto, se muestra una ventana en blanco con un tama\u00f1o de 800x600  pixels y un t\u00edtulo \"Visor de im\u00e1genes\". </p>"},{"location":"016-01-Tkinter-imagenes1.html#geometria","title":"Geometr\u00eda","text":"<p>Podemos establecer las dimensiones de una ventana mediante:</p> <pre><code>ventana.geometry(geometr\u00eda)\n</code></pre> <p>La geometr\u00eda estable el ancho y alto del componente, en este caso, la ventana.  Opcionalmente podemos a\u00f1adir la posici\u00f3n en pantalla, todo  ello en una cadena de texto que tkinter analizar\u00e1. El formato es (sin espacios en blanco):</p> <pre><code>\"ancho x alto + x + y\"\n</code></pre> <p>siendo x,y las coordenadas donde de la esquina superior izquierda de la ventana  en el escritorio. Por ejemplo, una geometr\u00eda <code>'120x50-0+20'</code>  mostrar\u00e1 una ventana de 120 x 50 pixels, pegada al borde superior de la  pantalla, y desplazada 20 pixels respecto al margen derecho.</p>"},{"location":"016-01-Tkinter-imagenes1.html#anadir-paneles-y-botones","title":"A\u00f1adir paneles y botones","text":"<p>Vamos a a\u00f1adir un panel con dos botones, y debajo, un panel donde se visualizar\u00e1 la imagen:</p> Visor02.py<pre><code>import tkinter as tk\n\nclass App:\n    def __init__(self, ventana):\n        self.ventana = ventana\n        self.ventana.title('Visor de im\u00e1genes')\n        self.ventana.geometry('800x600')\n\n        # A\u00f1adir un panel para botones. Es un objeto dee la clase Frame\n        self.panelBotones = tk.Frame(self.ventana)\n        self.panelBotones.pack()\n\n        # A\u00f1adir un bot\u00f3n \"Salir\" al panel\n        self.btnSalir = tk.Button(self.panelBotones, text='Salir', command=self.ventana.destroy)\n        self.btnSalir.pack(side='left')\n\n        # A\u00f1adir un bot\u00f3n \"Abrir\" al panel\n        self.btnAbrir = tk.Button(self.panelBotones, text='Abrir')\n        self.btnAbrir.pack(side='left')\n\n        # A\u00f1adir un panel para mostrar la imagen\n\n        self.panelImagen = tk.Label(self.ventana)\n        self.panelImagen.pack()\n\n\nventana = tk.Tk()\nApp(ventana)\nventana.mainloop()\n</code></pre> <p>Lo que muestra:</p> <p></p> <p>El panel para mostrar la imagen es un objeto de la clase <code>Label</code>. En principio se usa para mostrar un texto, pero tambi\u00e9n sirve para mostrar una imagen.</p> <p>En el cap\u00edtulo siguiente veremos como cargar y mostrar la imagen.</p>"},{"location":"016-02-Tkinter-imagenes2.html","title":"Visualizar imagenes en tkinter (II)","text":"<p>Una vez creado el embri\u00f3n del programa, el siguiente paso es cargar y mostrar un archivo de imagen.</p>"},{"location":"016-02-Tkinter-imagenes2.html#bibliotecas","title":"Bibliotecas","text":"<p>Cuando pulsemos en el bot\u00f3n \"Abrir\", queremos que se muestre una ventana de di\u00e1logo para seleccionar la imagen a cargar. Usamos el m\u00f3dulo filedialog:</p> <pre><code>from tkinter import filedialog as dialogo\n</code></pre> <p>Para trabajar con im\u00e1genes, vamos a usar la biblioteca  Pillow. Importamos los m\u00f3dulos  <code>Image</code> e <code>ImageTk</code>.</p> <pre><code>from PIL import Image, ImageTk\n</code></pre> <p>El primero sirve para procesar im\u00e1genes. Pero <code>Pillow</code> y <code>Tkinter</code> son bibliotecas diferentes, y el m\u00f3dulo <code>ImageTk</code> crea im\u00e1genes en la memoria RAM que pueden mostrarse en una ventana Tkinter.</p>"},{"location":"016-02-Tkinter-imagenes2.html#cargar-imagen","title":"Cargar imagen","text":"<p>Todav\u00eda no hemos definido el comando a ejecutar al pulsar en el bot\u00f3n \"Abrir\".  Le vamos a asignar un m\u00e9todo de la propia aplicaci\u00f3n:</p> <pre><code>self.btnAbrir = tk.Button(self.panelBotones, text='Abrir', command=self.abrir)\n</code></pre> <p>y definimos el m\u00e9todo a ejecutar:</p> <pre><code>def abrir(self):\n    self.archivo = dialogo.askopenfilename()\n\n    try:\n        self.imagen = Image.open(self.archivo)\n    except:\n        return\n\n    self.mostrar()\n\ndef mostrar(self):\n    self.tk_imagen = ImageTk.PhotoImage(self.imagen)\n    self.panelImagen.configure(image=self.tk_imagen)\n</code></pre> <p>V\u00e9ase que obtenemos el nombre del archivo y lo guardamos como propiedad  de la aplicaci\u00f3n:</p> <pre><code>self.archivo = dialogo.askopenfilename()\n</code></pre> <p>Conocido el nombre del archivo, intentamos cargarlo y guardamos la imagen  resultante como propiedad de la aplicaci\u00f3n:</p> <pre><code>self.imagen = Image.open(self.archivo)\n</code></pre> <p>Seguidamente vamos a mostrarlo. Esta tarea la hacemos en un m\u00e9todo aparte al  que llamaremos <code>mostrar()</code>. Usamos el m\u00f3dulo <code>ImageTk</code> de la biblioteca  <code>Pillow</code> para obtener una imagen utilizable por Tkinter:</p> <pre><code>self.tk_imagen = ImageTk.PhotoImage(self.imagen)\n</code></pre> <p>y se lo asignamos al panel: </p> <pre><code>self.panelImagen.configure(image=self.tk_imagen)\n</code></pre> <p>CXon lo que, en la memoria RAM, tenemos dos im\u00e1genes:</p> <ul> <li>un objeto Imagen propio de la biblioteca Pillow</li> <li>un objeto ImageTk.PhotoImage adaptado a Tkinter</li> </ul> <p>El programa completo:</p> Visor03.py<pre><code>import tkinter as tk\nfrom tkinter import filedialog\nfrom PIL import Image, ImageTk\n\nclass App:\n    def __init__(self, ventana):\n        self.ventana = ventana\n        self.ventana.title('Visor de im\u00e1genes')\n        self.ventana.geometry('800x600')\n\n        # A\u00f1adir un panel para botones\n        self.panelBotones = tk.Frame(self.ventana)\n        self.panelBotones.pack()\n\n        # A\u00f1adir un bot\u00f3n \"Salir\"\n        self.btnSalir = tk.Button(self.panelBotones, text='Salir', command=self.ventana.destroy)\n        self.btnSalir.pack(side='left')\n\n        # A\u00f1adir un bot\u00f3n \"Abrir\"\n        self.btnAbrir = tk.Button(self.panelBotones, text='Abrir', command=self.abrir)\n        self.btnAbrir.pack(side='left')\n\n        # A\u00f1adir un panel para mostrar la imagen\n        self.panelImagen = tk.Label(self.ventana)\n        self.panelImagen.pack()\n\n    def abrir(self):\n        self.archivo = filedialog.askopenfilename()\n\n        try:\n            self.imagen = Image.open(self.archivo)\n        except:\n            return\n\n        self.mostrar()\n\n    def mostrar(self):\n        self.tk_imagen = ImageTk.PhotoImage(self.imagen)\n        self.panelImagen.configure(image=self.tk_imagen)\n\nventana = tk.Tk()\nApp(ventana)\nventana.mainloop()\n</code></pre>"},{"location":"016-03-Tkinter-imagenes3.html","title":"Control de errores","text":"<p>Al abrir un archivo se pueden producir errores. Vamos a introducir algunos cambios en el programa:</p> Visor04.py<pre><code>import tkinter as tk\nfrom tkinter import filedialog\nfrom tkinter import messagebox\nfrom PIL import Image, ImageTk\n\n\nclass App:\n    def __init__(self, ventana):\n        self.ventana = ventana\n        self.ventana.title('Visor de im\u00e1genes')\n        self.ventana.geometry('800x600')\n\n        # A\u00f1adir un panel para botones\n        self.panelBotones = tk.Frame(self.ventana)\n        self.panelBotones.pack()\n\n        # A\u00f1adir un bot\u00f3n \"Salir\"\n        self.btnSalir = tk.Button(self.panelBotones, text='Salir', command=self.ventana.destroy)\n        self.btnSalir.pack(side='left')\n\n        # A\u00f1adir un bot\u00f3n \"Abrir\"\n        self.btnAbrir = tk.Button(self.panelBotones, text='Abrir', command=self.abrir)\n        self.btnAbrir.pack(side='left')\n\n        # A\u00f1adir un panel para mostrar la imagen\n        self.panelImagen = tk.Label(self.ventana)\n        self.panelImagen.pack()\n\n    def abrir(self):\n        tipos_archivos= [\n                        (\"Todos\", \"*.*\"),\n                        (\"JPEG\" , \".jpg\"),\n                        (\"PNG\"  , \".png\"),\n                        (\"GIF\"  , \".gif\")\n                                      ]\n        self.archivo = filedialog.askopenfilename(\n                                  defaultextension=\".jpg\",\n                                  filetypes=tipos_archivos\n                                  )\n\n        if not self.archivo:\n            return\n\n        try:\n            self.imagen = Image.open(self.archivo)\n        except:\n            messagebox.showerror(\"Error\", \"Error abriendo archivo\")\n\n        self.mostrar()\n\n    def mostrar(self):\n        self.tk_imagen = ImageTk.PhotoImage(self.imagen)\n        self.panelImagen.configure(image=self.tk_imagen)\n\nventana = tk.Tk()\nApp(ventana)\nventana.mainloop()\n</code></pre> <p>Al m\u00e9todo <code>filedialog.askopenfilename</code> le hemos a\u00f1adido dos argumentos para establecer unos filtros que permitan seleccionar solos los ficheros de im\u00e1genes en la ventana de di\u00e1logo.</p> <p>Con las sentencias</p> <pre><code>if not self.archivo:\n    return\n</code></pre> <p>Controlamos que el archivo seleccionado est\u00e1 en blanco, es decir, que el usuario ha cerrado la ventana de di\u00e1logo pulsando en el bot\u00f3n <code>[cancelar]</code> .</p> <p>En el apartado <code>except</code> de la sentencia <code>try</code>, establecemos que, si se produce un error abriendo el archivo, se muestre un mensaje de error. Usamos el m\u00f3dulo <code>messagebox</code> de Tkinter, que tiene una funci\u00f3n <code>showerror()</code>, cuyo cometido es mostrar una ventana con un mensaje de error. El primer argumento es el t\u00edtulo de la ventana:</p> <p></p>"},{"location":"016-04-Tkinter-imagenes4.html","title":"Ajustar imagenes","text":"<p>En el caso de cargar una imagen grande, se visualizar\u00e1 solo parte de ella.  En ese caso, ajustaremos el tama\u00f1o de las imagen, una vez cargada en la  memoria RAM, para que quepa en la ventana:</p> Visor04.py<pre><code>import tkinter as tk\nfrom tkinter import filedialog\nfrom tkinter import messagebox\nfrom PIL import Image, ImageTk\n\n\nclass App:\n    def __init__(self, ventana):\n        self.ventana = ventana\n        self.ventana.title('Visor de im\u00e1genes')\n        self.ventana.geometry('800x600')\n\n        # A\u00f1adir un panel para botones\n        self.panelBotones = tk.Frame(self.ventana)\n        self.panelBotones.pack()\n\n        # A\u00f1adir un bot\u00f3n \"Salir\"\n        self.btnSalir = tk.Button(self.panelBotones, text='Salir', command=self.ventana.destroy)\n        self.btnSalir.pack(side='left')\n\n        # A\u00f1adir un bot\u00f3n \"Abrir\"\n        self.btnAbrir = tk.Button(self.panelBotones, text='Abrir', command=self.abrir)\n        self.btnAbrir.pack(side='left')\n\n        # A\u00f1adir un panel para mostrar la imagen\n        self.panelImagen = tk.Label(self.ventana)\n        self.panelImagen.pack()\n\n    def abrir(self):\n        tipos_archivos= [\n                        (\"Todos\", \"*.*\"),\n                        (\"JPEG\" , \".jpg\"),\n                        (\"PNG\"  , \".png\"),\n                        (\"GIF\"  , \".gif\")\n                                      ]\n        self.archivo = filedialog.askopenfilename(\n                                  defaultextension=\".jpg\",\n                                  filetypes=tipos_archivos\n                                  )\n\n        if not self.archivo:\n            return\n\n        try:\n            self.imagen = Image.open(self.archivo)\n        except:\n            messagebox.showerror(\"Error\", \"Error abriendo archivo\")\n\n        self.ajustar()\n        self.mostrar()\n\n    def ajustar(self):\n        ancho_imagen = self.imagen.width\n        alto_imagen = self.imagen.height\n        ancho_panel = ventana.winfo_width()\n        alto_panel = ventana.winfo_height() - self.panelBotones.winfo_height()\n        zoom_ancho = 1\n        zoom_alto = 1\n        if ancho_imagen &gt; ancho_panel:\n            zoom_ancho = ancho_panel/ancho_imagen\n        if alto_imagen &gt; alto_panel:\n            zoom_alto = alto_panel/alto_imagen\n        zoom = min(zoom_ancho,zoom_alto)\n        if zoom &lt; 1:\n            dimensiones = (\n                int(ancho_imagen*zoom),\n                int(alto_imagen*zoom)\n                )\n            self.imagen = self.imagen.resize(dimensiones)\n\n    def mostrar(self):\n        self.tk_imagen = ImageTk.PhotoImage(self.imagen)\n        self.panelImagen.configure(image=self.tk_imagen)\n\nventana = tk.Tk()\nApp(ventana)\nventana.mainloop()\n</code></pre> <p>Como paso previo a mostrar la imagen, invocamos la funci\u00f3n <code>ajustar()</code>. Las dimensiones de una imagen se obtienen con:</p> <pre><code>ancho_imagen = self.imagen.width\nalto_imagen = self.imagen.height\n</code></pre> <p>Las dimensiones de la ventana:</p> <pre><code>ancho_ventana = ventana.winfo_width()\nalto_ventana = ventana.winfo_height()\n</code></pre> <p>Las dimensiones del <code>Frame</code> que usamos como panel de botones:</p> <pre><code>ancho_panel = panelBotones.winfo_width()\nalto_panel = panelBotones.winfo_height()\n</code></pre> <p>El area restante para mostrar la imagen tiene las dimensiones:</p> <pre><code>ancho = ancho_ventana\nalto = alto_ventana - alto_panel\n</code></pre> <p>Para el c\u00e1lculo del zoom a aplicar, comparamos las dimensiones de la imagen y del espacio disponible. Una vez calculado el nuevo tama\u00f1o, ajustamos la  imagen con:</p> <pre><code>imagen.resize(dimensiones)\n</code></pre> <p>siendo el argumento una tupla de dos valores, ancho y alto. El m\u00e9todo <code>resize()</code> crea un nuevo objeto, por lo que tenemos que sobreescribir la variable:</p> <pre><code>imagen = imagen.resize(dimensiones)\n</code></pre>"},{"location":"017-01-Inicio.html","title":"Juego de bolas","text":"<p>Vamos a crear el cl\u00e1sico juego de una bola rebotando por la pantalla:</p> <p></p> <p>Usaremos las teclas Left y Right para mover la paleta y evitar que la  bola caiga hasta el borde inferior de la ventana. En la esquina inferior izquierda mostramos la puntuaci\u00f3n del juego, que se incrementar\u00e1 cada vez que la bola rebote en la paleta. A medida que aumente la puntuaci\u00f3n, el juego se ir\u00e1 acelerando.</p> <p>Vamos a desarrollar la aplicaci\u00f3n en una docena de pasos, a\u00f1adiendo mejoras en cada paso. Lo primero ser\u00e1 crear la ventana.</p>"},{"location":"017-01-Inicio.html#crear-ventana","title":"Crear ventana","text":"<p>El embri\u00f3n b\u00e1sico de nuestro juego muestra una ventana en blanco:</p> 01CrearVentana.py<pre><code>class Juego:\n    def __init__(self, ventana):\n        self.ventana = ventana\n\n        # Configurar ventana\n        self.ventana.title('Bola')\n        self.ventana.resizable(False, False)\n        self.ventana.wm_attributes('-topmost', True)\n\n        # Crear lienzo\n        self.lienzo = tkinter.Canvas(self.ventana,\n                                     width=500,\n                                     height=400,\n                                     bd=0)\n        self.lienzo.pack()\n        self.ventana.update()\n\n    def bucle(self):\n        while True:\n            self.ventana.update_idletasks()\n            self.ventana.update()\n\nv = tkinter.Tk()\njuego = Juego(v)\njuego.bucle()\njuego.ventana.update_idletasks()\njuego.ventana.destroy()\n</code></pre> <p>Comenzamos por definir una clase que representa al juego y sus componentes. Entre otras cosas, almacenar\u00e1 una referencia a la ventana:</p> <pre><code>class Juego:\n    def __init__(self, ventana):\n        self.ventana = ventana\n        ...\n\nv = tkinter.Tk()\njuego = Juego(v)\n</code></pre> <p>De esta forma, para hacer referencia a la ventana, escribimos <code>juego.ventana</code>.</p> <p>Vamos a sustituir el m\u00e9todo <code>mainloop()</code> que tienen las ventanas, para gestionar eventos, por nuestro propio bucle:</p> <pre><code>juego.bucle()\n</code></pre> <p>y definimos el m\u00e9todo como:</p> <pre><code>def bucle(self):\n    while True:\n        # refrescar continuamente los objetos de pantalla\n        # si se pulsa tecla escape, salir del bucle\n</code></pre> <p>El m\u00e9todo <code>ventana.update_idletasks()</code> gestiona todas las tareas pendientes que tenga tkinter. Esto nos garantiza que no quedan eventos desatendidos.</p> <p>El m\u00e9todo <code>ventana.destroy()</code> elimina la ventana y, siendo la principal,  finaliza la ejecuci\u00f3n del programa.</p> <p>\u00a1Cuidado!</p> <p>En pr\u00f3ximos pasos, vamos a utilizar la tecla Esc para salir de la  aplicaci\u00f3n. El cierre de la ventana pulsando en el icono [x] de la esquina superior puede mostrar en la consola de IDLE alg\u00fan mensaje de error por intentar gestionar eventos pendientes de una ventana que ya no existe.</p> <p>Por ahora, podemos finalizar el programa pulsando Ctrl+C en el shell de IDLE.</p>"},{"location":"017-01-Inicio.html#configurar-la-ventanas","title":"Configurar la ventanas","text":"<p>Al crear una instancia de la clase <code>Juego</code>, en el m\u00e9todo <code>__init__()</code>  configuramos la ventana:</p> <ul> <li> <p>barra de t\u00edtulo</p> <pre><code>self.ventana.title('Bola')\n</code></pre> </li> <li> <p>no redimensionable horizontal ni verticalmente</p> <pre><code>self.ventana.resizable(False, False)\n</code></pre> </li> <li> <p>el atributo <code>topmost</code> hace que la ventana siempre est\u00e9 en primer plano:</p> <pre><code>self.ventana.wm_attributes('-topmost', True)\n</code></pre> </li> <li> <p>creamos un lienzo con un borde de grosor cero. La ventana se ajustar\u00e1     a las dimensiones del lienzo:</p> <pre><code>self.lienzo = tkinter.Canvas(self.ventana,\n                             width=500,\n                             height=400,\n                             bd=0)\nself.lienzo.pack()\n</code></pre> </li> <li> <p>hacemos que el ajuste de la ventana sea efectivo:</p> <pre><code>self.ventana.update()\n</code></pre> </li> </ul>"},{"location":"017-02-Teclado.html","title":"Control del teclado","text":"<p>El segundo paso consiste en hacer que nuestro juego est\u00e9 atento a las pulsaciones en el teclado, actuando en consecuencia. Por ahora, gestionaremos la tecla Esc, que dar\u00e1 fin al juego y cerrar\u00e1 la ventana:</p> 02CapturarTeclas.py<pre><code>import tkinter\n\nclass Juego:\n    def __init__(self, ventana):\n        self.ventana = ventana\n\n        # Configurar ventana\n        self.ventana.title('Bola')\n        self.ventana.resizable(False, False)\n        self.ventana.wm_attributes('-topmost', True)\n\n        # Crear lienzo\n        self.lienzo = tkinter.Canvas(self.ventana,\n                                     width=500,\n                                     height=400,\n                                     bd=0)\n        self.lienzo.pack()\n        self.ventana.update()\n\n        # Indicadores\n        self.terminar = False\n\n        # Asociar eventos de teclado\n        self.ventana.bind_all('&lt;KeyPress&gt;', self.gestionar_tecla)\n\n    def gestionar_tecla(self,evento):\n        if evento.keysym=='Escape':\n            self.terminar = True\n\n    def bucle(self):\n        while True:\n            if self.terminar:\n                break\n\n            self.ventana.update_idletasks()\n            self.ventana.update()\n\nv = tkinter.Tk()\njuego = Juego(v)\njuego.bucle()\njuego.ventana.update_idletasks()\njuego.ventana.destroy()\n</code></pre> <p>Creamos una propiedad del juego llamada <code>terminar. En el bucle, preguntamos continuamente por ella para saber cuando finalizar las iteraciones con una sentencia</code>break`</p> <p>Para que tenga efecto, tenemos que ligar el evento Pulsar Tecla a la ejecuci\u00f3n de un m\u00e9todo que gestione esa pulsaci\u00f3n. La asociaci\u00f3n se hace mediante el m\u00e9todo <code>bind</code> de la ventana (o de otro componente. Hay que pasarle el nombre del evento, en forma de texto, y el nombre de la funci\u00f3n asociada.</p> <p>Esta funci\u00f3n recibe de forma autom\u00e1tica un par\u00e1metro que representa informaci\u00f3n sobre el evento. Trat\u00e1ndose de un m\u00e9todo, tambi\u00e9n recibir\u00e1 una referencia a la instancia de la clase:</p> <pre><code>def gestionar_tecla(self, evento):\n</code></pre> <p>El evento es un objeto que tiene una propiedad con el nombre de la tecla pulsada:</p> <pre><code>if evento.keysym=='Escape':\n</code></pre>"},{"location":"017-02-Teclado.html#nombres-de-teclas","title":"Nombres de teclas","text":"<p>Podemos averiguar nombres de teclas con el siguiente programa:</p> Nombres_teclas.py<pre><code>import tkinter\n\ndef mostrar_tecla(evento):\n    print(f\"'{evento.keysym}'\")\n\nventana = tkinter.Tk()\nventana.bind_all('&lt;KeyPress&gt;', mostrar_tecla)\nventana.mainloop()\n</code></pre> <p>Pulsar sobre la ventana resultante. Al pulsar teclas, se mostrar\u00e1 el nombre de cada una en el shell de IDLE.</p>"},{"location":"017-03-Bola.html","title":"A\u00f1adir la bola","text":"<p>El tercer paso de nuestra aplicaci\u00f3n es a\u00f1adir la bola. En principio la mostramos en el centro de la ventana:</p> 03A\u00f1adirBola.py<pre><code>import tkinter\n\nclass Juego:\n    def __init__(self, ventana):\n        self.ventana = ventana\n\n        # Configurar ventana\n        self.ventana.title('Bola')\n        self.ventana.resizable(False, False)\n        self.ventana.wm_attributes('-topmost', True)\n\n        # Crear lienzo\n        self.lienzo = tkinter.Canvas(self.ventana,\n                                     width=500,\n                                     height=400,\n                                     bd=0)\n        self.lienzo.pack()\n        self.ventana.update()\n\n        # Crear bola\n        self.bola = Bola(self)\n\n        # Indicadores\n        self.terminar = False\n\n        # Asociar eventos de teclado\n        self.ventana.bind_all('&lt;KeyPress&gt;', self.gestionar_tecla)\n\n    def gestionar_tecla(self,evento):\n        if evento.keysym=='Escape':\n            self.terminar = True\n\n    def bucle(self):\n        while True:\n            if self.terminar:\n                break\n\n            self.ventana.update_idletasks()\n            self.ventana.update()\n\nclass Bola:\n    def __init__(self, juego):\n        self.juego  = juego\n\n        tama\u00f1o = 15\n        self.lienzo_ancho = self.juego.lienzo.winfo_width()\n        self.lienzo_alto = self.juego.lienzo.winfo_height()\n\n        self.juego.id_bola = self.juego.lienzo.create_oval(0, 0, tama\u00f1o, tama\u00f1o,\n                                                           fill='red')\n        centro_x = self.lienzo_ancho/2 - tama\u00f1o/2\n        centro_y = self.lienzo_alto/2 - tama\u00f1o/2\n        self.juego.lienzo.move(self.juego.id_bola, centro_x, centro_y)\n\nv = tkinter.Tk()\njuego = Juego(v)\njuego.bucle()\njuego.ventana.update_idletasks()\njuego.ventana.destroy()\n</code></pre> <p>Definimos una clase <code>Bola</code> y la instanciamos, creando un objeto que guardamos como propiedad del juego. V\u00e9ase que este ya tiene tres objetos gr\u00e1ficos,  la ventana, el canvas y la bola.</p> <p>Para instanciar la bola, le pasamos una referencia al objeto <code>juego</code>. Esto permite a los m\u00e9todos de la clase <code>Bola</code> acceder a las propiedades del juego:</p> <pre><code>self.bola = Bola(self)\n</code></pre> <p>Dentro del m\u00e9todo <code>__init__()</code> de la bola, guardamos la referencia:</p> <pre><code>def __init__(self, juego):\n    self.juego  = juego\n</code></pre> <p>El juego tiene a su vez la propiedad <code>lienzo</code>, que nos permite descubrir las dimensiones de este y guardarlo entre las propiedades de la bola:</p> <pre><code>self.lienzo_ancho = self.juego.lienzo.winfo_width()\nself.lienzo_alto = self.juego.lienzo.winfo_height()\n</code></pre> <p>Ahora que podemos acceder al lienzo desde la bola, dibujamos el c\u00edrculo y guardamos una referencia al mismo:</p> <pre><code>self.juego.id_bola = self.juego.lienzo.create_oval(0, 0, tama\u00f1o, tama\u00f1o, fill='red')\n</code></pre> <p>... y lo desplazamos al centro del lienzo:</p> <pre><code>centro_x = self.lienzo_ancho/2 - tama\u00f1o/2\ncentro_y = self.lienzo_alto/2 - tama\u00f1o/2\nself.juego.lienzo.move(self.juego.id_bola, centro_x, centro_y)\n</code></pre> <p>En futuros pasos, desplazaremos la bola por la pantalla usando el m\u00e9todo  <code>bucle()</code> del juego.</p>"},{"location":"017-04-Paleta.html","title":"A\u00f1adir la paleta","text":"<p>A\u00f1adir la paleta es similar a lo que hemos hecho con la bola:</p> 04A\u00f1adirPaleta.py<pre><code>import tkinter\n\nclass Juego:\n    def __init__(self, ventana):\n        self.ventana = ventana\n\n        # Configurar ventana\n        self.ventana.title('Bola')\n        self.ventana.resizable(False, False)\n        self.ventana.wm_attributes('-topmost', True)\n\n        # Crear lienzo\n        self.lienzo = tkinter.Canvas(self.ventana,\n                                     width=500,\n                                     height=400,\n                                     bd=0)\n        self.lienzo.pack()\n        self.ventana.update()\n\n        # Crear bola y paleta\n        self.bola = Bola(self)\n        self.paleta = Paleta(self)        \n\n        # Indicadores\n        self.terminar = False\n\n        # Asociar eventos de teclado\n        self.ventana.bind_all('&lt;KeyPress&gt;', self.gestionar_tecla)\n\n    def gestionar_tecla(self,evento):\n        if evento.keysym=='Escape':\n            self.terminar = True\n\n    def bucle(self):\n        while True:\n            if self.terminar:\n                break\n\n            self.ventana.update_idletasks()\n            self.ventana.update()\n\nclass Bola:\n    def __init__(self, juego):\n        self.juego  = juego\n\n        tama\u00f1o = 15\n        self.lienzo_ancho = self.juego.lienzo.winfo_width()\n        self.lienzo_alto = self.juego.lienzo.winfo_height()\n\n        self.juego.id_bola = self.juego.lienzo.create_oval(0, 0, tama\u00f1o, tama\u00f1o,\n                                                           fill='red')\n        centro_x = self.lienzo_ancho/2 - tama\u00f1o/2\n        centro_y = self.lienzo_alto/2 - tama\u00f1o/2\n        self.juego.lienzo.move(self.juego.id_bola, centro_x, centro_y)\n\nclass Paleta:\n    def __init__(self, juego):\n        self.juego  = juego\n\n        ancho = 60\n        self.lienzo_ancho = self.juego.lienzo.winfo_width()\n        self.lienzo_alto = self.juego.lienzo.winfo_height()\n\n        self.juego.id_paleta = self.juego.lienzo.create_rectangle(0, 0, ancho, 10, fill='blue')\n\n        centro_x = self.lienzo_ancho/2 - ancho/2\n        centro_y = self.lienzo_alto - 50\n\n        self.juego.lienzo.move(self.juego.id_paleta, centro_x, centro_y)\n\nv = tkinter.Tk()\njuego = Juego(v)\njuego.bucle()\njuego.ventana.update_idletasks()\njuego.ventana.destroy()\n</code></pre>"},{"location":"017-05-MoverBola1.html","title":"Mover la bola (1\u00aa parte)","text":"<p>El siguiente paso es a\u00f1adir un movimiento continuo de la bola. Vamos a crear un m\u00e9todo <code>mover()</code> en el juego, que sea invocado continuamente desde el m\u00e9todo <code>bucle()</code>.</p> <p>Como primer paso, vamos a hacer que la bola se mueva de arriba a abajo, rebotando en los bordes superior e inferior:</p> 05MoverBola1.py<pre><code>import tkinter\n\nclass Juego:\n    def __init__(self, ventana):\n        self.ventana = ventana\n\n        # Configurar ventana\n        self.ventana.title('Bola')\n        self.ventana.resizable(False, False)\n        self.ventana.wm_attributes('-topmost', True)\n\n        # Crear lienzo\n        self.lienzo = tkinter.Canvas(self.ventana,\n                                     width=500,\n                                     height=400,\n                                     bd=0)\n        self.lienzo.pack()\n        self.ventana.update()\n\n        # Crear bola y paleta\n        self.bola = Bola(self)\n        self.paleta = Paleta(self)        \n\n        # Indicadores\n        self.terminar = False\n        self.en_juego=False\n\n        # Asociar eventos de teclado\n        self.ventana.bind_all('&lt;KeyPress&gt;', self.gestionar_tecla)\n\n    def gestionar_tecla(self,evento):\n        if evento.keysym=='Escape':\n            self.terminar = True\n        elif evento.keysym == 'space':            \n            self.en_juego = True\n\n    def bucle(self):\n        while True:\n            if self.terminar:\n                break\n\n            if self.en_juego:\n                self.bola.mover()\n\n            self.ventana.update_idletasks()\n            self.ventana.update()\n\nclass Bola:\n    def __init__(self, juego):\n        self.juego  = juego\n\n        tama\u00f1o = 15\n        self.lienzo_ancho = self.juego.lienzo.winfo_width()\n        self.lienzo_alto = self.juego.lienzo.winfo_height()\n\n        self.juego.id_bola = self.juego.lienzo.create_oval(0, 0, tama\u00f1o, tama\u00f1o,\n                                                           fill='red')\n        centro_x = self.lienzo_ancho/2 - tama\u00f1o/2\n        centro_y = self.lienzo_alto/2 - tama\u00f1o/2\n        self.juego.lienzo.move(self.juego.id_bola, centro_x, centro_y)\n\n        self.desplaz_y = -(velocidad_bola)\n\n    def mover(self):\n        # obtener coordenadas bola (x1, y1, x2, y2)\n        coord_bola = self.juego.lienzo.coords(self.juego.id_bola)\n        borde_sup_bola = coord_bola[1]\n        borde_inf_bola = coord_bola[3]\n\n        # si ha tocado el borde superior, empezar a bajar\n        if borde_sup_bola &lt;= 1:\n            self.desplaz_y = abs(self.desplaz_y)\n\n        # si ha tocado el borde inferior, empezar a subir\n        if borde_inf_bola &gt;= self.lienzo_alto-1:\n            self.desplaz_y = abs(self.desplaz_y)*(-1)\n\n        # desplazar\n        self.juego.lienzo.move(self.juego.id_bola, 0, self.desplaz_y)\n\nclass Paleta:\n    def __init__(self, juego):\n        self.juego  = juego\n\n        ancho = 60\n        self.lienzo_ancho = self.juego.lienzo.winfo_width()\n        self.lienzo_alto = self.juego.lienzo.winfo_height()\n\n        self.juego.id_paleta = self.juego.lienzo.create_rectangle(0, 0, ancho, 10, fill='blue')\n\n        centro_x = self.lienzo_ancho/2 - ancho/2\n        centro_y = self.lienzo_alto - 50\n\n        self.juego.lienzo.move(self.juego.id_paleta, centro_x, centro_y)\n\nvelocidad_bola=4\nv = tkinter.Tk()\njuego = Juego(v)\njuego.bucle()\njuego.ventana.update_idletasks()\njuego.ventana.destroy()\n</code></pre> <p>En el bloque principal del programa, comenzamos por definir la velocidad de la  bola, medida en n\u00famero de pixels a desplazar en cada iteraci\u00f3n del bucle:</p> <pre><code>velocidad_bola=4\n</code></pre> <p>Como es una variable global, ser\u00e1 accesible desde cualquier punto del programa.</p> <p>Al inicializar el juego, creamos una propiedad para controlar cuando est\u00e1 parado el juego:</p> <pre><code>self.en_juego=False\n</code></pre> <p>El juego se activa al pulsar la tecla Space</p> <pre><code>def gestionar_tecla(self,evento):\n    if evento.keysym=='Escape':\n        self.terminar = True\n    elif evento.keysym == 'space':            \n        self.en_juego = True\n</code></pre> <p>Y en el bucle principal, movemos la bola solo si el juego est\u00e1 activo:</p> <pre><code>if self.en_juego:\n    self.bola.mover()\n</code></pre> <p>Para controlar el desplazamiento actual de la bola, creamos una propiedad al crear una nueva bola:</p> <pre><code>self.desplaz_y = -(velocidad_bola):\n</code></pre> <p>Siendo x,y las coordenadas de todo objeto, llamaremos <code>desplaz_y</code> al desplazamiento vertical y <code>desplaz_x</code> al horizontal. Inicialmente, el vertical es negativo, lo que hace que la bola comience desplaz\u00e1ndose hacia arriba.</p> <p>El m\u00e9todo <code>mover()</code> es invocado continuamente. Consta de dos partes:</p> <ul> <li>Calcular desplazamientos</li> <li> <p>Desplazar la bola. En este primer paso, no la desplazaremos horizontalmente:</p> <pre><code>self.juego.lienzo.move(self.juego.id_bola, 0, self.desplaz_y)\n</code></pre> <p>La bola guarda como propiedades:</p> <ul> <li>el desplazamiento vertical <code>self.desplaz_y</code></li> <li>una referencia al juego. Este almacena una referencia al canvas, que      tiene un m\u00e9todo <code>move()</code>. Hay que pasarle la referencia al circulo      dibujado, que est\u00e1 guardada como propiedad del juego.</li> </ul> </li> </ul> <p>La funci\u00f3n <code>abs(x)</code> devuelve el valor absoluto de un n\u00famero x, quitando el signo. Aqu\u00ed la usamos para controlar el signo de los desplazamientos.</p>"},{"location":"017-06-MoverBola2.html","title":"Mover la bola (2\u00aa parte)","text":"<p>Como sexto paso, vamos a a\u00f1adir el movimiento en horizontal. La bola rebotar\u00e1  en los cuatro lados del lienzo.</p> 06MoverBola2.py<pre><code>import tkinter\nimport random\n\nclass Juego:\n    def __init__(self, ventana):\n        self.ventana = ventana\n\n        # Configurar ventana\n        self.ventana.title('Bola')\n        self.ventana.resizable(False, False)\n        self.ventana.wm_attributes('-topmost', True)\n\n        # Crear lienzo\n        self.lienzo = tkinter.Canvas(self.ventana,\n                                     width=500,\n                                     height=400,\n                                     bd=0)\n        self.lienzo.pack()\n        self.ventana.update()\n\n        # Crear bola y paleta\n        self.bola = Bola(self)\n        self.paleta = Paleta(self)        \n\n        # Indicadores\n        self.terminar = False\n        self.en_juego=False\n\n        # Asociar eventos de teclado\n        self.ventana.bind_all('&lt;KeyPress&gt;', self.gestionar_tecla)\n\n    def gestionar_tecla(self,evento):\n        if evento.keysym=='Escape':\n            self.terminar = True\n        elif evento.keysym=='space':            \n            self.en_juego = True\n\n    def bucle(self):\n        while True:\n            if self.terminar:\n                break\n\n            if self.en_juego:\n                self.bola.mover()\n\n            self.ventana.update_idletasks()\n            self.ventana.update()\n\nclass Bola:\n    def __init__(self, juego):\n        self.juego  = juego\n\n        tama\u00f1o = 15\n        self.lienzo_ancho = self.juego.lienzo.winfo_width()\n        self.lienzo_alto = self.juego.lienzo.winfo_height()\n\n        self.juego.id_bola = self.juego.lienzo.create_oval(0, 0, tama\u00f1o, tama\u00f1o,\n                                                           fill='red')\n        centro_x = self.lienzo_ancho/2 - tama\u00f1o/2\n        centro_y = self.lienzo_alto/2 - tama\u00f1o/2\n        self.juego.lienzo.move(self.juego.id_bola, centro_x, centro_y)\n\n        self.desplaz_y = -(velocidad_bola)\n        self.desplaz_x = random.choice([-2, -3, -4, 2, 3, 4])\n\n    def mover(self):\n        # obtener coordenadas bola (x1, y1, x2, y2)\n        coord_bola = self.juego.lienzo.coords(self.juego.id_bola)\n        borde_sup_bola = coord_bola[1]\n        borde_inf_bola = coord_bola[3]\n        borde_izd_bola = coord_bola[0]\n        borde_dch_bola = coord_bola[2]\n\n        # si ha tocado el borde superior, empezar a bajar\n        if borde_sup_bola &lt;= 1:\n            self.desplaz_y = abs(self.desplaz_y)\n\n        # si ha tocado el borde inferior, empezar a subir\n        if borde_inf_bola &gt;= self.lienzo_alto-1:\n            self.desplaz_y = abs(self.desplaz_y)*(-1)\n\n        # si ha tocado el borde lateral, cambiar de direcci\u00f3n\n        if borde_izd_bola &lt;= 1:\n            self.desplaz_x = abs(self.desplaz_x)\n        elif borde_dch_bola &gt;= self.lienzo_ancho-1:\n            self.desplaz_x = abs(self.desplaz_x)*(-1)\n\n        # desplazar\n        self.juego.lienzo.move(self.juego.id_bola, self.desplaz_x, self.desplaz_y)\n\nclass Paleta:\n    def __init__(self, juego):\n        self.juego  = juego\n\n        ancho = 60\n        self.lienzo_ancho = self.juego.lienzo.winfo_width()\n        self.lienzo_alto = self.juego.lienzo.winfo_height()\n\n        self.juego.id_paleta = self.juego.lienzo.create_rectangle(0, 0, ancho, 10, fill='blue')\n\n        centro_x = self.lienzo_ancho/2 - ancho/2\n        centro_y = self.lienzo_alto - 50\n\n        self.juego.lienzo.move(self.juego.id_paleta, centro_x, centro_y)\n\nvelocidad_bola=4\nv = tkinter.Tk()\njuego = Juego(v)\njuego.bucle()\njuego.ventana.update_idletasks()\njuego.ventana.destroy()\n</code></pre> <p>Vemos que la bola tiene una nueva propiedad, <code>desplaz_x</code>, que mide el n\u00famero de pixels a desplazar en cada iteraci\u00f3n. En cada juego la inicializamos con un  valor al azar, 2, 3 o 4:</p> <pre><code>self.desplaz_x = random.choice([-2, -3, -4, 2, 3, 4])\n</code></pre>"},{"location":"017-06-MoverBola2.html#ralentizar-el-juego","title":"Ralentizar el juego","text":"<p>Ajustando los desplazamientos podemos acelerar o ralentizar el juego. Pero hay un mecanismo adicional que podemos usar para introducir un retardo:</p> <pre><code>    import time\n    ... \n\n    while True:\n        if self.terminar:\n            break\n\n        if self.en_juego:\n            self.bola.mover()\n            time.sleep(0.01)    \n\n        self.ventana.update_idletasks()\n        self.ventana.update()\n</code></pre> <p>la funci\u00f3n <code>time.sleep(n)</code> de la biblioteca est\u00e1ndar de Python genera una pausa de n segundos en la ejecuci\u00f3n del programa. Invoc\u00e1ndola en el bucle obtenemos un retardo que podemos ajustar cambiando el argumento. Normalmente pasaremos una fracci\u00f3n de segundo, d\u00e9cimas, cent\u00e9simas o mil\u00e9simas.</p>"},{"location":"017-07-TocarFondo.html","title":"Fin del juego","text":"<p>Vamos a modificar el programa para que, al tocar la bola el borde inferior del canvas, finalice el juego y se quede en estado inactivo. Lo podemos reiniciar pulsando Space</p> 07FinJuego.py<pre><code>import tkinter\nimport random\n\nclass Juego:\n    def __init__(self, ventana):\n        self.ventana = ventana\n\n        # Configurar ventana\n        self.ventana.title('Bola')\n        self.ventana.resizable(False, False)\n        self.ventana.wm_attributes('-topmost', True)\n\n        # Crear lienzo\n        self.lienzo = tkinter.Canvas(self.ventana,\n                                     width=500,\n                                     height=400,\n                                     bd=0)\n        self.lienzo.pack()\n        self.ventana.update()\n\n        # Crear bola y paleta\n        self.bola = Bola(self)\n        self.paleta = Paleta(self)        \n\n        # Indicadores\n        self.terminar = False\n        self.en_juego=False\n        self.reiniciar=False\n\n        # Asociar eventos de teclado\n        self.ventana.bind_all('&lt;KeyPress&gt;', self.gestionar_tecla)\n\n    def gestionar_tecla(self,evento):\n        if evento.keysym=='Escape':\n            self.terminar = True\n        elif evento.keysym=='space':            \n            self.en_juego = True\n\n    def bucle(self):\n        while True:\n            if self.terminar:\n                break\n\n            if self.reiniciar and self.en_juego:\n                self.lienzo.delete(self.id_bola)\n                self.lienzo.delete(self.id_paleta)\n                self.bola = Bola(self)\n                self.paleta = Paleta(self)\n                self.reiniciar = False\n\n            if self.en_juego:\n                self.bola.mover()\n\n            self.ventana.update_idletasks()\n            self.ventana.update()\n\nclass Bola:\n    def __init__(self, juego):\n        self.juego  = juego\n\n        tama\u00f1o = 15\n        self.lienzo_ancho = self.juego.lienzo.winfo_width()\n        self.lienzo_alto = self.juego.lienzo.winfo_height()\n\n        self.juego.id_bola = self.juego.lienzo.create_oval(0, 0, tama\u00f1o, tama\u00f1o,\n                                                           fill='red')\n        centro_x = self.lienzo_ancho/2 - tama\u00f1o/2\n        centro_y = self.lienzo_alto/2 - tama\u00f1o/2\n        self.juego.lienzo.move(self.juego.id_bola, centro_x, centro_y)\n\n        self.desplaz_y = -(velocidad_bola)\n        self.desplaz_x = random.choice([-2, -3, -4, 2, 3, 4])\n\n    def mover(self):\n        # obtener coordenadas bola (x1, y1, x2, y2)\n        coord_bola = self.juego.lienzo.coords(self.juego.id_bola)\n        borde_sup_bola = coord_bola[1]\n        borde_inf_bola = coord_bola[3]\n        borde_izd_bola = coord_bola[0]\n        borde_dch_bola = coord_bola[2]\n\n        # si ha tocado el borde superior, empezar a bajar\n        if borde_sup_bola &lt;= 1:\n            self.desplaz_y = abs(self.desplaz_y)\n\n        ## si toca el borde inferior, fin del juego\n        if borde_inf_bola &gt;= self.lienzo_alto:\n            self.juego.en_juego = False\n            self.juego.reiniciar = True\n\n        # si ha tocado el borde lateral, cambiar de direcci\u00f3n\n        if borde_izd_bola &lt;= 1:\n            self.desplaz_x = abs(self.desplaz_x)\n        elif borde_dch_bola &gt;= self.lienzo_ancho-1:\n            self.desplaz_x = abs(self.desplaz_x)*(-1)\n\n        # desplazar\n        self.juego.lienzo.move(self.juego.id_bola, self.desplaz_x, self.desplaz_y)\n\nclass Paleta:\n    def __init__(self, juego):\n        self.juego  = juego\n\n        ancho = 60\n        self.lienzo_ancho = self.juego.lienzo.winfo_width()\n        self.lienzo_alto = self.juego.lienzo.winfo_height()\n\n        self.juego.id_paleta = self.juego.lienzo.create_rectangle(0, 0, ancho, 10, fill='blue')\n\n        centro_x = self.lienzo_ancho/2 - ancho/2\n        centro_y = self.lienzo_alto - 50\n\n        self.juego.lienzo.move(self.juego.id_paleta, centro_x, centro_y)\n\nvelocidad_bola=4\nv = tkinter.Tk()\njuego = Juego(v)\njuego.bucle()\njuego.ventana.update_idletasks()\njuego.ventana.destroy()\n</code></pre> <p>El reinicio implica destruir la bola y paleta y crear objetos nuevos:</p> <pre><code>if self.reiniciar and self.en_juego:\n    self.lienzo.delete(self.id_bola)\n    self.lienzo.delete(self.id_paleta)\n    self.bola = Bola(self)\n    self.paleta = Paleta(self)\n    self.reiniciar = False\n</code></pre> <p>Las formas creadas se borran haciendo uso del m\u00e9todo <code>delete()</code> del canvas.</p>"},{"location":"017-08-MoverPaleta.html","title":"Mover la paleta","text":"<p>El siguiente a\u00f1adido es reaccionar a las pulsaciones Left Right para mover la paleta a izquierda y derecha:</p> 08MoverPaleta.py<pre><code>import tkinter\nimport random\n\nclass Juego:\n    def __init__(self, ventana):\n        self.ventana = ventana\n\n        # Configurar ventana\n        self.ventana.title('Bola')\n        self.ventana.resizable(False, False)\n        self.ventana.wm_attributes('-topmost', True)\n\n        # Crear lienzo\n        self.lienzo = tkinter.Canvas(self.ventana,\n                                     width=500,\n                                     height=400,\n                                     bd=0)\n        self.lienzo.pack()\n        self.ventana.update()\n\n        # Crear bola y paleta\n        self.bola = Bola(self)\n        self.paleta = Paleta(self)        \n\n        # Indicadores\n        self.terminar = False\n        self.en_juego = False\n        self.reiniciar= False\n\n        # Asociar eventos de teclado\n        self.ventana.bind_all('&lt;KeyPress&gt;', self.gestionar_tecla)\n        self.ventana.bind_all('&lt;KeyRelease&gt;', self.detener_paleta)\n\n    def gestionar_tecla(self,evento):\n        if evento.keysym=='Escape':\n            self.terminar = True\n        elif evento.keysym=='space':            \n            self.en_juego = True\n        elif evento.keysym=='Left':\n            self.paleta.desplaz_paleta(-1)\n        elif evento.keysym=='Right':\n            self.paleta.desplaz_paleta(1)\n\n    def detener_paleta(self,evento):\n            self.paleta.desplaz_paleta(0)\n\n    def bucle(self):\n        while True:\n            if self.terminar:\n                break\n\n            if self.reiniciar and self.en_juego:\n                self.lienzo.delete(self.id_bola)\n                self.lienzo.delete(self.id_paleta)\n                self.bola = Bola(self)\n                self.paleta = Paleta(self)\n                self.reiniciar = False\n\n            if self.en_juego:\n                self.ventana.update_idletasks()\n                self.bola.mostrar()\n                self.paleta.mostrar()\n\n            self.ventana.update_idletasks()\n            self.ventana.update()\n\nclass Bola:\n    def __init__(self, juego):\n        self.juego  = juego\n\n        tama\u00f1o = 15\n        self.lienzo_ancho = self.juego.lienzo.winfo_width()\n        self.lienzo_alto = self.juego.lienzo.winfo_height()\n\n        self.juego.id_bola = self.juego.lienzo.create_oval(0, 0, tama\u00f1o, tama\u00f1o,\n                                                           fill='red')\n        centro_x = self.lienzo_ancho/2 - tama\u00f1o/2\n        centro_y = self.lienzo_alto/2 - tama\u00f1o/2\n        self.juego.lienzo.move(self.juego.id_bola, centro_x, centro_y)\n\n        self.desplaz_y = -(velocidad_bola)\n        self.desplaz_x = random.choice([-2, -3, -4, 2, 3, 4])\n\n    def mostrar(self):\n        # obtener coordenadas bola (x1, y1, x2, y2)\n        coord_bola = self.juego.lienzo.coords(self.juego.id_bola)\n        borde_sup_bola = coord_bola[1]\n        borde_inf_bola = coord_bola[3]\n        borde_izd_bola = coord_bola[0]\n        borde_dch_bola = coord_bola[2]\n\n        # si ha tocado el borde superior, empezar a bajar\n        if borde_sup_bola &lt;= 1:\n            self.desplaz_y = abs(self.desplaz_y)\n\n        ## si toca el borde inferior, fin del juego\n        if borde_inf_bola &gt;= self.lienzo_alto:\n            self.juego.en_juego = False\n            self.juego.reiniciar = True\n\n        # si ha tocado el borde lateral, cambiar de direcci\u00f3n\n        if borde_izd_bola &lt;= 1:\n            self.desplaz_x = abs(self.desplaz_x)\n        elif borde_dch_bola &gt;= self.lienzo_ancho-1:\n            self.desplaz_x = abs(self.desplaz_x)*(-1)\n\n        # desplazar\n        self.juego.lienzo.move(self.juego.id_bola, self.desplaz_x, self.desplaz_y)\n\nclass Paleta:\n    def __init__(self, juego):\n        self.juego  = juego\n\n        ancho = 60\n        self.lienzo_ancho = self.juego.lienzo.winfo_width()\n        self.lienzo_alto = self.juego.lienzo.winfo_height()\n\n        self.juego.id_paleta = self.juego.lienzo.create_rectangle(0, 0, ancho, 10, fill='blue')\n        self.desplaz = velocidad_paleta\n        self.desplaz_x = 0\n\n        centro_x = self.lienzo_ancho/2 - ancho/2\n        centro_y = self.lienzo_alto - 50\n\n        self.juego.lienzo.move(self.juego.id_paleta, centro_x, centro_y)\n\n    def desplaz_paleta(self, sentido):\n        if not self.juego.en_juego:\n            return\n\n        if sentido==0:\n            self.desplaz_x=0\n\n        coord = self.juego.lienzo.coords(self.juego.id_paleta)\n        borde_izd_paleta = coord[0]\n        borde_dch_paleta = coord[2]\n\n        self.desplaz_x = 0\n        if borde_izd_paleta &gt; 0 and sentido == -1:\n            self.desplaz_x = -velocidad_paleta\n\n        elif borde_dch_paleta &lt; self.lienzo_ancho and sentido == 1:        \n            self.desplaz_x = velocidad_paleta\n\n    def mostrar(self):\n        self.juego.lienzo.move(self.juego.id_paleta, self.desplaz_x, 0)          \n\nvelocidad_bola=4\nvelocidad_paleta=5\nv = tkinter.Tk()\njuego = Juego(v)\njuego.bucle()\njuego.ventana.update_idletasks()\njuego.ventana.destroy()\n</code></pre> <p>En el bloque principal del programa establecemos la velocidad con la que se  desplaza la paleta, medida en pixels:</p> <pre><code>velocidad_paleta=5\n</code></pre> <p>Inicializamos el objeto paleta con un desplazamiento horizontal de cero.  Mientras no pulsemos las teclas, la paleta no se mueve:</p> <pre><code>self.desplaz = velocidad_paleta\nself.desplaz_x = 0\n</code></pre> <p>En la gesti\u00f3n del evento KeyPress establecemos la direcci\u00f3n de desplazamiento:</p> <pre><code>elif evento.keysym=='Left':\n    self.paleta.desplaz_paleta(-1)\nelif evento.keysym=='Right':\n    self.paleta.desplaz_paleta(1)\n</code></pre> <p>En el m\u00e9todo <code>desplaz_paleta()</code> establecemos el desplazamiento:</p> <pre><code>if borde_izd_paleta &gt; 0 and sentido == -1:\n    self.desplaz_x = -velocidad_paleta\n\nelif borde_dch_paleta &lt; self.lienzo_ancho and sentido == 1:        \n    self.desplaz_x = velocidad_paleta\n</code></pre> <p>Al soltar la tecla, detenemos el desplazamiento:</p> <pre><code>self.ventana.bind_all('&lt;KeyRelease&gt;', self.detener_paleta)\n\ndef detener_paleta(self,evento):\n        self.paleta.desplaz_paleta(0)\n</code></pre> <p>Establecido el desplazamiento, refrescamos la paleta en cada iteraci\u00f3n del bucle principal del juego:</p> <pre><code>if self.en_juego:\n    self.ventana.update_idletasks()\n    self.bola.mostrar()\n    self.paleta.mostrar()\n</code></pre> <p>Nota: La paleta se desplaza a izquierda y derecha hasta tocar borde, pero es posible que el desplazamiento que se ejecuta en cada iteraci\u00f3n sea superior a la distancia que falta para llegar al borde. Por este motivo, es posible que el extremo de la paleta se salga ligeramente del canvas. Podr\u00edamos refinar el programa para controlarlo pero no vamos a complicarlo.  Apenas afecta a la jugabilidad.</p>"},{"location":"017-09-Texto.html","title":"A\u00f1adir texto","text":"<p>El siguiente paso deber\u00eda ser detectar cuando la bola toca la paleta, pero vamos a hacer una pausa. Vamos a mostrar un texto cuando el programa est\u00e1 inactivo, pendiente de pulsar Space: </p> <p>Los cambios en el programa son:</p> <p></p> 09Texto.py<pre><code>import tkinter\nimport random\n\nclass Juego:\n    def __init__(self, ventana):\n        self.ventana = ventana\n\n        # Configurar ventana\n        self.ventana.title('Bola')\n        self.ventana.resizable(False, False)\n        self.ventana.wm_attributes('-topmost', True)\n\n        # Crear lienzo\n        self.lienzo = tkinter.Canvas(self.ventana,\n                                     width=500,\n                                     height=400,\n                                     bd=0)\n        self.lienzo.pack()\n        self.ventana.update()\n\n        # Crear bola y paleta\n        self.bola = Bola(self)\n        self.paleta = Paleta(self)        \n\n        # Indicadores\n        self.terminar = False\n        self.en_juego = False\n        self.reiniciar= False\n\n        self.texto = self.lienzo.create_text(250, 250, text='PULSE ESPACIO PARA INICIAR')\n\n        # Asociar eventos de teclado\n        self.ventana.bind_all('&lt;KeyPress&gt;', self.gestionar_tecla)\n        self.ventana.bind_all('&lt;KeyRelease&gt;', self.detener_paleta)\n\n    def gestionar_tecla(self,evento):\n        if evento.keysym=='Escape':\n            self.terminar = True\n        elif evento.keysym=='space':            \n            self.en_juego = True\n            self.lienzo.itemconfig(self.texto, state='hidden')\n        elif evento.keysym=='Left':\n            self.paleta.desplaz_paleta(-1)\n        elif evento.keysym=='Right':\n            self.paleta.desplaz_paleta(1)\n\n    def detener_paleta(self,evento):\n            self.paleta.desplaz_paleta(0)\n\n    def bucle(self):\n        while True:\n            if self.terminar:\n                break\n\n            if self.reiniciar and self.en_juego:\n                self.lienzo.delete(self.id_bola)\n                self.lienzo.delete(self.id_paleta)\n                self.bola = Bola(self)\n                self.paleta = Paleta(self)\n                self.reiniciar = False\n\n            if self.en_juego:\n                self.ventana.update_idletasks()\n                self.bola.mostrar()\n                self.paleta.mostrar()\n\n            self.ventana.update_idletasks()\n            self.ventana.update()\n\nclass Bola:\n    def __init__(self, juego):\n        self.juego  = juego\n\n        tama\u00f1o = 15\n        self.lienzo_ancho = self.juego.lienzo.winfo_width()\n        self.lienzo_alto = self.juego.lienzo.winfo_height()\n\n        self.juego.id_bola = self.juego.lienzo.create_oval(0, 0, tama\u00f1o, tama\u00f1o,\n                                                           fill='red')\n        centro_x = self.lienzo_ancho/2 - tama\u00f1o/2\n        centro_y = self.lienzo_alto/2 - tama\u00f1o/2\n        self.juego.lienzo.move(self.juego.id_bola, centro_x, centro_y)\n\n        self.desplaz_y = -(velocidad_bola)\n        self.desplaz_x = random.choice([-2, -3, -4, 2, 3, 4])\n\n    def mostrar(self):\n        # obtener coordenadas bola (x1, y1, x2, y2)\n        coord_bola = self.juego.lienzo.coords(self.juego.id_bola)\n        borde_sup_bola = coord_bola[1]\n        borde_inf_bola = coord_bola[3]\n        borde_izd_bola = coord_bola[0]\n        borde_dch_bola = coord_bola[2]\n\n        # si ha tocado el borde superior, empezar a bajar\n        if borde_sup_bola &lt;= 1:\n            self.desplaz_y = abs(self.desplaz_y)\n\n        ## si toca el borde inferior, fin del juego\n        if borde_inf_bola &gt;= self.lienzo_alto:\n            self.juego.en_juego = False\n            self.juego.reiniciar = True\n            self.juego.lienzo.itemconfig(self.juego.texto, state='normal')\n\n        # si ha tocado el borde lateral, cambiar de direcci\u00f3n\n        if borde_izd_bola &lt;= 1:\n            self.desplaz_x = abs(self.desplaz_x)\n        elif borde_dch_bola &gt;= self.lienzo_ancho-1:\n            self.desplaz_x = abs(self.desplaz_x)*(-1)\n\n        # desplazar\n        self.juego.lienzo.move(self.juego.id_bola, self.desplaz_x, self.desplaz_y)\n\nclass Paleta:\n    def __init__(self, juego):\n        self.juego  = juego\n\n        ancho = 60\n        self.lienzo_ancho = self.juego.lienzo.winfo_width()\n        self.lienzo_alto = self.juego.lienzo.winfo_height()\n\n        self.juego.id_paleta = self.juego.lienzo.create_rectangle(0, 0, ancho, 10, fill='blue')\n        self.desplaz = velocidad_paleta\n        self.desplaz_x = 0\n\n        centro_x = self.lienzo_ancho/2 - ancho/2\n        centro_y = self.lienzo_alto - 50\n\n        self.juego.lienzo.move(self.juego.id_paleta, centro_x, centro_y)\n\n    def desplaz_paleta(self, sentido):\n        if not self.juego.en_juego:\n            return\n\n        if sentido==0:\n            self.desplaz_x=0\n\n        coord = self.juego.lienzo.coords(self.juego.id_paleta)\n        borde_izd_paleta = coord[0]\n        borde_dch_paleta = coord[2]\n\n        self.desplaz_x = 0\n        if borde_izd_paleta &gt; 0 and sentido == -1:\n            self.desplaz_x = -velocidad_paleta\n\n        elif borde_dch_paleta &lt; self.lienzo_ancho and sentido == 1:        \n            self.desplaz_x = velocidad_paleta\n\n    def mostrar(self):\n        self.juego.lienzo.move(self.juego.id_paleta, self.desplaz_x, 0)          \n\nvelocidad_bola=4\nvelocidad_paleta=5\nv = tkinter.Tk()\njuego = Juego(v)\njuego.bucle()\njuego.ventana.update_idletasks()\njuego.ventana.destroy()\n</code></pre> <p>Los a\u00f1adidos son pocos:</p> <ul> <li> <p>crear el texto en el lienzo, en unas coordenadas m\u00e1s o menos centradas:</p> <pre><code>texto = lienzo.create_text(250, 250, text='PULSE ESPACIO PARA INICIAR')\n</code></pre> </li> <li> <p>ocultarlo al activar el juego:</p> <pre><code>if evento.keysym=='space':            \n    self.en_juego = True\n    self.lienzo.itemconfig(self.texto, state='hidden')\n</code></pre> </li> <li> <p>volverlo a mostrar al finalizar el juego:</p> <pre><code>if borde_inf_bola &gt;= self.lienzo_alto:\n    self.juego.en_juego = False\n    self.juego.reiniciar = True\n    self.juego.lienzo.itemconfig(self.juego.texto, state='normal')\n</code></pre> </li> </ul>"},{"location":"017-10-Colisiones.html","title":"Gestionar colisi\u00f3n Bola-Paleta","text":"<p>Lleg\u00f3 el momento de la magia. Vamos a detectar cuando la bola toca la paleta, cambiar la direcci\u00f3n de la bola para que el desplazamiento sea hacia arriba.  Para darle m\u00e1s inter\u00e9s al juego, modificaremos el desplazamiento horizontal tomando uno al azar, de forma que el \u00e1ngulo de rebote sea aleatorio.</p> 10Colision.py<pre><code>import tkinter\nimport random\n\nclass Juego:\n    def __init__(self, ventana):\n        self.ventana = ventana\n\n        # Configurar ventana\n        self.ventana.title('Bola')\n        self.ventana.resizable(False, False)\n        self.ventana.wm_attributes('-topmost', True)\n\n        # Crear lienzo\n        self.lienzo = tkinter.Canvas(self.ventana,\n                                     width=500,\n                                     height=400,\n                                     bd=0)\n        self.lienzo.pack()\n        self.ventana.update()\n\n        # Crear bola y paleta\n        self.bola = Bola(self)\n        self.paleta = Paleta(self)        \n\n        # Indicadores\n        self.terminar = False\n        self.en_juego = False\n        self.reiniciar= False\n\n        self.texto = self.lienzo.create_text(250, 250, text='PULSE ESPACIO PARA INICIAR')\n\n        # Asociar eventos de teclado\n        self.ventana.bind_all('&lt;KeyPress&gt;', self.gestionar_tecla)\n        self.ventana.bind_all('&lt;KeyRelease&gt;', self.detener_paleta)\n\n    def gestionar_tecla(self,evento):\n        if evento.keysym=='Escape':\n            self.terminar = True\n        elif evento.keysym=='space':            \n            self.en_juego = True\n            self.lienzo.itemconfig(self.texto, state='hidden')\n        elif evento.keysym=='Left':\n            self.paleta.desplaz_paleta(-1)\n        elif evento.keysym=='Right':\n            self.paleta.desplaz_paleta(1)\n\n    def detener_paleta(self,evento):\n            self.paleta.desplaz_paleta(0)\n\n    def bucle(self):\n        while True:\n            if self.terminar:\n                break\n\n            if self.reiniciar and self.en_juego:\n                self.lienzo.delete(self.id_bola)\n                self.lienzo.delete(self.id_paleta)\n                self.bola = Bola(self)\n                self.paleta = Paleta(self)\n                self.reiniciar = False\n\n            if self.en_juego:\n                self.ventana.update_idletasks()\n                self.bola.mostrar()\n                self.paleta.mostrar()\n\n            self.ventana.update_idletasks()\n            self.ventana.update()\n\nclass Bola:\n    def __init__(self, juego):\n        self.juego  = juego\n\n        tama\u00f1o = 15\n        self.lienzo_ancho = self.juego.lienzo.winfo_width()\n        self.lienzo_alto = self.juego.lienzo.winfo_height()\n\n        self.juego.id_bola = self.juego.lienzo.create_oval(0, 0, tama\u00f1o, tama\u00f1o,\n                                                           fill='red')\n        centro_x = self.lienzo_ancho/2 - tama\u00f1o/2\n        centro_y = self.lienzo_alto/2 - tama\u00f1o/2\n        self.juego.lienzo.move(self.juego.id_bola, centro_x, centro_y)\n\n        self.desplaz_y = -(velocidad_bola)\n        self.desplaz_x = random.choice([-2, -3, -4, 2, 3, 4])\n\n    def mostrar(self):\n        # obtener coordenadas bola (x1, y1, x2, y2)\n        coord_bola = self.juego.lienzo.coords(self.juego.id_bola)\n        borde_sup_bola = coord_bola[1]\n        borde_inf_bola = coord_bola[3]\n        borde_izd_bola = coord_bola[0]\n        borde_dch_bola = coord_bola[2]\n\n        # si ha tocado el borde superior, empezar a bajar\n        if borde_sup_bola &lt;= 1:\n            self.desplaz_y = abs(self.desplaz_y)\n\n        ## si toca la paleta, empezar a subir\n        if self.toca_paleta():\n            direccion = 1 if abs(self.desplaz_x)== self.desplaz_x else -1\n            self.desplaz_x = random.choice([2, 3, 4])*direccion\n            self.desplaz_y = abs(self.desplaz_y)*(-1)\n\n        # si toca el borde inferior, fin del juego\n        if borde_inf_bola &gt;= self.lienzo_alto:\n            self.juego.en_juego = False\n            self.juego.reiniciar = True\n            self.juego.lienzo.itemconfig(self.juego.texto, state='normal')\n\n        # si ha tocado el borde lateral, cambiar de direcci\u00f3n\n        if borde_izd_bola &lt;= 1:\n            self.desplaz_x = abs(self.desplaz_x)\n        elif borde_dch_bola &gt;= self.lienzo_ancho-1:\n            self.desplaz_x = abs(self.desplaz_x)*(-1)\n\n        # desplazar\n        self.juego.lienzo.move(self.juego.id_bola, self.desplaz_x, self.desplaz_y)\n\n    def toca_paleta(self):\n        pos_bola = self.juego.lienzo.coords(self.juego.id_bola)\n        pos_paleta = self.juego.lienzo.coords(self.juego.id_paleta)\n\n        bola_sup = pos_bola[1]\n        bola_inf = pos_bola[3]\n        bola_izd = pos_bola[0]\n        bola_dch = pos_bola[2]\n\n        paleta_sup = pos_paleta[1]\n        paleta_inf = pos_paleta[3]\n        paleta_izd = pos_paleta[0]\n        paleta_dch = pos_paleta[2]\n\n        encima = bola_inf &lt; paleta_sup\n        debajo = bola_sup &gt; paleta_inf\n        izda   = bola_dch &lt; paleta_izd\n        dcha   = bola_izd &gt; paleta_dch\n\n        if debajo or encima:\n            return False\n        if izda or dcha:\n            return False\n        return True\n\nclass Paleta:\n    def __init__(self, juego):\n        self.juego  = juego\n\n        ancho = 60\n        self.lienzo_ancho = self.juego.lienzo.winfo_width()\n        self.lienzo_alto = self.juego.lienzo.winfo_height()\n\n        self.juego.id_paleta = self.juego.lienzo.create_rectangle(0, 0, ancho, 10, fill='blue')\n        self.desplaz = velocidad_paleta\n        self.desplaz_x = 0\n\n        centro_x = self.lienzo_ancho/2 - ancho/2\n        centro_y = self.lienzo_alto - 50\n\n        self.juego.lienzo.move(self.juego.id_paleta, centro_x, centro_y)\n\n    def desplaz_paleta(self, sentido):\n        if not self.juego.en_juego:\n            return\n\n        if sentido==0:\n            self.desplaz_x=0\n\n        coord = self.juego.lienzo.coords(self.juego.id_paleta)\n        borde_izd_paleta = coord[0]\n        borde_dch_paleta = coord[2]\n\n        self.desplaz_x = 0\n        if borde_izd_paleta &gt; 0 and sentido == -1:\n            self.desplaz_x = -velocidad_paleta\n\n        elif borde_dch_paleta &lt; self.lienzo_ancho and sentido == 1:        \n            self.desplaz_x = velocidad_paleta\n\n    def mostrar(self):\n        self.juego.lienzo.move(self.juego.id_paleta, self.desplaz_x, 0)          \n\nvelocidad_bola=4\nvelocidad_paleta=5\nv = tkinter.Tk()\njuego = Juego(v)\njuego.bucle()\njuego.ventana.update_idletasks()\njuego.ventana.destroy()\n</code></pre> <p>Creamos un nuevo m\u00e9todo <code>Bola.toca_paleta()</code>. Como la bola guarda una referencia al objeto juego, que a su vez mantiene referencias al canvas, y a las formas circulo y rect\u00e1ngulo que representan la bola y paleta, podemos calcular las coordenadas de ambas formas:</p> <pre><code>pos_bola = self.juego.lienzo.coords(self.juego.id_bola)\npos_paleta = self.juego.lienzo.coords(self.juego.id_paleta)\n</code></pre> <p>Con estas coordenadas podemos averiguar si ambas formas est\u00e1n colisionando o la bola est\u00e1 por encima, debajo, a la izquierda o derecha de la paleta.</p> <p>Nota: realmente lo que hacemos es comprobar que ambas formas no se  superpongan. Esto afecta ligeramente a la jugabilidad, porque la bola podr\u00eda colisionar con la paleta por el borde lateral de esta, rebotando hacia arriba. Una vez m\u00e1s, no vamos a complicar  el programa. Lo dejaremos as\u00ed.</p>"},{"location":"017-10-Colisiones.html#expresiones-condicionales","title":"Expresiones condicionales","text":"<p>En la sentencia:</p> <pre><code>direccion = 1 if abs(self.desplaz_x)== self.desplaz_x else -1\n</code></pre> <p>descubrimos una caracter\u00edstica del lenguaje Python que no hab\u00edamos visto  todav\u00eda, la posibilidad de evaluar una expresi\u00f3n que tiene dos posibles resultados, dependiendo de una condici\u00f3n:</p> <pre><code>variable = valor1 if condici\u00f3n else valor2\n</code></pre> <p>Se eval\u00faa la condici\u00f3n y el valor resultante es la primera expresi\u00f3n, si es True o la segunda, si False.</p>"},{"location":"017-11-Puntuacion.html","title":"A\u00f1adir puntuaci\u00f3n","text":"<p>Ahora que ya tenemos el juego funcional, vamos a mostrar una puntuaci\u00f3n en el margen inferior izquierdo de la ventana. Cada vez que la bola rebota en la paleta, adem\u00e1s de cambiar de direcci\u00f3n, sumamos un punto.</p> 11Puntuacion.py<pre><code>import tkinter\nimport random\n\nclass Juego:\n    def __init__(self, ventana):\n        self.ventana = ventana\n\n        # Configurar ventana\n        self.ventana.title('Bola')\n        self.ventana.resizable(False, False)\n        self.ventana.wm_attributes('-topmost', True)\n\n        # Crear lienzo\n        self.lienzo = tkinter.Canvas(self.ventana,\n                                     width=500,\n                                     height=400,\n                                     bd=0)\n        self.lienzo.pack()\n        self.ventana.update()\n\n        # Crear bola y paleta\n        self.bola = Bola(self)\n        self.paleta = Paleta(self)        \n\n        # Indicadores\n        self.terminar = False\n        self.en_juego = False\n        self.reiniciar= False\n        self.puntos=0\n        self.id_puntos = self.lienzo.create_text(\n                                10, 385,\n                                text=f'Puntuaci\u00f3n: {0}',\n                                fill='red',\n                                anchor='nw')        \n\n        self.texto = self.lienzo.create_text(250, 250, text='PULSE ESPACIO PARA INICIAR')\n\n        # Asociar eventos de teclado\n        self.ventana.bind_all('&lt;KeyPress&gt;', self.gestionar_tecla)\n        self.ventana.bind_all('&lt;KeyRelease&gt;', self.detener_paleta)\n\n    def gestionar_tecla(self,evento):\n        if evento.keysym=='Escape':\n            self.terminar = True\n        elif evento.keysym=='space':            \n            self.en_juego = True\n            self.lienzo.itemconfig(self.texto, state='hidden')\n        elif evento.keysym=='Left':\n            self.paleta.desplaz_paleta(-1)\n        elif evento.keysym=='Right':\n            self.paleta.desplaz_paleta(1)\n\n    def detener_paleta(self,evento):\n            self.paleta.desplaz_paleta(0)\n\n    def mostrar_puntos(self):\n            self.lienzo.itemconfig(self.id_puntos, text=f'Puntuaci\u00f3n: {self.puntos}')\n\n    def bucle(self):\n        while True:\n            if self.terminar:\n                break\n\n            if self.reiniciar and self.en_juego:\n                self.lienzo.delete(self.id_bola)\n                self.lienzo.delete(self.id_paleta)\n                self.bola = Bola(self)\n                self.paleta = Paleta(self)\n                self.reiniciar = False\n                self.puntos=0\n                self.mostrar_puntos()\n\n            if self.en_juego:\n                self.ventana.update_idletasks()\n                self.bola.mostrar()\n                self.paleta.mostrar()\n\n            self.ventana.update_idletasks()\n            self.ventana.update()\n\n\nclass Bola:\n    def __init__(self, juego):\n        self.juego  = juego\n\n        tama\u00f1o = 15\n        self.lienzo_ancho = self.juego.lienzo.winfo_width()\n        self.lienzo_alto = self.juego.lienzo.winfo_height()\n\n        self.juego.id_bola = self.juego.lienzo.create_oval(0, 0, tama\u00f1o, tama\u00f1o,\n                                                           fill='red')\n        centro_x = self.lienzo_ancho/2 - tama\u00f1o/2\n        centro_y = self.lienzo_alto/2 - tama\u00f1o/2\n        self.juego.lienzo.move(self.juego.id_bola, centro_x, centro_y)\n\n        self.desplaz_y = -(velocidad_bola)\n        self.desplaz_x = random.choice([-2, -3, -4, 2, 3, 4])\n\n    def mostrar(self):\n        # obtener coordenadas bola (x1, y1, x2, y2)\n        coord_bola = self.juego.lienzo.coords(self.juego.id_bola)\n        borde_sup_bola = coord_bola[1]\n        borde_inf_bola = coord_bola[3]\n        borde_izd_bola = coord_bola[0]\n        borde_dch_bola = coord_bola[2]\n\n        # si ha tocado el borde superior, empezar a bajar\n        if borde_sup_bola &lt;= 1:\n            self.desplaz_y = abs(self.desplaz_y)\n\n        ## si toca la paleta, empezar a subir\n        if self.toca_paleta():\n            direccion = 1 if abs(self.desplaz_x)== self.desplaz_x else -1\n            self.desplaz_x = random.choice([2, 3, 4]) * direccion\n            self.desplaz_y = abs(self.desplaz_y)*(-1)\n            self.juego.puntos += 1\n            self.juego.mostrar_puntos()\n\n        # si toca el borde inferior, fin del juego\n        if borde_inf_bola &gt;= self.lienzo_alto:\n            self.juego.en_juego = False\n            self.juego.reiniciar = True\n            self.juego.lienzo.itemconfig(self.juego.texto, state='normal')\n\n        # si ha tocado el borde lateral, cambiar de direcci\u00f3n\n        if borde_izd_bola &lt;= 1:\n            self.desplaz_x = abs(self.desplaz_x)\n        elif borde_dch_bola &gt;= self.lienzo_ancho-1:\n            self.desplaz_x = abs(self.desplaz_x)*(-1)\n\n        # desplazar\n        self.juego.lienzo.move(self.juego.id_bola, self.desplaz_x, self.desplaz_y)\n\n    def toca_paleta(self):\n        pos_bola = self.juego.lienzo.coords(self.juego.id_bola)\n        pos_paleta = self.juego.lienzo.coords(self.juego.id_paleta)\n\n        bola_sup = pos_bola[1]\n        bola_inf = pos_bola[3]\n        bola_izd = pos_bola[0]\n        bola_dch = pos_bola[2]\n\n        paleta_sup = pos_paleta[1]\n        paleta_inf = pos_paleta[3]\n        paleta_izd = pos_paleta[0]\n        paleta_dch = pos_paleta[2]\n\n        encima = bola_inf &lt; paleta_sup\n        debajo = bola_sup &gt; paleta_inf\n        izda   = bola_dch &lt; paleta_izd\n        dcha   = bola_izd &gt; paleta_dch\n\n        if debajo or encima:\n            return False\n        if izda or dcha:\n            return False\n        return True\n\nclass Paleta:\n    def __init__(self, juego):\n        self.juego  = juego\n\n        ancho = 60\n        self.lienzo_ancho = self.juego.lienzo.winfo_width()\n        self.lienzo_alto = self.juego.lienzo.winfo_height()\n\n        self.juego.id_paleta = self.juego.lienzo.create_rectangle(0, 0, ancho, 10, fill='blue')\n        self.desplaz = velocidad_paleta\n        self.desplaz_x = 0\n\n        centro_x = self.lienzo_ancho/2 - ancho/2\n        centro_y = self.lienzo_alto - 50\n\n        self.juego.lienzo.move(self.juego.id_paleta, centro_x, centro_y)\n\n    def desplaz_paleta(self, sentido):\n        if not self.juego.en_juego:\n            return\n\n        if sentido==0:\n            self.desplaz_x=0\n\n        coord = self.juego.lienzo.coords(self.juego.id_paleta)\n        borde_izd_paleta = coord[0]\n        borde_dch_paleta = coord[2]\n\n        self.desplaz_x = 0\n        if borde_izd_paleta &gt; 0 and sentido == -1:\n            self.desplaz_x = -velocidad_paleta\n\n        elif borde_dch_paleta &lt; self.lienzo_ancho and sentido == 1:        \n            self.desplaz_x = velocidad_paleta\n\n    def mostrar(self):\n        self.juego.lienzo.move(self.juego.id_paleta, self.desplaz_x, 0)          \n\nvelocidad_bola=4\nvelocidad_paleta=5\nv = tkinter.Tk()\njuego = Juego(v)\njuego.bucle()\njuego.ventana.update_idletasks()\njuego.ventana.destroy()\n</code></pre> <p>Al crear al juego, a\u00f1adimos un contador de puntos y un texto en el fondo del canvas:</p> <pre><code>self.puntos=0\nself.id_puntos = self.lienzo.create_text(\n                            10, 385,\n                            text=f'Puntuaci\u00f3n: {0}',\n                            fill='red',\n                            anchor='nw')\n</code></pre> <p>Cada vez que la pelota rebota en la paleta, sumamos un punto y refrescamos el texto:</p> <pre><code>self.juego.puntos += 1\nself.juego.mostrar_puntos()\n</code></pre> <p>Al reiniciar el juego, ponemos el contador a cero:</p> <pre><code>self.puntos=0\nself.mostrar_puntos()\n</code></pre> <p>Necesitamos que el juego tenga un m\u00e9todo <code>mostrar_puntos()</code>:</p> <pre><code>def mostrar_puntos(self):\n    self.lienzo.itemconfig(self.id_puntos, text=f'Puntuaci\u00f3n: {self.puntos}')\n</code></pre>"},{"location":"017-12-Nivel.html","title":"Acelerando el juego","text":"<p>Como paso final, vamos a acelerar el juego a medida que acumulamos puntos. Con cada 5 puntos, sumaremos 1 al desplazamiento vertical de la bola. Eso har\u00e1 que se mueva a mayor velocidad.</p> <p>A\u00f1adiremos un contador de niveles. Inicialmente tomar\u00e1 el valor de 1, y cada vez que incrementemos el desplazamiento, aumentaremos el nivel y lo  mostraremos en la barra de t\u00edtulo.</p> <p>Al reiniciar el juego, volveremos a poner el nivel a 1. No hace falta resetear el desplazamiento de la bola, porque estamos destruyendo los objetos bola y  paleta, y creando unos nuevos.</p> 12Nivel.py<pre><code>import tkinter\nimport random\n\nclass Juego:\n    def __init__(self, ventana):\n        self.ventana = ventana\n        self.nivel=1\n\n        # Configurar ventana\n        self.ventana.title('Bola (nivel '+str(self.nivel)+')')\n        self.ventana.resizable(False, False)\n        self.ventana.wm_attributes('-topmost', True)\n\n        # Crear lienzo\n        self.lienzo = tkinter.Canvas(self.ventana,\n                                     width=500,\n                                     height=400,\n                                     bd=0)\n        self.lienzo.pack()\n        self.ventana.update()\n\n        # Crear bola y paleta\n        self.bola = Bola(self)\n        self.paleta = Paleta(self)        \n\n        # Indicadores\n        self.terminar = False\n        self.en_juego = False\n        self.reiniciar= False\n        self.puntos=0\n        self.id_puntos = self.lienzo.create_text(\n                                10, 385,\n                                text=f'Puntuaci\u00f3n: {0}',\n                                fill='red',\n                                anchor='nw')        \n\n        self.texto = self.lienzo.create_text(250, 250, text='PULSE ESPACIO PARA INICIAR')\n\n        # Asociar eventos de teclado\n        self.ventana.bind_all('&lt;KeyPress&gt;', self.gestionar_tecla)\n        self.ventana.bind_all('&lt;KeyRelease&gt;', self.detener_paleta)\n\n    def gestionar_tecla(self,evento):\n        if evento.keysym=='Escape':\n            self.terminar = True\n        elif evento.keysym=='space':            \n            self.en_juego = True\n            self.lienzo.itemconfig(self.texto, state='hidden')\n        elif evento.keysym=='Left':\n            self.paleta.desplaz_paleta(-1)\n        elif evento.keysym=='Right':\n            self.paleta.desplaz_paleta(1)\n\n    def detener_paleta(self,evento):\n            self.paleta.desplaz_paleta(0)\n\n    def mostrar_puntos(self):\n            self.lienzo.itemconfig(self.id_puntos, text=f'Puntuaci\u00f3n: {self.puntos}')\n\n    def bucle(self):\n        while True:\n            if self.terminar:\n                break\n\n            if self.reiniciar and self.en_juego:\n                self.lienzo.delete(self.id_bola)\n                self.lienzo.delete(self.id_paleta)\n                self.bola = Bola(self)\n                self.paleta = Paleta(self)\n                self.reiniciar = False\n                self.puntos=0\n                self.mostrar_puntos()\n                self.nivel=1\n                self.ventana.title('Bola (nivel '+str(self.nivel)+')')\n\n            if self.en_juego:\n                self.ventana.update_idletasks()\n                self.bola.mostrar()\n                self.paleta.mostrar()\n\n            self.ventana.update_idletasks()\n            self.ventana.update()\n\n\nclass Bola:\n    def __init__(self, juego):\n        self.juego  = juego\n\n        tama\u00f1o = 15\n        self.lienzo_ancho = self.juego.lienzo.winfo_width()\n        self.lienzo_alto = self.juego.lienzo.winfo_height()\n\n        self.juego.id_bola = self.juego.lienzo.create_oval(0, 0, tama\u00f1o, tama\u00f1o,\n                                                           fill='red')\n        centro_x = self.lienzo_ancho/2 - tama\u00f1o/2\n        centro_y = self.lienzo_alto/2 - tama\u00f1o/2\n        self.juego.lienzo.move(self.juego.id_bola, centro_x, centro_y)\n\n        self.desplaz_y = -(velocidad_bola)\n        self.desplaz_x = random.choice([-2, -3, -4, 2, 3, 4])\n\n    def mostrar(self):\n        # obtener coordenadas bola (x1, y1, x2, y2)\n        coord_bola = self.juego.lienzo.coords(self.juego.id_bola)\n        borde_sup_bola = coord_bola[1]\n        borde_inf_bola = coord_bola[3]\n        borde_izd_bola = coord_bola[0]\n        borde_dch_bola = coord_bola[2]\n\n        # si ha tocado el borde superior, empezar a bajar\n        if borde_sup_bola &lt;= 1:\n            self.desplaz_y = abs(self.desplaz_y)\n\n        ## si toca la paleta, empezar a subir\n        if self.toca_paleta():\n            direccion = 1 if abs(self.desplaz_x)== self.desplaz_x else -1\n            self.desplaz_x = random.choice([2, 3, 4]) * direccion\n            self.desplaz_y = abs(self.desplaz_y)*(-1)\n            self.juego.puntos += 1\n            self.juego.mostrar_puntos()\n            if self.juego.puntos &gt; 1 and self.juego.puntos%5==0:\n                self.juego.nivel +=1\n                self.desplaz_y -=1\n                self.juego.ventana.title('Bola (nivel '+str(self.juego.nivel)+')')\n\n        # si toca el borde inferior, fin del juego\n        if borde_inf_bola &gt;= self.lienzo_alto:\n            self.juego.en_juego = False\n            self.juego.reiniciar = True\n            self.juego.lienzo.itemconfig(self.juego.texto, state='normal')\n\n        # si ha tocado el borde lateral, cambiar de direcci\u00f3n\n        if borde_izd_bola &lt;= 1:\n            self.desplaz_x = abs(self.desplaz_x)\n        elif borde_dch_bola &gt;= self.lienzo_ancho-1:\n            self.desplaz_x = abs(self.desplaz_x)*(-1)\n\n        # desplazar\n        self.juego.lienzo.move(self.juego.id_bola, self.desplaz_x, self.desplaz_y)\n\n    def toca_paleta(self):\n        pos_bola = self.juego.lienzo.coords(self.juego.id_bola)\n        pos_paleta = self.juego.lienzo.coords(self.juego.id_paleta)\n\n        bola_sup = pos_bola[1]\n        bola_inf = pos_bola[3]\n        bola_izd = pos_bola[0]\n        bola_dch = pos_bola[2]\n\n        paleta_sup = pos_paleta[1]\n        paleta_inf = pos_paleta[3]\n        paleta_izd = pos_paleta[0]\n        paleta_dch = pos_paleta[2]\n\n        encima = bola_inf &lt; paleta_sup\n        debajo = bola_sup &gt; paleta_inf\n        izda   = bola_dch &lt; paleta_izd\n        dcha   = bola_izd &gt; paleta_dch\n\n        if debajo or encima:\n            return False\n        if izda or dcha:\n            return False\n        return True\n\nclass Paleta:\n    def __init__(self, juego):\n        self.juego  = juego\n\n        ancho = 60\n        self.lienzo_ancho = self.juego.lienzo.winfo_width()\n        self.lienzo_alto = self.juego.lienzo.winfo_height()\n\n        self.juego.id_paleta = self.juego.lienzo.create_rectangle(0, 0, ancho, 10, fill='blue')\n        self.desplaz = velocidad_paleta\n        self.desplaz_x = 0\n\n        centro_x = self.lienzo_ancho/2 - ancho/2\n        centro_y = self.lienzo_alto - 50\n\n        self.juego.lienzo.move(self.juego.id_paleta, centro_x, centro_y)\n\n    def desplaz_paleta(self, sentido):\n        if not self.juego.en_juego:\n            return\n\n        if sentido==0:\n            self.desplaz_x=0\n\n        coord = self.juego.lienzo.coords(self.juego.id_paleta)\n        borde_izd_paleta = coord[0]\n        borde_dch_paleta = coord[2]\n\n        self.desplaz_x = 0\n        if borde_izd_paleta &gt; 0 and sentido == -1:\n            self.desplaz_x = -velocidad_paleta\n\n        elif borde_dch_paleta &lt; self.lienzo_ancho and sentido == 1:        \n            self.desplaz_x = velocidad_paleta\n\n    def mostrar(self):\n        self.juego.lienzo.move(self.juego.id_paleta, self.desplaz_x, 0)          \n\nvelocidad_bola=4\nvelocidad_paleta=5\nv = tkinter.Tk()\njuego = Juego(v)\njuego.bucle()\njuego.ventana.update_idletasks()\njuego.ventana.destroy()\n</code></pre>"},{"location":"017-13-Mejoras.html","title":"Mejorando el juego","text":"<p>Mi prop\u00f3sito al desarrollar este juego era puramente did\u00e1ctico, por lo que he intentado mantenerlo simple haciendo que, a la vez, sea jugable.</p> <p>Se pueden a\u00f1adir refinamientos hasta el infinito, pero eso ir\u00eda m\u00e1s all\u00e1 de este cuaderno. Entre otras mejoras, se me ocurren las siguientes:</p> <ul> <li> <p>Empaquetar el programa en formato binario para que se pueda distribuir     y sea utilizable en m\u00e1quinas que no tienen el int\u00e9rprete de Python.      Para esta labor podemos usar herramientas como      PyInstaller     o Briefcase, por ejemplo.</p> </li> <li> <p>Introducir peque\u00f1os ajustes en los desplazamientos de la bola y la     paleta para corregir algo que ya se ha mencionado, que los objetos no      se salgan del canvas, o que las colisiones laterales bola-paleta tengan     la respuesta adecuada.</p> </li> <li> <p>Vigilar el orden en que Tkinter gestiona los eventos de teclado cuando     pulsamos varias teclas a la vez.</p> </li> <li> <p>A\u00f1adir sonido. Hacer que se escuche un ligero chasquido cuando la bola toque     un borde de la pantalla o la paleta.</p> <p>Tkinter no cuenta con funciones para emitir sonidos, pero podr\u00edamos instalar e incorporar al juego alguna biblioteca, como por ejemplo  playsound3</p> <p>Lo instalar\u00edamos desde la ventana de comandos del sistema operativo:</p> <pre><code>pip install playsound3\n</code></pre> <p>y lo usar\u00edamos de la siguiente forma:</p> Playsound<pre><code>from playsound3 import playsound\n\n# Cargar y reproducir sonido\nplaysound(\"/carpeta/archivo.mp3\")\n</code></pre> <p>En Internet podemos encontrar multitud de archivos de sonido descargables.</p> </li> <li> <p>Usar Pygame en lugar de Tkinter.      Se trata de una biblioteca para desarrollar juegos 2D.</p> </li> </ul>"}]}